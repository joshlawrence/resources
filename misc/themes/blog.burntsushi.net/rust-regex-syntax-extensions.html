<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <title>Syntax extensions and regular expressions for Rust - Andrew Gallant&#39;s Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  
  <meta name="description" content="I blog mostly about my own programming projects.">
  
  <meta name="author" content="">
  <meta name="keywords" content="">
  <link rel="canonical" href="rust-regex-syntax-extensions.html">

  
  <link rel="stylesheet" type="text/css" href="css/basscss.css">
  <link rel="stylesheet" type="text/css" href="css/main.css">
  <link rel="stylesheet" type="text/css" href="css/chroma-fruity-light.css">
  <link rel="stylesheet" type="text/css" href="css/override.css">
</head>
<body class="">

<div class="site-wrap">
  <header class="site-header px2 px-responsive">
  <div class="mt2 wrap">
    <div class="measure">
      <a href="index.html" class="site-title">Andrew Gallant&#39;s Blog</a>
      <nav class="site-nav right">
      <a href="about/index.html">About</a>
<a href="projects/index.html">Projects</a>
<a href="https://github.com/BurntSushi">GitHub</a>


      </nav>
      <div class="clearfix"></div>
    </div>
  </div>
</header>

  <div class="post p2 p-responsive wrap" role="main">
    <div class="measure">
      <div class="post-header mb2">
        <h1>Syntax extensions and regular expressions for Rust</h1>
        <span class="post-meta">Apr 21, 2014</span><br>
        
      </div>

      <article class="post-content">
      <p><strong>WARNING:</strong> <!-- raw HTML omitted -->2018-04-12<!-- raw HTML omitted -->: The code snippets for this post are no longer
available. This is just as well anyway, since they all depended on an unstable
internal compiler interface, which hasn't existed for years.</p>
<p>A few weeks ago, I set out to add regular expressions to the
<a href="http://www.rust-lang.org/">Rust</a>
distribution with an implementation and feature set heavily inspired by
<a href="http://swtch.com/~rsc/regexp/">Russ Cox's RE2</a>.
It was just recently added to the
<a href="http://static.rust-lang.org/doc/master/regex/index.html">Rust distribution</a>.</p>
<p>This regex crate includes a syntax extension that compiles a regular expression
to native Rust code <em>when a Rust program is compiled</em>. This can be thought of
as &ldquo;ahead of time&rdquo; compilation or
something similar to <a href="http://en.wikipedia.org/wiki/Compile_time_function_execution">compile time function
execution</a>.
These special natively compiled regexes have the <em>same exact</em> API as regular
expressions compiled at runtime.</p>
<p>In this article, I will outline my implementation strategy&mdash;including code
samples on how to write a Rust syntax extension&mdash;and describe how I was able
to achieve an identical API between regexes compiled at compile time and
regexes compiled at runtime.</p>
<h3 id="brief-notes-on-format">Brief notes on format</h3>
<p>All code samples in this post compile with <code>rustc</code> from commit <code>8bc286</code>
(compiled on <code>2014-06-30, 21:16:32+0</code>).
Code samples with an <code>// Output:</code> comment are tested before uploaded.</p>
<p>Most code samples <em>should</em> correspond to a complete program that is
compilable. This makes samples a bit longer than they need to be, but I think
it's important to include complete working examples for a language still in
development and not (yet) widely known.</p>
<p>Note that Rust is still under heavy development. I will do my best to keep this
article updated with any breaking changes.</p>
<h3 id="how-a-regex-matcher-works">How a regex matcher works</h3>
<p>There are many different ways to implement a regular expression engine, so I
will just briefly outline how mine works, which should closely correspond to
RE2.</p>
<p>First, a regular expression is parsed and converted into an abstract syntax
tree. For example, the regex <code>a|b</code> might be represented as
<code>Alternate(Literal(a), Literal(b))</code>, which signifies &ldquo;match either <code>a</code> or <code>b</code>.&rdquo;
Second, the regex's abstract syntax is converted to a sequence of
instructions. This sequence of instructions can then be evaluated by a
<a href="http://swtch.com/~rsc/regexp/regexp2.html">virtual machine</a>
which will determine if a regex matches some text (and where it matches).</p>
<p>For the regex <code>a|b</code>, the sequence of instructions looks something like:</p>
<ul>
<li>1: Split(2, 4)</li>
<li>2: Char(a)</li>
<li>3: Jump(5)</li>
<li>4: Char(b)</li>
<li>5: Match</li>
</ul>
<p>In this case, <code>Split</code> means &ldquo;jump to two different instructions
simultaneously.&rdquo; In particular, if <em>either</em> branch executes the <code>Match</code>
instruction, then the entire regex will match. If both <code>Char</code> instructions
fail, then it's impossible to reach the <code>Match</code> instruction.</p>
<h3 id="clarifying-the-divide-native-regexes-vs-dynamic-regexes">Clarifying the divide: native regexes vs. dynamic regexes</h3>
<p>The word &ldquo;compiled&rdquo; is heavily overloaded, so it's worth making sure that we
get our terms straight. For example, in Python, you can <em>compile</em> a regular
expression with <code>re.compile(&quot;...&quot;)</code>, which is done at runtime, and converts the
pattern given into a data structure that is fed into a matching algorithm.
Often, it is good practice to compile a regular expression outside of loops
so that it doesn't have to go through the overhead of compilation each time the
expression is used to search text. (Assuming you don't want to rely on Python's
caching.)</p>
<p>This is emphatically <em>not</em> what I mean by compiling regexes &ldquo;ahead of time.&rdquo;
What I mean is the more literal translation: a regular expression is converted
to native Rust code when you compile your Rust program. That is, there is
(virtually) zero cost of compiling a regex during runtime. Perhaps more
importantly, because it's compiled to native Rust code, your regex will always
run faster. (I promise evidence of this claim with benchmarks toward the end of
this article.)</p>
<p>Let's clarify with an example. First, we can try compiling a regular expression
at runtime:</p>
<p>&lt;code
data-gist-id=&quot;11161035&rdquo;
data-gist-file=&quot;intro.rs&rdquo;
data-gist-hide-footer=&quot;true&rdquo;
data-gist-hide-line-numbers=&quot;true&rdquo;</p>
<blockquote>
<!-- raw HTML omitted -->
</blockquote>
<p>Notice that we call <code>Regex::new</code> to create a regex, and the call may fail if
the expression given isn't a valid regex. I call this a <em>dynamic</em> regex
because the regular expression compilation happens at runtime. This example is
analogous to Python's <code>re.compile</code>.</p>
<p>When a regular expression is compiled <em>dynamically</em>, it is converted to a
sequence of instructions that are
<a href="http://swtch.com/~rsc/regexp/regexp2.html">executed by a virtual machine</a>.
This virtual machine can execute <strong>any</strong> valid regular expression expressed as
a sequence of instructions.</p>
<p>In contrast, I've called regexes that are compiled to Rust code when your Rust
program compiles <em>native</em>. A native regex is indistinguishable from a dynamic
regex, except that it must be created with a <code>regex!</code> macro:</p>
<p>&lt;code
data-gist-id=&quot;11161035&rdquo;
data-gist-file=&quot;intro-aot.rs&rdquo;
data-gist-highlight-line=&quot;1,3,6&rdquo;
data-gist-hide-footer=&quot;true&rdquo;
data-gist-hide-line-numbers=&quot;true&rdquo;</p>
<blockquote>
<!-- raw HTML omitted -->
</blockquote>
<p>The highlighted lines indicate a change from the previous code sample.</p>
<p>(Note about Rust: Syntax extensions require a special compiler
directive <code>#[phase(plugin)]</code> to work. The <code>phase</code> directive must be enabled
explicitly: <code>#![feature(phase)]</code>.)</p>
<p>Notice that we no longer have to check if <code>regex!</code> returns an error because
all errors are converted to <em>compile time</em> errors. For example, the following
program will fail to compile:</p>
<p>&lt;code
data-gist-id=&quot;11161035&rdquo;
data-gist-file=&quot;unbalanced-paren.rs&rdquo;
data-gist-hide-footer=&quot;true&rdquo;
data-gist-hide-line-numbers=&quot;true&rdquo;</p>
<blockquote>
<!-- raw HTML omitted -->
</blockquote>
<p>The error given by <code>rustc</code>: <code>Regex syntax error near position 3: Unclosed parenthesis.</code></p>
<p>So what exactly does <code>regex!</code> expand to if not a sequence of instructions?
Well, remember the virtual machine I mentioned earlier that can execute a
sequence of instructions? That's precisely what <code>regex!</code> gets replaced with,
except it's <em>specialized</em> to the particular sequence of instructions
corresponding to the regular expression given. This specialization allows us to
perform optimizations such as removing heap allocation and embedding the
instructions directly instead of relying on a generalized algorithm.</p>
<p>If you want an example, you can take a look at how
<a href="https://gist.githubusercontent.com/BurntSushi/11161035/raw/unexpanded.rs">this
program</a>
expands the <code>regex!</code> macro into
<a href="https://gist.githubusercontent.com/BurntSushi/11161035/raw/expanded.rs">this
program</a>.
(It's not important to understand the expanded code, but it is notable that it
expands to a lot of code! If you have a lot of <code>regex!</code> calls in your program,
then you might see your binary size increase. But compiling with <code>-O</code>
optimization will help with that.)</p>
<p>Native regexes are pretty good. They provide extra safety (cannot compile a
program with an invalid regex) and extra performance. They do come with a
downside though: code bloat. If your program has a lot of <code>regex!</code> calls
(hundreds) and is compiled unoptimized, then you'll notice a bigger binary.
However, optimization can help shrink them back down.</p>
<h3 id="related-work">Related work</h3>
<p>Note that I am not the first to do this.
<a href="http://dlang.org/phobos/std_regex.html#.ctRegex">D has ctRegex</a> which claims
to do something similar.
There is also
<a href="http://www.boost.org/doc/libs/1_41_0/doc/html/xpressive/user_s_guide.html">xpressive</a>
in Boost, but native regexes must be written with template syntax.
Finally, there is also
<a href="http://weitz.de/cl-ppcre/">CL-PPCRE</a> for Common Lisp which also claims to have
native regexes.</p>
<p><a href="http://nimrod-lang.org/">Nimrod</a> seems like it is capable of producing native
regexes, but I don't think it has been done yet.</p>
<p>A related project is
<a href="http://www.complang.org/ragel/">Ragel</a>,
which can compile state machines to native code in a variety of languages.
In principle, Ragel is also producing native regexes, but my approach is
automated by the Rust compiler and provides an API identical to that of
dynamic regexes.</p>
<p>(Please alert me if I've missed anything.)</p>
<h3 id="native-regexes-are-implemented-with-macros">Native regexes are implemented with macros</h3>
<p>Rust has
<a href="http://en.wikipedia.org/wiki/Hygienic_macro">hygienic macros</a>,
but they can be written in one of two ways.
The first way is to use <code>macro_rules!</code> to conveniently specify some source
transformation with quasiquoting.
For example, here is how the <code>try!</code> macro is defined, which provides an easy
way to return early in a function that returns a value with type <code>Result&lt;T, E&gt;</code>:</p>
<p>&lt;code
data-gist-id=&quot;11161035&rdquo;
data-gist-file=&quot;try.rs&rdquo;
data-gist-hide-footer=&quot;true&rdquo;
data-gist-hide-line-numbers=&quot;true&rdquo;</p>
<blockquote>
<!-- raw HTML omitted -->
</blockquote>
<p>Notice the use of quasiquoting with <code>$e</code>. The expression <code>$e</code> is spliced into
the <code>match</code> expression <em>at compile time</em>. The quasiquoting in this case
distinguishes between something that parameterizes the macro at compile time
and the actual source code being written.</p>
<p>In general, if a macro can be written with <code>macro_rules!</code>, then it <em>should</em> be
written with <code>macro_rules!</code> because they are simple to write. However, they
are not powerful enough to implement native regexes because they are restricted
to source code transformations. To implement native regexes, we need to
actually compile a regular expression during the compilation of a Rust program.</p>
<p>Luckily, the second way to write a macro is via a syntax extension (also known
as a &ldquo;procedural macro&rdquo;). This is done by a compile time hook that lets you
execute arbitrary Rust code, rewrite the abstract syntax to whatever you want
and opens up access to the Rust compiler's parser. In short, you get a lot of
power. And it's enough to implement native regexes. The obvious drawback is
that they are more difficult to implement.</p>
<p>Note that <em>all</em> macros are invoked with the <code>name!</code> syntax, regardless of
whether they are defined with <code>macro_rules!</code> or as a syntax extension.</p>
<h3 id="setting-up-a-syntax-extension">Setting up a syntax extension</h3>
<p>Syntax extensions only became available to user programs a few months ago.
Before that, they were only available to the Rust compiler.
Thus, there is little documentation, so I've learned what I know by example and
by examining the
<a href="http://static.rust-lang.org/doc/master/syntax/index.html">syntax</a>
crate, which defines Rust's abstract syntax, provides a parser and the syntax
extension functionality itself. (Note that syntax extensions are currently an
experimental feature of Rust.)</p>
<p>Since there is a fair bit of boiler plate required, let's take a look at
implementing a trivial macro that returns the factorial of <code>5</code>:</p>
<p>&lt;code
data-gist-id=&quot;11161035&rdquo;
data-gist-file=&quot;lib-factorial_no_quote.rs&rdquo;
data-gist-hide-footer=&quot;true&rdquo;
data-gist-hide-line-numbers=&quot;true&rdquo;</p>
<blockquote>
<!-- raw HTML omitted -->
</blockquote>
<p>(N.B. There are some comments in the code above that explain some details.)</p>
<p>The magic happens with the <code>macro_registrar</code> function, which must be exported
and labelled with the special <code>#[macro_registrar]</code> attribute. This function is
where the compiler lets you register syntax extensions, which have a name and
provide a value of type <code>SyntaxExtension</code> which indicates the sort of expansion
that you intend to do. In this case, we're using <code>NormalTT</code>, which is a
function-like macro, but there
<a href="http://static.rust-lang.org/doc/master/syntax/ext/base/enum.SyntaxExtension.html">are
others</a>,
including the <code>macro_rules!</code> form.</p>
<p>Here, we register a single macro: <code>factorial</code>, which is <em>expanded</em> by the
<code>expand</code> function. The type of <code>expand</code> is specified by the <code>NormalTT</code>
expansion, which gives us an
<a href="http://static.rust-lang.org/doc/master/syntax/ext/base/struct.ExtCtxt.html">extension
context</a>
(e.g., the parsing state),
a
<a href="http://static.rust-lang.org/doc/master/syntax/codemap/struct.Span.html">span</a>
(e.g., a region of the actual code, used for error reporting)
and a
<a href="http://static.rust-lang.org/doc/master/syntax/ast/enum.TokenTree.html">token
tree</a>.
But most importantly, the <em>return value</em> is a
<a href="http://static.rust-lang.org/doc/master/syntax/ext/base/trait.MacResult.html"><code>Box&lt;MacResult&gt;</code></a>
(&ldquo;macro result&rdquo;), where <code>MacResult</code> is a trait.
Types that satisfy the <code>MacResult</code> trait can be automatically spliced into the
AST of a Rust program.
In this case, we're just creating an expression, so we can use the
<a href="http://static.rust-lang.org/doc/master/syntax/ext/base/struct.MacExpr.html">MacExpr</a>
helper type to construct a value that has type <code>Box&lt;MacResult&gt;</code>. Finally, we
see that <code>MacExpr::new</code> has type <code>Gc&lt;Expr&gt; -&gt; Box&lt;MacResult&gt;</code>. Ah ha! So if we
can build an expression, then we can build a <code>Box&lt;MacResult&gt;</code>, and therefore be
done with our macro expansion.</p>
<p>The body of the <code>expand</code> function shows how to manually create an expression
with a single integer literal. Even though the expression is very simple, I
wrote two helper functions <code>uint_literal</code> and <code>dummy_expr</code> to encapsulate some
of the more mundane details. If we have to go through this much work for just a
single literal, you might imagine that it gets very tedious pretty quickly.</p>
<p>But remember the quasiquoting that was available to use when defining macros
with <code>macro_rules!</code>? They are available to us here too, courtesy of the
<a href="http://static.rust-lang.org/doc/master/syntax/ext/quote/index.html"><code>syntax::ext::quote</code></a>
module. Here's the same syntax extension implemented using quasiquoting:</p>
<p>&lt;code
data-gist-id=&quot;11161035&rdquo;
data-gist-file=&quot;lib-factorial.rs&rdquo;
data-gist-hide-footer=&quot;true&rdquo;
data-gist-hide-line-numbers=&quot;true&rdquo;</p>
<blockquote>
<!-- raw HTML omitted -->
</blockquote>
<p>The <code>quote_expr!</code> macro does all the heavy lifting for us. It splices the
value of <code>answer</code> into an expression for us, handling all the nitty-gritty
details automatically. (We could also write, say, <code>$answer + 1</code> which would
produce an expression with an addition operation. The <code>$answer</code> part is
computed at compile time and the addition operation would be done at
runtime&mdash;if it isn't optimized away.) Fundamentally, the
quasiquoting works the same here as it does with <code>macro_rules!</code>.</p>
<p>(There is some
<a href="http://static.rust-lang.org/doc/master/syntax/ext/build/trait.AstBuilder.html">middle
ground</a>
between building the AST manually and using
quasiquoting, but I won't cover it here.)</p>
<p>And finally, we can actually <em>use</em> it with:</p>
<p>&lt;code
data-gist-id=&quot;11161035&rdquo;
data-gist-file=&quot;factorial.rs&rdquo;
data-gist-hide-footer=&quot;true&rdquo;
data-gist-hide-line-numbers=&quot;true&rdquo;</p>
<blockquote>
<!-- raw HTML omitted -->
</blockquote>
<p>The comments in the code explain some of the extra compiler directives we have
to write in order to import a syntax extension. (Note that this is no different
than importing the <code>log</code> crate from the Rust distribution, except that the
<code>log</code> crate requires <code>#[phase(syntax, link)]</code> because it provides more stuff
than just a syntax extension.)</p>
<h3 id="accessing-the-parser">Accessing the parser</h3>
<p>The above example demonstrates how to write a really simple&mdash;but pretty
useless&mdash;syntax extension. To write a useful syntax extension, we probably
need to define a macro that can accept arguments. With <code>macro_rules!</code>, this is
really easy because there's some convenient syntax similar to defining a
regular function. But in the land of syntax extensions, we must deal with
Rust's parser directly.</p>
<p>An obvious extension to our <code>factorial!</code> macro is to let it take an integer
argument so that we can compute any factorial. But how do we get the arguments
given to a macro defined as a syntax extension?</p>
<p>Well, if you look back at the last example, then you'll notice that the
<code>expand</code> function has a few parameters that we didn't use. One of which is a
sequence of token trees with type <code>&amp;[ast::TokenTree]</code>. Luckily, a sequence of
<code>ast::TokenTree</code> values can be used to build a parser with
<code>new_parser_from_tts</code> defined in the
<a href="http://static.rust-lang.org/doc/master/syntax/parse/index.html">syntax::parse</a>
module. With a parser, we can ask it for expressions&mdash;and once we have
expressions, we can translate those to real Rust values. In this case, that's
just going to be an integer.
(You can see the
<a href="http://static.rust-lang.org/doc/master/syntax/parse/parser/struct.Parser.html">parser API
here</a>,
and although it is largely undocumented, most of the names are reasonably
descriptive.)</p>
<p>Let's take a look at the code. The principal changes from the last example are
highlighted:</p>
<p>&lt;code
data-gist-id=&quot;11161035&rdquo;
data-gist-file=&quot;lib-factorial_arg.rs&rdquo;
data-gist-hide-footer=&quot;true&rdquo;
data-gist-hide-line-numbers=&quot;true&rdquo;
data-gist-highlight-line=&quot;999999999,20-25,35-65&rdquo;</p>
<blockquote>
<!-- raw HTML omitted -->
</blockquote>
<p>The first few changes are fairly trivial. This time, instead of hard-coding the
factorial of <code>5</code>, we parse an unsigned integer literal and pass that to the
<code>factorial</code> function. If a single unsigned integer literal could not be parsed,
then we return a
&ldquo;<a href="http://static.rust-lang.org/doc/master/syntax/ext/base/struct.DummyResult.html#method.expr">dummy
expression</a>&quot;.
The actual error is written to the parser state in <code>parse</code>. The code is
structured this way to allow the compiler to continue even if an error is
found.</p>
<p>The <code>parse</code> function shows how to create a parser from a sequence of token
trees. A single expression is parsed, and we use pattern matching to make sure
it corresponds to an unsigned integer literal.
(To figure out which value constructors to use in your patterns, you'll want to
dig into the
<a href="http://static.rust-lang.org/doc/master/syntax/ast/struct.Expr.html">ast::Expr</a>
documentation, specifically the <code>Expr_</code> type.)</p>
<p>After we find a literal, we make sure it's the last thing in the sequence of
token trees and then return the integer as a real Rust value with type <code>u64</code>.</p>
<p>If anything unexpected occurs, we log an error with the Rust compiler via the
<code>ExtCtxt</code> and return <code>None</code>. As a bonus, we use the <code>syntax::print::pprust</code>
module to pretty-print Rust expressions to make our error messages nicer.</p>
<p>Finally, the macro can be used the same way as last time, except we call
<code>factorial!</code> with an integer argument:</p>
<p>&lt;code
data-gist-id=&quot;11161035&rdquo;
data-gist-file=&quot;factorial_arg.rs&rdquo;
data-gist-hide-footer=&quot;true&rdquo;
data-gist-hide-line-numbers=&quot;true&rdquo;
data-gist-highlight-line=&quot;5&rdquo;</p>
<blockquote>
<!-- raw HTML omitted -->
</blockquote>
<p>This concludes the tutorial aspect of this article. Now we'll get back to
regexes.</p>
<h3 id="creating-the-regex-syntax-extension">Creating the <code>regex!</code> syntax extension</h3>
<p>Instead of going through the
<a href="https://github.com/mozilla/rust/blob/master/src/libregex_macros/lib.rs">full code
generator</a>,
which would require more explanation about how the virtual machine works,
I'll explain the representation of native regexes and how some of the
optimizations work.</p>
<p>But first, we must figure out how the <code>regex!</code> macro will be used. If possible,
it should reuse the existing
<a href="http://static.rust-lang.org/doc/master/regex/struct.Regex.html">API for the Regex
type</a>.
The benefit of this is that native regexes won't introduce any additional
complexity on top of dynamic regexes other than how they are constructed. The
<code>regex!</code> macro should also probably return an expression, so that we can write
things like <code>regex!(&quot;abc&quot;).is_match(&quot;xyz&quot;)</code>.</p>
<p>Perhaps we can construct a value with type <code>Regex</code>. If we could do that, then
we'd be done&mdash;because such values already support all the convenient matching,
splitting and replacing functions. So let's take a look at the representation
of a dynamic <code>Regex</code>:</p>
<p>&lt;code
data-gist-id=&quot;11161035&rdquo;
data-gist-file=&quot;rep-regex-dynamic.rs&rdquo;
data-gist-hide-footer=&quot;true&rdquo;
data-gist-hide-line-numbers=&quot;true&rdquo;
data-gist-line=&quot;2-1000&rdquo;</p>
<blockquote>
<!-- raw HTML omitted -->
</blockquote>
<p>The representation shown here is very simple: it's just a sequence of
instructions. The problem is that this representation is for <em>dynamic</em>
regexes. Remember that dynamic regexes work by being compiled to a sequence of
instructions that is then executed by a general virtual machine. The VM can be
thought of as a Rust function with type
<code>fn(insts: &amp;[Inst], search: &amp;str) -&gt; Captures</code>, where <code>Captures</code> is just the
location of matches in the <code>search</code> text.</p>
<p>Native regexes on the other hand should be native Rust code with <em>precisely the
same type</em> as above with one omission: the sequence of instructions. Why?
Because the sequence of instructions is encoded directly into the function by
the <code>regex!</code> syntax extension. Therefore, the type of a native regex VM would
have to be <code>fn(search: &amp;str) -&gt; Captures</code>.</p>
<p>So we're left with an interesting set of constraints. On the one hand, we have
a VM that can execute a sequence of instructions on search text, and on the
other, we have a specialized VM that just executes on search text. Since a
regex must be <em>either</em> dynamic or native, we can represent this state of
affairs with a sum type:</p>
<p>&lt;code
data-gist-id=&quot;11161035&rdquo;
data-gist-file=&quot;rep-regex-both.rs&rdquo;
data-gist-hide-footer=&quot;true&rdquo;
data-gist-hide-line-numbers=&quot;true&rdquo;
data-gist-line=&quot;2-1000&rdquo;</p>
<blockquote>
<!-- raw HTML omitted -->
</blockquote>
<p>And now we can easily write a function that executes a <code>Regex</code> on search text,
regardless of whether its dynamic or native:</p>
<p>&lt;code
data-gist-id=&quot;11161035&rdquo;
data-gist-file=&quot;rep-regex-exec.rs&rdquo;
data-gist-hide-footer=&quot;true&rdquo;
data-gist-hide-line-numbers=&quot;true&rdquo;
data-gist-line=&quot;12-1000&rdquo;</p>
<blockquote>
<!-- raw HTML omitted -->
</blockquote>
<p>These details of the representation are hidden from well behaving clients, and
therefore, dynamic and native regexes are indistinguishable.</p>
<h3 id="why-did-you-just-say-well-behaving-clients">Why did you just say &ldquo;well behaving clients&rdquo;?</h3>
<p>Shouldn't Rust's module system prevent clients from accessing parts of the
representation that aren't exported?</p>
<p>Herein lay the dirty little secret of the <code>regex_macros</code> crate: it <em>must</em>
be able to access the internal representation of a <code>Regex</code> (along with other
things, like the set of all instructions). But if you look at the public API
documentation, you'll not see any such details of the representation exposed.
This is because they are hidden using a special <code>#[doc(hidden)]</code> attribute,
but you can see that an
<a href="https://github.com/mozilla/rust/blob/master/src/libregex/lib.rs#L395">entire module of
things</a>
is exported for the exclusive benefit of the <code>regex_macros</code> crate.</p>
<p>Therefore, the &ldquo;well behaving clients&rdquo; qualification is necessary. Misbehaving
clients could
<a href="https://github.com/mozilla/rust/blob/master/src/libregex/re.rs#L103">access the internal representation of the Regex
type</a>, and
thereby distinguish between dynamic and native regexes.</p>
<p>(It'd be possible to ameliorate this somewhat by exposing a hidden constructor
function.)</p>
<h3 id="performance-optimizations">Performance optimizations</h3>
<p>This is still early days for the regex crate in Rust, but there are two primary
optimizations made with native regexes. The first is removing heap allocation.
Briefly, the general VM for dynamic regexes has a few places where it needs to
allocate things on the heap. Primarily, the allocation is for storing capture
groups (i.e., the location of submatches in search text). The heap allocation
is necessary because the dynamic VM doesn't know at compile time how many
capture groups any particular regex might have.</p>
<p>This of course is not the case for native regexes, since the regex is compiled
when your Rust program is compiled. Therefore, we can put all of the capture
group information on the stack using explicitly sized vectors (i.e., <code>[T, ..N]</code>). This removes all heap allocation (except for the return value).</p>
<p>The second optimization comes from encoding the instructions directly into one
big <code>match</code> expression based on the <em>position</em> of the instruction. This removes
a lot of small computations necessary to discover what the &ldquo;next&rdquo; instruction
is.</p>
<p>Some other smaller optimizations were made, such as removing conditional
branches based on flags set in a particular instruction (like case
insensitivity, multi-line mode, etc.) or converting a binary search on a
character class to a single <code>match</code> expression.</p>
<h3 id="benchmarks">Benchmarks</h3>
<p>As promised, here are some benchmarks run on an Intel i3930K:</p>
<p>&lt;code
data-gist-id=&quot;11161035&rdquo;
data-gist-file=&quot;bench-cmp&rdquo;
data-gist-hide-footer=&quot;true&rdquo;
data-gist-hide-line-numbers=&quot;true&rdquo;</p>
<blockquote>
<!-- raw HTML omitted -->
</blockquote>
<p>Native regexes provide a universal speedup.</p>
<p>The more interesting observation is that native regexes drastically reduce
constant factors associated with matching a particular regex against some text.
This is evidenced by the <code>easy_32</code>, <code>easy1_32</code>, <code>medium_32</code> and <code>hard_32</code>
benchmarks, where there is an order of magnitude improvement in almost all of
them.</p>
<p>These benchmarks in particular test a few different regexes (based on
particular optimizations related to literal prefixes) on 32 bytes of text.
As one might imagine, with such a small search string, constant factors are
likely to dominate the performance of the matching algorithm.
Not surprisingly, native regexes win big here&mdash;likely because there is almost
no heap allocation occurring.</p>
<h3 id="future-work">Future work</h3>
<p>There are still many more optimizations that can be performed:</p>
<ul>
<li>Creating a &ldquo;one pass&rdquo; NFA where no backtracking need occur.</li>
<li>Attempt to do state compression in the code generator via a more intelligent
analysis on the sequence of instructions.</li>
<li>The big one: implement a DFA, similar to how RE2/C++ works.</li>
</ul>
<h3 id="acknowledgements">Acknowledgements</h3>
<p>Many thanks to the following:</p>
<ul>
<li><a href="https://github.com/sfackler">Steven Fackler</a> for helping
me navigate the word of syntax extensions.</li>
<li><a href="https://github.com/eddyb">Eduard Burtescu</a> for helping me with the code
generator and talking through some future ideas for optimization.</li>
<li><a href="https://github.com/chris-morgan">Chris Morgan</a> for <a href="https://github.com/rust-lang/rfcs/pull/42#issuecomment-40301587">giving me the initial
idea</a> to
create native regexes.</li>
<li><a href="https://github.com/alexcrichton">Alex Crichton</a> for holding my hand through
the pull request process.</li>
<li><a href="http://swtch.com/~rsc/">Russ Cox</a> for blazing the trail and writing
an <strong>amazing</strong> <a href="http://swtch.com/~rsc/regexp">series of articles</a> on
implementing regular expression matching.</li>
</ul>
<h3 id="links">Links</h3>
<ul>
<li><a href="http://static.rust-lang.org/doc/master/regex/index.html">regex API
documentation</a>.</li>
<li>A <a href="https://gist.github.com/BurntSushi/11161035">gist of all code samples</a> in
this article.</li>
<li>Some rough numbers for the
<a href="https://github.com/BurntSushi/regexp/tree/master/benchmark/regex-dna">regex-dna</a>
benchmark, compared with Go, Python and C.</li>
<li>The
<a href="https://github.com/BurntSushi/burntsushi-blog/tree/master/posts/gists/rust-regex-syntax-extensions">infrastructure used to compile, check and upload</a>
code samples in this article automatically.</li>
</ul>
<h3 id="other-examples-of-syntax-extensions">Other examples of syntax extensions</h3>
<p>When documentation is scarce, the next best thing is to look at examples. Here
are the ones I know about:</p>
<ul>
<li><a href="https://github.com/sfackler/syntax-ext-talk/blob/gh-pages/simple-ext/lib.rs">simple-ext</a>
is an example of a syntax extension for sorting literal strings. You
can see it <a href="https://github.com/sfackler/syntax-ext-talk/blob/gh-pages/simple-ext/test.rs">used
here</a>.</li>
<li><a href="https://github.com/mozilla/rust/blob/master/src/libhexfloat/lib.rs">hexfloat</a>
for hexadecimal floating-point literals (part of Rust distribution).</li>
<li><a href="https://github.com/mozilla/rust/blob/master/src/libfourcc/lib.rs">fourcc</a>
four-character code library (part of Rust distribution).</li>
<li><a href="https://github.com/sfackler/rust-phf">rust-phf</a> implements compile time
static maps.</li>
</ul>
<p>Please ping me if you know of more examples. I'll add them here.</p>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
      </article>

      

    </div>
  </div>
</div>
    <footer class="footer">
      <div class="p2 wrap">
        <div class="measure mt1 center">
      <nav class="social-icons icons">
<a class="fa fa-rss rss" href="index.xml"></a>

</nav>

          <small>
            All content is dual licensed under the UNLICENSE and MIT licenses.<br>
            Powered by <a href="http://gohugo.io/" target="_blank">Hugo</a> &amp; <a href="https://github.com/azmelanar/hugo-theme-pixyll" target="_blank">Pixyll</a>
          </small>
        </div>
      </div>
    </footer>
</body>
</html>

