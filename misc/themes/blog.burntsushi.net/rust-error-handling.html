<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <title>Error Handling in Rust - Andrew Gallant&#39;s Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  
  <meta name="description" content="I blog mostly about my own programming projects.">
  
  <meta name="author" content="">
  <meta name="keywords" content="">
  <link rel="canonical" href="rust-error-handling.html">

  
  <link rel="stylesheet" type="text/css" href="css/basscss.css">
  <link rel="stylesheet" type="text/css" href="css/main.css">
  <link rel="stylesheet" type="text/css" href="css/chroma-fruity-light.css">
  <link rel="stylesheet" type="text/css" href="css/override.css">
</head>
<body class="">

<div class="site-wrap">
  <header class="site-header px2 px-responsive">
  <div class="mt2 wrap">
    <div class="measure">
      <a href="index.html" class="site-title">Andrew Gallant&#39;s Blog</a>
      <nav class="site-nav right">
      <a href="about/index.html">About</a>
<a href="projects/index.html">Projects</a>
<a href="https://github.com/BurntSushi">GitHub</a>


      </nav>
      <div class="clearfix"></div>
    </div>
  </div>
</header>

  <div class="post p2 p-responsive wrap" role="main">
    <div class="measure">
      <div class="post-header mb2">
        <h1>Error Handling in Rust</h1>
        <span class="post-meta">May 14, 2015</span><br>
        
      </div>

      <article class="post-content">
      <p>Like most programming languages, Rust encourages the programmer to handle
errors in a particular way. Generally speaking, error handling is divided into
two broad categories: exceptions and return values. Rust opts for return
values.</p>
<p>In this article, I intend to provide a comprehensive treatment of how to deal
with errors in Rust. More than that, I will attempt to introduce error handling
one piece at a time so that you'll come away with a solid working knowledge of
how everything fits together.</p>
<p>When done naively, error handling in Rust can be verbose and annoying. This
article will explore those stumbling blocks and demonstrate how to use the
standard library to make error handling concise and ergonomic.</p>
<p><strong>Target audience</strong>: Those new to Rust that don't know its error handling
idioms yet. Some familiarity with Rust is helpful. (This article makes heavy
use of some standard traits and some very light use of closures and macros.)</p>
<p><strong>Update (2018/04/14)</strong>: Examples were converted to <code>?</code>, and some text was
added to give historical context on the change.</p>
<p><strong>Update (2020/01/03)</strong>: A recommendation to use
<a href="https://crates.io/crates/failure"><code>failure</code></a> was removed and replaced with
a recommendation to use either <code>Box&lt;Error + Send + Sync&gt;</code> or
<a href="https://crates.io/crates/anyhow"><code>anyhow</code></a>.</p>
<h2 id="brief-notes">Brief notes</h2>
<p>All code samples in this post compile with Rust <code>1.0.0-beta.5</code>. They should
continue to work as Rust 1.0 stable is released.</p>
<p>All code can be found and compiled in
<a href="https://github.com/BurntSushi/blog/tree/master/code/rust-error-handling">my blog's repository</a>.</p>
<p>The <a href="http://doc.rust-lang.org/1.0.0-beta.5/book/">Rust Book</a>
has a <a href="http://doc.rust-lang.org/1.0.0-beta.5/book/error-handling.html">section on error
handling</a>.
It gives a very brief overview, but doesn't (yet) go into enough detail,
particularly when working with some of the more recent additions to the
standard library.</p>
<h2 id="run-the-code">Run the code!</h2>
<p>If you'd like to run any of the code samples below, then the following should
work:</p>



<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh">$ git clone git://github.com/BurntSushi/blog
$ <span class="nb">cd</span> blog/code/rust-error-handling
$ cargo run --bin NAME-OF-CODE-SAMPLE <span class="o">[</span> args ... <span class="o">]</span></code></pre></div>


<p>Each code sample is labeled with its name. (Code samples without a name aren't
available to be run this way. Sorry.)</p>
<h2 id="table-of-contents">Table of Contents</h2>
<p>This article is very long, mostly because I start at the very beginning with
sum types and combinators, and try to motivate the way Rust does error handling
incrementally. As such, programmers with experience in other expressive type
systems may want to jump around. Here's my very brief guide:</p>
<ul>
<li>If you're new to Rust, systems programming and expressive type systems, then
start at the beginning and work your way through. (If you're brand new, you
should probably read through the <a href="http://doc.rust-lang.org/1.0.0-beta.5/book/">Rust
book</a> first.)</li>
<li>If you've never seen Rust before but have experience with functional
languages (&ldquo;algebraic data types&rdquo; and &ldquo;combinators&rdquo; make you feel warm and
fuzzy), then you can probably skip right over the basics and start by
skimming <a href="rust-error-handling.html#working-with-multiple-error-types">multiple error types</a>, and work
you're way into a full read of
<a href="rust-error-handling.html#standard-library-traits-used-for-error-handling">standard library error
traits</a>.
(Skimming <a href="rust-error-handling.html#the-basics">the basics</a> might be a good idea to just get a feel
for the syntax if you've really never seen Rust before.)
You may need to <a href="http://doc.rust-lang.org/1.0.0-beta.5/book/">consult the Rust
book</a> for help with Rust
closures and macros.</li>
<li>If you're already experienced with Rust and just want the skinny on error
handling, then you can probably skip straight <a href="rust-error-handling.html#the-short-story">to the end</a>.
You may find it useful to skim the <a href="rust-error-handling.html#case-study-a-program-to-read-population-data">case
study</a> for examples.</li>
</ul>
<hr>
<ul>
<li><a href="rust-error-handling.html#the-basics">The Basics</a>
<ul>
<li><a href="rust-error-handling.html#unwrapping-explained">Unwrapping explained</a></li>
<li><a href="rust-error-handling.html#the-option-type">The <code>Option</code> type</a>
<ul>
<li><a href="rust-error-handling.html#composing-option-t-values">Composing <code>Option&lt;T&gt;</code> values</a></li>
</ul>
</li>
<li><a href="rust-error-handling.html#the-result-type">The <code>Result</code> type</a>
<ul>
<li><a href="rust-error-handling.html#parsing-integers">Parsing integers</a></li>
<li><a href="rust-error-handling.html#the-result-type-alias-idiom">The <code>Result</code> type alias idiom</a></li>
</ul>
</li>
<li><a href="rust-error-handling.html#a-brief-interlude-unwrapping-isn-t-evil">A brief interlude: unwrapping isn't evil</a></li>
</ul>
</li>
<li><a href="rust-error-handling.html#working-with-multiple-error-types">Working with multiple error types</a>
<ul>
<li><a href="rust-error-handling.html#composing-option-and-result">Composing <code>Option</code> and <code>Result</code></a></li>
<li><a href="rust-error-handling.html#the-limits-of-combinators">The limits of combinators</a></li>
<li><a href="rust-error-handling.html#early-returns">Early returns</a></li>
<li><a href="rust-error-handling.html#the-try-macro-operator">The <code>try!</code> macro/<code>?</code> operator</a></li>
<li><a href="rust-error-handling.html#defining-your-own-error-type">Defining your own error type</a></li>
</ul>
</li>
<li><a href="rust-error-handling.html#standard-library-traits-used-for-error-handling">Standard library traits used for error handling</a>
<ul>
<li><a href="rust-error-handling.html#the-error-trait">The <code>Error</code> trait</a></li>
<li><a href="rust-error-handling.html#the-from-trait">The <code>From</code> trait</a></li>
<li><a href="rust-error-handling.html#the-real-try-macro-operator">The real <code>try!</code> macro/<code>?</code> operator</a></li>
<li><a href="rust-error-handling.html#composing-custom-error-types">Composing custom error types</a></li>
<li><a href="rust-error-handling.html#advice-for-library-writers">Advice for library writers</a></li>
</ul>
</li>
<li><a href="rust-error-handling.html#case-study-a-program-to-read-population-data">Case study: A program to read population data</a>
<ul>
<li><a href="rust-error-handling.html#it-s-on-github">It's on Github</a></li>
<li><a href="rust-error-handling.html#initial-setup">Initial setup</a></li>
<li><a href="rust-error-handling.html#argument-parsing">Argument parsing</a></li>
<li><a href="rust-error-handling.html#writing-the-logic">Writing the logic</a></li>
<li><a href="rust-error-handling.html#error-handling-with-box-error">Error handling with <code>Box&lt;Error&gt;</code></a></li>
<li><a href="rust-error-handling.html#reading-from-stdin">Reading from stdin</a></li>
<li><a href="rust-error-handling.html#error-handling-with-a-custom-type">Error handling with a custom type</a></li>
<li><a href="rust-error-handling.html#adding-functionality">Adding functionality</a></li>
</ul>
</li>
<li><a href="rust-error-handling.html#the-short-story">The short story</a></li>
</ul>
<h2 id="the-basics">The Basics</h2>
<p>I like to think of error handling as using <em>case analysis</em> to determine whether
a computation was successful or not. As we will see, the key to ergonomic error
handling is reducing the amount of explicit case analysis the programmer has to
do while keeping code composable.</p>
<p>Keeping code composable is important, because without that requirement, we
could <a href="http://doc.rust-lang.org/std/macro.panic!.html"><code>panic</code></a> whenever we
come across something unexpected. (<code>panic</code> causes the current task to unwind,
and in most cases, the entire program aborts.) Here's an example:</p>

  <div class="named-code" id="code-panic-simple">

  <span class="named-code-name">panic-simple</span>
  <div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="c1">// Guess a number between 1 and 10.
</span><span class="c1"></span><span class="c1">// If it matches the number I had in mind, return true. Else, return false.
</span><span class="c1"></span><span class="k">fn</span> <span class="nf">guess</span><span class="p">(</span><span class="n">n</span>: <span class="kt">i32</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">bool</span> <span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">|</span><span class="o">|</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">10</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="n">panic</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;Invalid number: {}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="n">n</span><span class="w"> </span><span class="o">=</span><span class="o">=</span><span class="w"> </span><span class="mi">5</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">main</span><span class="p">(</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="n">guess</span><span class="p">(</span><span class="mi">11</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div>
</div>

<p>(If you like, it's easy to <a href="rust-error-handling.html#run-the-code">run this code</a>.)</p>
<p>If you try running this code, the program will crash with a message like this:</p>



<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh">thread <span class="s1">&#39;&lt;main&gt;&#39;</span> panicked at <span class="s1">&#39;Invalid number: 11&#39;</span>, src/bin/panic-simple.rs:5</code></pre></div>


<p>Here's another example that is slightly less contrived. A program that accepts
an integer as an argument, doubles it and prints it.</p>

  <div class="named-code" id="code-unwrap-double">

  <span class="named-code-name">unwrap-double</span>
  <div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">env</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">main</span><span class="p">(</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">argv</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">env</span>::<span class="n">args</span><span class="p">(</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">arg</span>: <span class="nb">String</span> <span class="o">=</span><span class="w"> </span><span class="n">argv</span><span class="p">.</span><span class="n">nth</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="p">.</span><span class="n">unwrap</span><span class="p">(</span><span class="p">)</span><span class="p">;</span><span class="w"> </span><span class="c1">// error 1
</span><span class="c1"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">n</span>: <span class="kt">i32</span> <span class="o">=</span><span class="w"> </span><span class="n">arg</span><span class="p">.</span><span class="n">parse</span><span class="p">(</span><span class="p">)</span><span class="p">.</span><span class="n">unwrap</span><span class="p">(</span><span class="p">)</span><span class="p">;</span><span class="w"> </span><span class="c1">// error 2
</span><span class="c1"></span><span class="w">    </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;{}&#34;</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="c1">// $ cargo run --bin unwrap-double 5
</span><span class="c1"></span><span class="c1">// 10
</span></code></pre></div>
</div>

<p>If you give this program zero arguments (error 1) or if the first argument
isn't an integer (error 2), the program will panic just like in the first
example.</p>
<p>I like to think of this style of error handling as similar to a bull running
through a china shop. The bull will get to where it wants to go, but it will
trample everything in the process.</p>
<h3 id="unwrapping-explained">Unwrapping explained</h3>
<p>In the previous example (<a href="rust-error-handling.html#code-unwrap-double"><code>unwrap-double</code></a>), I claimed
that the program would simply panic if it reached one of the two error
conditions, yet, the program does not include an explicit call to <code>panic</code> like
the first example (<a href="rust-error-handling.html#code-panic-simple"><code>panic-simple</code></a>). This is because the
panic is embedded in the calls to <code>unwrap</code>.</p>
<p>To &ldquo;unwrap&rdquo; something in Rust is to say, &ldquo;Give me the result of the
computation, and if there was an error, just panic and stop the program.&rdquo;
It would be better if I just showed the code for unwrapping because it is so
simple, but to do that, we will first need to explore the <code>Option</code> and <code>Result</code>
types. Both of these types have a method called <code>unwrap</code> defined on them.</p>
<h3 id="the-option-type">The <code>Option</code> type</h3>
<p>The <code>Option</code> type is
<a href="http://doc.rust-lang.org/std/option/enum.Option.html">defined in the standard library</a>:</p>

  <div class="named-code" id="code-option-def">

  <span class="named-code-name">option-def</span>
  <div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">enum</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="nb">None</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="nb">Some</span><span class="p">(</span><span class="n">T</span><span class="p">)</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div>
</div>

<p>The <code>Option</code> type is a way to use Rust's type system to express the
<em>possibility of absence</em>. Encoding the possibility of absence into the type
system is an important concept because it will cause the compiler to force the
programmer to handle that absence. Let's take a look at an example that tries
to find a character in a string:</p>

  <div class="named-code" id="code-option-ex-string-find-1">

  <span class="named-code-name">option-ex-string-find</span>
  <div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="c1">// Searches `haystack` for the Unicode character `needle`. If one is found, the
</span><span class="c1"></span><span class="c1">// byte offset of the character is returned. Otherwise, `None` is returned.
</span><span class="c1"></span><span class="k">fn</span> <span class="nf">find</span><span class="p">(</span><span class="n">haystack</span>: <span class="kp">&amp;</span><span class="kt">str</span><span class="p">,</span><span class="w"> </span><span class="n">needle</span>: <span class="nc">char</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Option</span><span class="o">&lt;</span><span class="kt">usize</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">offset</span><span class="p">,</span><span class="w"> </span><span class="n">c</span><span class="p">)</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">haystack</span><span class="p">.</span><span class="n">char_indices</span><span class="p">(</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">=</span><span class="o">=</span><span class="w"> </span><span class="n">needle</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="n">offset</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="nb">None</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div>
</div>

<p>(Pro-tip: don't use this code. Instead, use the
<a href="http://doc.rust-lang.org/std/primitive.str.html#method.find"><code>find</code></a>
method from the standard library.)</p>
<p>Notice that when this function finds a matching character, it doesn't just
return the <code>offset</code>. Instead, it returns <code>Some(offset)</code>. <code>Some</code> is a variant or
a <em>value constructor</em> for the <code>Option</code> type. You can think of it as a function
with the type <code>fn&lt;T&gt;(value: T) -&gt; Option&lt;T&gt;</code>. Correspondingly, <code>None</code> is also a
value constructor, except it has no arguments. You can think of <code>None</code> as a
function with the type <code>fn&lt;T&gt;() -&gt; Option&lt;T&gt;</code>.</p>
<p>This might seem like much ado about nothing, but this is only half of the
story. The other half is <em>using</em> the <code>find</code> function we've written. Let's try
to use it to find the extension in a file name.</p>

  <div class="named-code" id="code-option-ex-string-find-2">

  <span class="named-code-name">option-ex-string-find</span>
  <div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">main_find</span><span class="p">(</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">file_name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&#34;foobar.rs&#34;</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="k">match</span><span class="w"> </span><span class="n">find</span><span class="p">(</span><span class="n">file_name</span><span class="p">,</span><span class="w"> </span><span class="sc">&#39;.&#39;</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="nb">None</span><span class="w"> </span><span class="o">=</span><span class="o">&gt;</span><span class="w"> </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;No file extension found.&#34;</span><span class="p">)</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="nb">Some</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="o">&gt;</span><span class="w"> </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;File extension: {}&#34;</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">file_name</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">.</span><span class="p">.</span><span class="p">]</span><span class="p">)</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div>
</div>

<p>This code uses <a href="http://doc.rust-lang.org/1.0.0-beta.5/book/patterns.html">pattern
matching</a> to do <em>case
analysis</em> on the <code>Option&lt;usize&gt;</code> returned by the <code>find</code> function. In fact, case
analysis is the only way to get at the value stored inside an <code>Option&lt;T&gt;</code>. This
means that you, as the programmer, must handle the case when an <code>Option&lt;T&gt;</code> is
<code>None</code> instead of <code>Some(t)</code>.</p>
<p>But wait, what about <code>unwrap</code> used in <a href="rust-error-handling.html#code-unwrap-double"><code>unwrap-double</code></a>?
There was no case analysis there! Instead, the case analysis was put inside the
<code>unwrap</code> method for you. You could define it yourself if you want:</p>

  <div class="named-code" id="code-option-def-unwrap">

  <span class="named-code-name">option-def-unwrap</span>
  <div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">enum</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="nb">None</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="nb">Some</span><span class="p">(</span><span class="n">T</span><span class="p">)</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="nb">Option</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="k">fn</span> <span class="nf">unwrap</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">T</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="k">match</span><span class="w"> </span><span class="bp">self</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">            </span><span class="nb">Option</span>::<span class="nb">Some</span><span class="p">(</span><span class="n">val</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="o">&gt;</span><span class="w"> </span><span class="n">val</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">            </span><span class="nb">Option</span>::<span class="nb">None</span><span class="w"> </span><span class="o">=</span><span class="o">&gt;</span><span class="w">
</span><span class="w"></span><span class="w">              </span><span class="n">panic</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;called `Option::unwrap()` on a `None` value&#34;</span><span class="p">)</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div>
</div>

<p>The <code>unwrap</code> method <em>abstracts away the case analysis</em>. This is precisely the thing
that makes <code>unwrap</code> ergonomic to use. Unfortunately, that <code>panic!</code> means that
<code>unwrap</code> is not composable: it is the bull in the china shop.</p>
<h4 id="composing-optiont-values">Composing <code>Option&lt;T&gt;</code> values</h4>
<p>In
<a href="rust-error-handling.html#code-option-ex-string-find-2"><code>option-ex-string-find</code></a>
we saw how to use <code>find</code> to discover the extension in a file name. Of course,
not all file names have a <code>.</code> in them, so it's possible that the file name has
no extension. This <em>possibility of absence</em> is encoded into the types using
<code>Option&lt;T&gt;</code>. In other words, the compiler will force us to address the
possibility that an extension does not exist. In our case, we just print out a
message saying as such.</p>
<p>Getting the extension of a file name is a pretty common operation, so it makes
sense to put it into a function:</p>

  <div class="named-code" id="code-option-ex-string-find-3">

  <span class="named-code-name">option-ex-string-find</span>
  <div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="c1">// Returns the extension of the given file name, where the extension is defined
</span><span class="c1"></span><span class="c1">// as all characters succeeding the first `.`.
</span><span class="c1"></span><span class="c1">// If `file_name` has no `.`, then `None` is returned.
</span><span class="c1"></span><span class="k">fn</span> <span class="nf">extension_explicit</span><span class="p">(</span><span class="n">file_name</span>: <span class="kp">&amp;</span><span class="kt">str</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Option</span><span class="o">&lt;</span><span class="o">&amp;</span><span class="kt">str</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="k">match</span><span class="w"> </span><span class="n">find</span><span class="p">(</span><span class="n">file_name</span><span class="p">,</span><span class="w"> </span><span class="sc">&#39;.&#39;</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="nb">None</span><span class="w"> </span><span class="o">=</span><span class="o">&gt;</span><span class="w"> </span><span class="nb">None</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="nb">Some</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="o">&gt;</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="o">&amp;</span><span class="n">file_name</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">.</span><span class="p">.</span><span class="p">]</span><span class="p">)</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div>
</div>

<p>(Pro-tip: don't use this code. Use the
<a href="http://doc.rust-lang.org/std/path/struct.Path.html#method.extension"><code>extension</code></a>
method in the standard library instead.)</p>
<p>The code stays simple, but the important thing to notice is that the type of
<code>find</code> forces us to consider the possibility of absence. This is a good thing
because it means the compiler won't let us accidentally forget about the case
where a file name doesn't have an extension. On the other hand, doing explicit
case analysis like we've done in <code>extension_explicit</code> every time can get a bit
tiresome.</p>
<p>In fact, the case analysis in <code>extension_explicit</code> follows a very common
pattern: <em>map</em> a function on to the value inside of an <code>Option&lt;T&gt;</code>, unless the
option is <code>None</code>, in which case, just return <code>None</code>.</p>
<p>Rust has parametric polymorphism, so it is very easy to define a combinator
that abstracts this pattern:</p>

  <div class="named-code" id="code-option-map">

  <span class="named-code-name">option-map</span>
  <div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">map</span><span class="o">&lt;</span><span class="n">F</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="n">A</span><span class="o">&gt;</span><span class="p">(</span><span class="n">option</span>: <span class="nb">Option</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">,</span><span class="w"> </span><span class="n">f</span>: <span class="nc">F</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Option</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;</span><span class="w"> </span><span class="k">where</span><span class="w"> </span><span class="n">F</span>: <span class="nb">FnOnce</span><span class="p">(</span><span class="n">T</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">A</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="k">match</span><span class="w"> </span><span class="n">option</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="nb">None</span><span class="w"> </span><span class="o">=</span><span class="o">&gt;</span><span class="w"> </span><span class="nb">None</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="nb">Some</span><span class="p">(</span><span class="n">value</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="o">&gt;</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">value</span><span class="p">)</span><span class="p">)</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div>
</div>

<p>Indeed, <code>map</code> is
<a href="http://doc.rust-lang.org/std/option/enum.Option.html#method.map">defined as a
method</a>
on <code>Option&lt;T&gt;</code> in the standard library.</p>
<p>Armed with our new combinator, we can rewrite our <code>extension_explicit</code> method
to get rid of the case analysis:</p>

  <div class="named-code" id="code-option-ex-string-find-4">

  <span class="named-code-name">option-ex-string-find</span>
  <div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="c1">// Returns the extension of the given file name, where the extension is defined
</span><span class="c1"></span><span class="c1">// as all characters succeeding the first `.`.
</span><span class="c1"></span><span class="c1">// If `file_name` has no `.`, then `None` is returned.
</span><span class="c1"></span><span class="k">fn</span> <span class="nf">extension</span><span class="p">(</span><span class="n">file_name</span>: <span class="kp">&amp;</span><span class="kt">str</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Option</span><span class="o">&lt;</span><span class="o">&amp;</span><span class="kt">str</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="n">find</span><span class="p">(</span><span class="n">file_name</span><span class="p">,</span><span class="w"> </span><span class="sc">&#39;.&#39;</span><span class="p">)</span><span class="p">.</span><span class="n">map</span><span class="p">(</span><span class="o">|</span><span class="n">i</span><span class="o">|</span><span class="w"> </span><span class="o">&amp;</span><span class="n">file_name</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">.</span><span class="p">.</span><span class="p">]</span><span class="p">)</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div>
</div>

<p>One other pattern that I find is very common is assigning a default value to
the case when an <code>Option</code> value is <code>None</code>. For example, maybe your program
assumes that the extension of a file is <code>rs</code> even if none is present. As you
might imagine, the case analysis for this is not specific to file
extensions&mdash;it can work with any <code>Option&lt;T&gt;</code>:</p>

  <div class="named-code" id="code-option-unwrap-or">

  <span class="named-code-name">option-unwrap-or</span>
  <div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">unwrap_or</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">option</span>: <span class="nb">Option</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">,</span><span class="w"> </span><span class="n">default</span>: <span class="nc">T</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">T</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="k">match</span><span class="w"> </span><span class="n">option</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="nb">None</span><span class="w"> </span><span class="o">=</span><span class="o">&gt;</span><span class="w"> </span><span class="n">default</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="nb">Some</span><span class="p">(</span><span class="n">value</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="o">&gt;</span><span class="w"> </span><span class="n">value</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div>
</div>

<p>The trick here is that the default value must have the same type as the value
that might be inside the <code>Option&lt;T&gt;</code>. Using it is dead simple in our case:</p>

  <div class="named-code" id="code-option-ex-string-find-5">

  <span class="named-code-name">option-ex-string-find</span>
  <div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">main</span><span class="p">(</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="n">extension</span><span class="p">(</span><span class="s">&#34;foobar.csv&#34;</span><span class="p">)</span><span class="p">.</span><span class="n">unwrap_or</span><span class="p">(</span><span class="s">&#34;rs&#34;</span><span class="p">)</span><span class="p">,</span><span class="w"> </span><span class="s">&#34;csv&#34;</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="n">extension</span><span class="p">(</span><span class="s">&#34;foobar&#34;</span><span class="p">)</span><span class="p">.</span><span class="n">unwrap_or</span><span class="p">(</span><span class="s">&#34;rs&#34;</span><span class="p">)</span><span class="p">,</span><span class="w"> </span><span class="s">&#34;rs&#34;</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div>
</div>

<p>(Note that <code>unwrap_or</code> is
<a href="http://doc.rust-lang.org/std/option/enum.Option.html#method.unwrap_or">defined as a
method</a>
on <code>Option&lt;T&gt;</code> in the standard library, so we use that here instead of the
free-standing function we defined above. Don't forget to check out the more
general
<a href="http://doc.rust-lang.org/std/option/enum.Option.html#method.unwrap_or_else"><code>unwrap_or_else</code></a>
method.)</p>
<p>There is one more combinator that I think is worth paying special attention to:
<code>and_then</code>. It makes it easy to compose distinct computations that admit the
<em>possibility of absence</em>. For example, much of the code in this section is
about finding an extension given a file name. In order to do this, you first
need the file name which is typically extracted from a file <em>path</em>. While most
file paths have a file name, not <em>all</em> of them do. For example, <code>.</code>, <code>..</code> or
<code>/</code>.</p>
<p>So, we are tasked with the challenge of finding an extension given a file
<em>path</em>. Let's start with explicit case analysis:</p>

  <div class="named-code" id="code-option-ex-string-find-6">

  <span class="named-code-name">option-ex-string-find</span>
  <div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">file_path_ext_explicit</span><span class="p">(</span><span class="n">file_path</span>: <span class="kp">&amp;</span><span class="kt">str</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Option</span><span class="o">&lt;</span><span class="o">&amp;</span><span class="kt">str</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="k">match</span><span class="w"> </span><span class="n">file_name</span><span class="p">(</span><span class="n">file_path</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="nb">None</span><span class="w"> </span><span class="o">=</span><span class="o">&gt;</span><span class="w"> </span><span class="nb">None</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="nb">Some</span><span class="p">(</span><span class="n">name</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="o">&gt;</span><span class="w"> </span><span class="k">match</span><span class="w"> </span><span class="n">extension</span><span class="p">(</span><span class="n">name</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">            </span><span class="nb">None</span><span class="w"> </span><span class="o">=</span><span class="o">&gt;</span><span class="w"> </span><span class="nb">None</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">            </span><span class="nb">Some</span><span class="p">(</span><span class="n">ext</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="o">&gt;</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="n">ext</span><span class="p">)</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">file_name</span><span class="p">(</span><span class="n">file_path</span>: <span class="kp">&amp;</span><span class="kt">str</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Option</span><span class="o">&lt;</span><span class="o">&amp;</span><span class="kt">str</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">  </span><span class="c1">// implementation elided
</span><span class="c1"></span><span class="w">  </span><span class="n">unimplemented</span><span class="o">!</span><span class="p">(</span><span class="p">)</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div>
</div>

<p>You might think that we could just use the <code>map</code> combinator to reduce the case
analysis, but its type doesn't quite fit. Namely, <code>map</code> takes a function that
does something only with the inner value. The result of that function is then
<em>always</em> <a href="rust-error-handling.html#code-option-map">rewrapped with <code>Some</code></a>. Instead, we need something
like <code>map</code>, but which allows the caller to return another <code>Option</code>. Its generic
implementation is even simpler than <code>map</code>:</p>

  <div class="named-code" id="code-option-and-then">

  <span class="named-code-name">option-and-then</span>
  <div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">and_then</span><span class="o">&lt;</span><span class="n">F</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="n">A</span><span class="o">&gt;</span><span class="p">(</span><span class="n">option</span>: <span class="nb">Option</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">,</span><span class="w"> </span><span class="n">f</span>: <span class="nc">F</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Option</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="k">where</span><span class="w"> </span><span class="n">F</span>: <span class="nb">FnOnce</span><span class="p">(</span><span class="n">T</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Option</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="k">match</span><span class="w"> </span><span class="n">option</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="nb">None</span><span class="w"> </span><span class="o">=</span><span class="o">&gt;</span><span class="w"> </span><span class="nb">None</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="nb">Some</span><span class="p">(</span><span class="n">value</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="o">&gt;</span><span class="w"> </span><span class="n">f</span><span class="p">(</span><span class="n">value</span><span class="p">)</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div>
</div>

<p>Now we can rewrite our <code>file_path_ext</code> function without explicit case analysis:</p>

  <div class="named-code" id="code-option-ex-string-find-6">

  <span class="named-code-name">option-ex-string-find</span>
  <div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">file_path_ext</span><span class="p">(</span><span class="n">file_path</span>: <span class="kp">&amp;</span><span class="kt">str</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Option</span><span class="o">&lt;</span><span class="o">&amp;</span><span class="kt">str</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="n">file_name</span><span class="p">(</span><span class="n">file_path</span><span class="p">)</span><span class="p">.</span><span class="n">and_then</span><span class="p">(</span><span class="n">extension</span><span class="p">)</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div>
</div>

<p>The <code>Option</code> type has many other combinators
<a href="http://doc.rust-lang.org/std/option/enum.Option.html">defined in the standard
library</a>. It is a good
idea to skim this list and familiarize yourself with what's available&mdash;they
can often reduce case analysis for you. Familiarizing yourself with these
combinators will pay dividends because many of them are also defined (with
similar semantics) for <code>Result</code>, which we will talk about next.</p>
<p>Combinators make using types like <code>Option</code> ergonomic because they reduce
explicit case analysis. They are also composable because they permit the caller
to handle the possibility of absence in their own way. Methods like <code>unwrap</code>
remove choices because they will panic if <code>Option&lt;T&gt;</code> is <code>None</code>.</p>
<h3 id="the-result-type">The <code>Result</code> type</h3>
<p>The <code>Result</code> type is also
<a href="http://doc.rust-lang.org/std/result/">defined in the standard library</a>:</p>

  <div class="named-code" id="code-result-def-1">

  <span class="named-code-name">result-def</span>
  <div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">enum</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="n">E</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="nb">Ok</span><span class="p">(</span><span class="n">T</span><span class="p">)</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="nb">Err</span><span class="p">(</span><span class="n">E</span><span class="p">)</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div>
</div>

<p>The <code>Result</code> type is a richer version of <code>Option</code>. Instead of expressing the
possibility of <em>absence</em> like <code>Option</code> does, <code>Result</code> expresses the possibility
of <em>error</em>. Usually, the <em>error</em> is used to explain why the result of some
computation failed. This is a strictly more general form of <code>Option</code>. Consider
the following type alias, which is semantically equivalent to the real
<code>Option&lt;T&gt;</code> in every way:</p>

  <div class="named-code" id="code-option-as-result">

  <span class="named-code-name">option-as-result</span>
  <div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">type</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">Result</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="p">)</span><span class="o">&gt;</span><span class="p">;</span><span class="w">
</span></code></pre></div>
</div>

<p>This fixes the second type parameter of <code>Result</code> to always be <code>()</code> (pronounced
&ldquo;unit&rdquo; or &ldquo;empty tuple&rdquo;). Exactly one value inhabits the <code>()</code> type: <code>()</code>. (Yup,
the type and value level terms have the same notation!)</p>
<p>The <code>Result</code> type is a way of representing one of two possible outcomes in a
computation. By convention, one outcome is meant to be expected or &ldquo;<code>Ok</code>&rdquo; while
the other outcome is meant to be unexpected or &ldquo;<code>Err</code>&rdquo;.</p>
<p>Just like <code>Option</code>, the <code>Result</code> type also has an
<a href="http://doc.rust-lang.org/std/result/enum.Result.html#method.unwrap"><code>unwrap</code> method
defined</a>
in the standard library. Let's define it:</p>

  <div class="named-code" id="code-result-def-2">

  <span class="named-code-name">result-def</span>
  <div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="n">E</span>: ::<span class="n">std</span>::<span class="n">fmt</span>::<span class="n">Debug</span><span class="o">&gt;</span><span class="w"> </span><span class="nb">Result</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="n">E</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="k">fn</span> <span class="nf">unwrap</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">T</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="k">match</span><span class="w"> </span><span class="bp">self</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">            </span><span class="nb">Result</span>::<span class="nb">Ok</span><span class="p">(</span><span class="n">val</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="o">&gt;</span><span class="w"> </span><span class="n">val</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">            </span><span class="nb">Result</span>::<span class="nb">Err</span><span class="p">(</span><span class="n">err</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="o">&gt;</span><span class="w">
</span><span class="w"></span><span class="w">              </span><span class="n">panic</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;called `Result::unwrap()` on an `Err` value: {:?}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">err</span><span class="p">)</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div>
</div>

<p>This is effectively the same as our
<a href="rust-error-handling.html#code-option-def-unwrap">definition for <code>Option::unwrap</code></a>,
except it includes the error value in the <code>panic!</code> message. This makes
debugging easier, but it also requires us to add a
<a href="http://doc.rust-lang.org/std/fmt/trait.Debug.html"><code>Debug</code></a>
constraint on the <code>E</code> type parameter (which represents our error type). Since
the vast majority of types should satisfy the <code>Debug</code> constraint, this tends to
work out in practice. (<code>Debug</code> on a type simply means that there's a reasonable
way to print a human readable description of values with that type.)</p>
<p>OK, let's move on to an example.</p>
<h4 id="parsing-integers">Parsing integers</h4>
<p>The Rust standard library makes converting strings to integers dead simple.
It's so easy in fact, that it is very tempting to write something like the
following:</p>

  <div class="named-code" id="code-result-num-unwrap">

  <span class="named-code-name">result-num-unwrap</span>
  <div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">double_number</span><span class="p">(</span><span class="n">number_str</span>: <span class="kp">&amp;</span><span class="kt">str</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">i32</span> <span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="mi">2</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">number_str</span><span class="p">.</span><span class="n">parse</span>::<span class="o">&lt;</span><span class="kt">i32</span><span class="o">&gt;</span><span class="p">(</span><span class="p">)</span><span class="p">.</span><span class="n">unwrap</span><span class="p">(</span><span class="p">)</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">main</span><span class="p">(</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">n</span>: <span class="kt">i32</span> <span class="o">=</span><span class="w"> </span><span class="n">double_number</span><span class="p">(</span><span class="s">&#34;10&#34;</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="mi">20</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div>
</div>

<p>At this point, you should be skeptical of calling <code>unwrap</code>. For example, if
the string doesn't parse as a number, you'll get a panic:</p>



<div class="highlight"><pre class="chroma"><code class="language-text" data-lang="text">thread &#39;&lt;main&gt;&#39; panicked at &#39;called `Result::unwrap()` on an `Err` value: ParseIntError { kind: InvalidDigit }&#39;, /home/rustbuild/src/rust-buildbot/slave/beta-dist-rustc-linux/build/src/libcore/result.rs:729</code></pre></div>


<p>This is rather unsightly, and if this happened inside a library you're using,
you might be understandably annoyed. Instead, we should try to handle the error
in our function and let the caller decide what to do. This means changing the
return type of <code>double_number</code>. But to what? Well, that requires looking at the
signature of the
<a href="http://doc.rust-lang.org/std/primitive.str.html#method.parse"><code>parse</code> method</a>
in the standard library:</p>



  
  

  
  
  
  

<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">impl</span><span class="w"> </span><span class="kt">str</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="k">fn</span> <span class="nf">parse</span><span class="o">&lt;</span><span class="n">F</span>: <span class="nc">FromStr</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="n">F</span><span class="p">,</span><span class="w"> </span><span class="n">F</span>::<span class="nb">Err</span><span class="o">&gt;</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div>


<p>Hmm. So we at least know that we need to use a <code>Result</code>. Certainly, it's
possible that this could have returned an <code>Option</code>. After all, a string either
parses as a number or it doesn't, right? That's certainly a reasonable way to
go, but the implementation internally distinguishes <em>why</em> the string didn't
parse as an integer. (Whether it's an empty string, an invalid digit, too big
or too small.) Therefore, using a <code>Result</code> makes sense because we want to
provide more information than simply &ldquo;absence.&rdquo; We want to say <em>why</em> the
parsing failed. You should try to emulate this line of reasoning when faced
with a choice between <code>Option</code> and <code>Result</code>. If you can provide detailed error
information, then you probably should. (We'll see more on this later.)</p>
<p>OK, but how do we write our return type? The <code>parse</code> method as defined above is
generic over all the different number types defined in the standard library. We
could (and probably should) also make our function generic, but let's favor
explicitness for the moment. We only care about <code>i32</code>, so we need to
<a href="http://doc.rust-lang.org/std/primitive.i32.html">find its implementation of
<code>FromStr</code></a>
(do a <code>CTRL-F</code> in your browser for &ldquo;FromStr&rdquo;)
and look at its <a href="http://doc.rust-lang.org/1.0.0-beta.5/book/associated-types.html">associated
type</a> <code>Err</code>.
We did this so we can find the concrete error type. In this case, it's
<a href="http://doc.rust-lang.org/std/num/struct.ParseIntError.html"><code>std::num::ParseIntError</code></a>.
Finally, we can rewrite our function:</p>

  <div class="named-code" id="code-result-num-no-unwrap">

  <span class="named-code-name">result-num-no-unwrap</span>
  <div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">num</span>::<span class="n">ParseIntError</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">double_number</span><span class="p">(</span><span class="n">number_str</span>: <span class="kp">&amp;</span><span class="kt">str</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="n">ParseIntError</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="k">match</span><span class="w"> </span><span class="n">number_str</span><span class="p">.</span><span class="n">parse</span>::<span class="o">&lt;</span><span class="kt">i32</span><span class="o">&gt;</span><span class="p">(</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="nb">Ok</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="o">&gt;</span><span class="w"> </span><span class="nb">Ok</span><span class="p">(</span><span class="mi">2</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="nb">Err</span><span class="p">(</span><span class="n">err</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="o">&gt;</span><span class="w"> </span><span class="nb">Err</span><span class="p">(</span><span class="n">err</span><span class="p">)</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">main</span><span class="p">(</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="k">match</span><span class="w"> </span><span class="n">double_number</span><span class="p">(</span><span class="s">&#34;10&#34;</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="nb">Ok</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="o">&gt;</span><span class="w"> </span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="mi">20</span><span class="p">)</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="nb">Err</span><span class="p">(</span><span class="n">err</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="o">&gt;</span><span class="w"> </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;Error: {:?}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">err</span><span class="p">)</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div>
</div>

<p>This is a little better, but now we've written a lot more code! The case
analysis has once again bitten us.</p>
<p>Combinators to the rescue! Just like <code>Option</code>, <code>Result</code> has lots of combinators
defined as methods. There is a large intersection of common combinators between
<code>Result</code> and <code>Option</code>. In particular, <code>map</code> is part of that intersection:</p>

  <div class="named-code" id="code-result-num-no-unwrap-map">

  <span class="named-code-name">result-num-no-unwrap-map</span>
  <div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">num</span>::<span class="n">ParseIntError</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">double_number</span><span class="p">(</span><span class="n">number_str</span>: <span class="kp">&amp;</span><span class="kt">str</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="n">ParseIntError</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="n">number_str</span><span class="p">.</span><span class="n">parse</span>::<span class="o">&lt;</span><span class="kt">i32</span><span class="o">&gt;</span><span class="p">(</span><span class="p">)</span><span class="p">.</span><span class="n">map</span><span class="p">(</span><span class="o">|</span><span class="n">n</span><span class="o">|</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">main</span><span class="p">(</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="k">match</span><span class="w"> </span><span class="n">double_number</span><span class="p">(</span><span class="s">&#34;10&#34;</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="nb">Ok</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="o">&gt;</span><span class="w"> </span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="mi">20</span><span class="p">)</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="nb">Err</span><span class="p">(</span><span class="n">err</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="o">&gt;</span><span class="w"> </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;Error: {:?}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">err</span><span class="p">)</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div>
</div>

<p>The usual suspects are all there for <code>Result</code>, including
<a href="http://doc.rust-lang.org/std/result/enum.Result.html#method.unwrap_or"><code>unwrap_or</code></a>
and
<a href="http://doc.rust-lang.org/std/result/enum.Result.html#method.and_then"><code>and_then</code></a>.
Additionally, since <code>Result</code> has a second type parameter, there are combinators
that affect only the error type, such as
<a href="http://doc.rust-lang.org/std/result/enum.Result.html#method.map_err"><code>map_err</code></a>
(instead of <code>map</code>) and
<a href="http://doc.rust-lang.org/std/result/enum.Result.html#method.or_else"><code>or_else</code></a>
(instead of <code>and_then</code>).</p>
<h4 id="the-result-type-alias-idiom">The <code>Result</code> type alias idiom</h4>
<p>In the standard library, you may frequently see types like <code>Result&lt;i32&gt;</code>. But
wait,
<a href="rust-error-handling.html#code-result-def-1">we defined <code>Result</code></a>
to have two type parameters. How can we get away with only specifying one? The
key is to define a <code>Result</code> type alias that <em>fixes</em> one of the type parameters
to a particular type. Usually the fixed type is the error type. For example,
our previous example parsing integers could be rewritten like this:</p>

  <div class="named-code" id="code-result-num-no-unwrap-map-alias">

  <span class="named-code-name">result-num-no-unwrap-map-alias</span>
  <div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">num</span>::<span class="n">ParseIntError</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">result</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="k">type</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">result</span>::<span class="nb">Result</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="n">ParseIntError</span><span class="o">&gt;</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">double_number</span><span class="p">(</span><span class="n">number_str</span>: <span class="kp">&amp;</span><span class="kt">str</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="kt">i32</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="n">unimplemented</span><span class="o">!</span><span class="p">(</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div>
</div>

<p>Why would we do this? Well, if we have a lot of functions that could return
<code>ParseIntError</code>, then it's much more convenient to define an alias that always
uses <code>ParseIntError</code> so that we don't have to write it out all the time.</p>
<p>The most prominent place this idiom is used in the standard library is with
<a href="http://doc.rust-lang.org/std/io/type.Result.html"><code>io::Result</code></a>. Typically,
one writes <code>io::Result&lt;T&gt;</code>, which makes it clear that you're using the <code>io</code>
module's type alias instead of the plain definition from <code>std::result</code>.
(This idiom is also used for
<a href="http://doc.rust-lang.org/std/fmt/type.Result.html"><code>fmt::Result</code></a>.)</p>
<h3 id="a-brief-interlude-unwrapping-isnt-evil">A brief interlude: unwrapping isn't evil</h3>
<p>If you've been following along, you might have noticed that I've taken a pretty
hard line against calling methods like <code>unwrap</code> that could <code>panic</code> and abort
your program. <em>Generally speaking</em>, this is good advice.</p>
<p>However, <code>unwrap</code> can still be used judiciously. What exactly justifies use of
<code>unwrap</code> is somewhat of a grey area and reasonable people can disagree. I'll
summarize some of my <em>opinions</em> on the matter.</p>
<ul>
<li><strong>In examples and quick &lsquo;n&rsquo; dirty code.</strong> Sometimes you're writing examples
or a quick program, and error handling simply isn't important. Beating the
convenience of <code>unwrap</code> can be hard in such scenarios, so it is very
appealing.</li>
<li><strong>When panicking indicates a bug in the program.</strong> When the invariants of
your code should prevent a certain case from happening (like, say, popping
from an empty stack), then panicking can be permissible. This is because it
exposes a bug in your program. This can be explicit, like from an <code>assert!</code>
failing, or it could be because your index into an array was out of bounds.</li>
</ul>
<p>This is probably not an exhaustive list. Moreover, when using an <code>Option</code>, it
is often better to use its
<a href="http://doc.rust-lang.org/std/option/enum.Option.html#method.expect"><code>expect</code></a>
method. <code>expect</code> does exactly the same thing as <code>unwrap</code>, except it prints a
message you give to <code>expect</code>. This makes the resulting panic a bit nicer to
deal with, since it will show your message instead of &ldquo;called unwrap on a
<code>None</code> value.&rdquo;</p>
<p>My advice boils down to this: use good judgment. There's a reason why the words
&ldquo;never do X&rdquo; or &ldquo;Y is considered harmful&rdquo; don't appear in my writing. There are
trade offs to all things, and it is up to you as the programmer to determine
what is acceptable for your use cases. My goal is only to help you evaluate
trade offs as accurately as possible.</p>
<p>Now that we've covered the basics of error handling in Rust, and I've said my
piece about unwrapping, let's start exploring more of the standard library.</p>
<h2 id="working-with-multiple-error-types">Working with multiple error types</h2>
<p>Thus far, we've looked at error handling where everything was either an
<code>Option&lt;T&gt;</code> or a <code>Result&lt;T, SomeError&gt;</code>. But what happens when you have both an
<code>Option</code> and a <code>Result</code>? Or what if you have a <code>Result&lt;T, Error1&gt;</code> and a
<code>Result&lt;T, Error2&gt;</code>? Handling <em>composition of distinct error types</em> is the next
challenge in front of us, and it will be the major theme throughout the rest of
this article.</p>
<h3 id="composing-option-and-result">Composing <code>Option</code> and <code>Result</code></h3>
<p>So far, I've talked about combinators defined for <code>Option</code> and combinators
defined for <code>Result</code>. We can use these combinators to compose results of
different computations without doing explicit case analysis.</p>
<p>Of course, in real code, things aren't always as clean. Sometimes you have a
mix of <code>Option</code> and <code>Result</code> types. Must we resort to explicit case analysis,
or can we continue using combinators?</p>
<p>For now, let's revisit one of the first examples in this article:</p>



  
  

  
  
  
  

<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">env</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">main</span><span class="p">(</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">argv</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">env</span>::<span class="n">args</span><span class="p">(</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">arg</span>: <span class="nb">String</span> <span class="o">=</span><span class="w"> </span><span class="n">argv</span><span class="p">.</span><span class="n">nth</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="p">.</span><span class="n">unwrap</span><span class="p">(</span><span class="p">)</span><span class="p">;</span><span class="w"> </span><span class="c1">// error 1
</span><span class="c1"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">n</span>: <span class="kt">i32</span> <span class="o">=</span><span class="w"> </span><span class="n">arg</span><span class="p">.</span><span class="n">parse</span><span class="p">(</span><span class="p">)</span><span class="p">.</span><span class="n">unwrap</span><span class="p">(</span><span class="p">)</span><span class="p">;</span><span class="w"> </span><span class="c1">// error 2
</span><span class="c1"></span><span class="w">    </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;{}&#34;</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="c1">// $ cargo run --bin unwrap-double 5
</span><span class="c1"></span><span class="c1">// 10
</span></code></pre></div>


<p>Given our new found knowledge of <code>Option</code>, <code>Result</code> and their various
combinators, we should try to rewrite this so that errors are handled properly
and the program doesn't panic if there's an error.</p>
<p>The tricky aspect here is that <code>argv.nth(1)</code> produces an <code>Option</code> while
<code>arg.parse()</code> produces a <code>Result</code>. These aren't directly composable. When faced
with both an <code>Option</code> and a <code>Result</code>, the solution is <em>usually</em> to convert the
<code>Option</code> to a <code>Result</code>. In our case, the absence of a command line parameter
(from <code>env::args()</code>) means the user didn't invoke the program correctly. We
could just use a <code>String</code> to describe the error. Let's try:</p>

  <div class="named-code" id="code-error-double-string">

  <span class="named-code-name">error-double-string</span>
  <div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">env</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">double_arg</span><span class="p">(</span><span class="k">mut</span><span class="w"> </span><span class="n">argv</span>: <span class="nc">env</span>::<span class="n">Args</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="nb">String</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="n">argv</span><span class="p">.</span><span class="n">nth</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="p">.</span><span class="n">ok_or</span><span class="p">(</span><span class="s">&#34;Please give at least one argument&#34;</span><span class="p">.</span><span class="n">to_owned</span><span class="p">(</span><span class="p">)</span><span class="p">)</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="p">.</span><span class="n">and_then</span><span class="p">(</span><span class="o">|</span><span class="n">arg</span><span class="o">|</span><span class="w"> </span><span class="n">arg</span><span class="p">.</span><span class="n">parse</span>::<span class="o">&lt;</span><span class="kt">i32</span><span class="o">&gt;</span><span class="p">(</span><span class="p">)</span><span class="p">.</span><span class="n">map_err</span><span class="p">(</span><span class="o">|</span><span class="n">err</span><span class="o">|</span><span class="w"> </span><span class="n">err</span><span class="p">.</span><span class="n">to_string</span><span class="p">(</span><span class="p">)</span><span class="p">)</span><span class="p">)</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">main</span><span class="p">(</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="k">match</span><span class="w"> </span><span class="n">double_arg</span><span class="p">(</span><span class="n">env</span>::<span class="n">args</span><span class="p">(</span><span class="p">)</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="nb">Ok</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="o">&gt;</span><span class="w"> </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;{}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="nb">Err</span><span class="p">(</span><span class="n">err</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="o">&gt;</span><span class="w"> </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;Error: {}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">err</span><span class="p">)</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div>
</div>

<p>There are a couple new things in this example. The first is the use of the
<a href="http://doc.rust-lang.org/std/option/enum.Option.html#method.ok_or"><code>Option::ok_or</code></a>
combinator. This is one way to convert an <code>Option</code> into a <code>Result</code>. The
conversion requires you to specify what error to use if <code>Option</code> is <code>None</code>.
Like the other combinators we've seen, its definition is very simple:</p>

  <div class="named-code" id="code-option-ok-or-def">

  <span class="named-code-name">option-ok-or-def</span>
  <div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">ok_or</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="n">E</span><span class="o">&gt;</span><span class="p">(</span><span class="n">option</span>: <span class="nb">Option</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">,</span><span class="w"> </span><span class="n">err</span>: <span class="nc">E</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="n">E</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="k">match</span><span class="w"> </span><span class="n">option</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="nb">Some</span><span class="p">(</span><span class="n">val</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="o">&gt;</span><span class="w"> </span><span class="nb">Ok</span><span class="p">(</span><span class="n">val</span><span class="p">)</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="nb">None</span><span class="w"> </span><span class="o">=</span><span class="o">&gt;</span><span class="w"> </span><span class="nb">Err</span><span class="p">(</span><span class="n">err</span><span class="p">)</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div>
</div>

<p>The other new combinator used here is
<a href="http://doc.rust-lang.org/std/result/enum.Result.html#method.map_err"><code>Result::map_err</code></a>.
This is just like <code>Result::map</code>, except it maps a function on to the <em>error</em>
portion of a <code>Result</code> value. If the <code>Result</code> is an <code>Ok(...)</code> value, then it is
returned unmodified.</p>
<p>We use <code>map_err</code> here because it is necessary for the error types to remain
the same (because of our use of <code>and_then</code>). Since we chose to convert the
<code>Option&lt;String&gt;</code> (from <code>argv.nth(1)</code>) to a <code>Result&lt;String, String&gt;</code>, we must
also convert the <code>ParseIntError</code> from <code>arg.parse()</code> to a <code>String</code>.</p>
<h3 id="the-limits-of-combinators">The limits of combinators</h3>
<p>Doing IO and parsing input is a very common task, and it's one that I
personally have done a lot of in Rust. Therefore, we will use (and continue to
use) IO and various parsing routines to exemplify error handling.</p>
<p>Let's start simple. We are tasked with opening a file, reading all of its
contents and converting its contents to a number. Then we multiply it by <code>2</code>
and print the output.</p>
<p>Although I've tried to convince you not to use <code>unwrap</code>, it can be useful
to first write your code using <code>unwrap</code>. It allows you to focus on your problem
instead of the error handling, and it exposes the points where proper error
handling need to occur. Let's start there so we can get a handle on the code,
and then refactor it to use better error handling.</p>

  <div class="named-code" id="code-io-basic-unwrap">

  <span class="named-code-name">io-basic-unwrap</span>
  <div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">fs</span>::<span class="n">File</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">io</span>::<span class="n">Read</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">path</span>::<span class="n">Path</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">file_double</span><span class="o">&lt;</span><span class="n">P</span>: <span class="nb">AsRef</span><span class="o">&lt;</span><span class="n">Path</span><span class="o">&gt;</span><span class="o">&gt;</span><span class="p">(</span><span class="n">file_path</span>: <span class="nc">P</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">i32</span> <span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">file</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">File</span>::<span class="n">open</span><span class="p">(</span><span class="n">file_path</span><span class="p">)</span><span class="p">.</span><span class="n">unwrap</span><span class="p">(</span><span class="p">)</span><span class="p">;</span><span class="w"> </span><span class="c1">// error 1
</span><span class="c1"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">contents</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">String</span>::<span class="n">new</span><span class="p">(</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="n">file</span><span class="p">.</span><span class="n">read_to_string</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">contents</span><span class="p">)</span><span class="p">.</span><span class="n">unwrap</span><span class="p">(</span><span class="p">)</span><span class="p">;</span><span class="w"> </span><span class="c1">// error 2
</span><span class="c1"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">n</span>: <span class="kt">i32</span> <span class="o">=</span><span class="w"> </span><span class="n">contents</span><span class="p">.</span><span class="n">trim</span><span class="p">(</span><span class="p">)</span><span class="p">.</span><span class="n">parse</span><span class="p">(</span><span class="p">)</span><span class="p">.</span><span class="n">unwrap</span><span class="p">(</span><span class="p">)</span><span class="p">;</span><span class="w"> </span><span class="c1">// error 3
</span><span class="c1"></span><span class="w">    </span><span class="mi">2</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">n</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">main</span><span class="p">(</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">doubled</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">file_double</span><span class="p">(</span><span class="s">&#34;foobar&#34;</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;{}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">doubled</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div>
</div>

<p>(N.B. The <code>AsRef&lt;Path&gt;</code> is used because those are the
<a href="http://doc.rust-lang.org/std/fs/struct.File.html#method.open">same bounds used on
<code>std::fs::File::open</code></a>.
This makes it ergnomic to use any kind of string as a file path.)</p>
<p>There are three different errors that can occur here:</p>
<ol>
<li>A problem opening the file.</li>
<li>A problem reading data from the file.</li>
<li>A problem parsing the data as a number.</li>
</ol>
<p>The first two problems are described via the
<a href="http://doc.rust-lang.org/std/io/struct.Error.html"><code>std::io::Error</code></a> type.
We know this because of the return types of
<a href="http://doc.rust-lang.org/std/fs/struct.File.html#method.open"><code>std::fs::File::open</code></a>
and
<a href="http://doc.rust-lang.org/std/io/trait.Read.html#method.read_to_string"><code>std::io::Read::read_to_string</code></a>.
(Note that they both use the
<a href="rust-error-handling.html#the-result-type-alias-idiom"><code>Result</code> type alias idiom</a>
described previously. If you click on the <code>Result</code> type, you'll
<a href="http://doc.rust-lang.org/std/io/type.Result.html">see the type alias</a>, and
consequently, the underlying <code>io::Error</code> type.)
The third problem is described by the
<a href="http://doc.rust-lang.org/std/num/struct.ParseIntError.html"><code>std::num::ParseIntError</code></a>
type. The <code>io::Error</code> type in particular is <em>pervasive</em> throughout the standard
library. You will see it again and again.</p>
<p>Let's start the process of refactoring the <code>file_double</code> function. To make this
function composable with other components of the program, it should <em>not</em> panic
if any of the above error conditions are met. Effectively, this means that the
function should <em>return an error</em> if any of its operations fail. Our problem is
that the return type of <code>file_double</code> is <code>i32</code>, which does not give us any
useful way of reporting an error. Thus, we must start by changing the return
type from <code>i32</code> to something else.</p>
<p>The first thing we need to decide: should we use <code>Option</code> or <code>Result</code>? We
certainly could use <code>Option</code> very easily. If any of the three errors occur, we
could simply return <code>None</code>. This will work <em>and it is better than panicking</em>,
but we can do a lot better. Instead, we should pass some detail about the error
that occurred. Since we want to express the <em>possibility of error</em>, we should
use <code>Result&lt;i32, E&gt;</code>. But what should <code>E</code> be? Since two <em>different</em> types of
errors can occur, we need to convert them to a common type. One such type is
<code>String</code>. Let's see how that impacts our code:</p>

  <div class="named-code" id="code-io-basic-error-string">

  <span class="named-code-name">io-basic-error-string</span>
  <div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">fs</span>::<span class="n">File</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">io</span>::<span class="n">Read</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">path</span>::<span class="n">Path</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">file_double</span><span class="o">&lt;</span><span class="n">P</span>: <span class="nb">AsRef</span><span class="o">&lt;</span><span class="n">Path</span><span class="o">&gt;</span><span class="o">&gt;</span><span class="p">(</span><span class="n">file_path</span>: <span class="nc">P</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="nb">String</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="n">File</span>::<span class="n">open</span><span class="p">(</span><span class="n">file_path</span><span class="p">)</span><span class="w">
</span><span class="w"></span><span class="w">         </span><span class="p">.</span><span class="n">map_err</span><span class="p">(</span><span class="o">|</span><span class="n">err</span><span class="o">|</span><span class="w"> </span><span class="n">err</span><span class="p">.</span><span class="n">to_string</span><span class="p">(</span><span class="p">)</span><span class="p">)</span><span class="w">
</span><span class="w"></span><span class="w">         </span><span class="p">.</span><span class="n">and_then</span><span class="p">(</span><span class="o">|</span><span class="k">mut</span><span class="w"> </span><span class="n">file</span><span class="o">|</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">              </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">contents</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">String</span>::<span class="n">new</span><span class="p">(</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">              </span><span class="n">file</span><span class="p">.</span><span class="n">read_to_string</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">contents</span><span class="p">)</span><span class="w">
</span><span class="w"></span><span class="w">                  </span><span class="p">.</span><span class="n">map_err</span><span class="p">(</span><span class="o">|</span><span class="n">err</span><span class="o">|</span><span class="w"> </span><span class="n">err</span><span class="p">.</span><span class="n">to_string</span><span class="p">(</span><span class="p">)</span><span class="p">)</span><span class="w">
</span><span class="w"></span><span class="w">                  </span><span class="p">.</span><span class="n">map</span><span class="p">(</span><span class="o">|</span><span class="n">_</span><span class="o">|</span><span class="w"> </span><span class="n">contents</span><span class="p">)</span><span class="w">
</span><span class="w"></span><span class="w">         </span><span class="p">}</span><span class="p">)</span><span class="w">
</span><span class="w"></span><span class="w">         </span><span class="p">.</span><span class="n">and_then</span><span class="p">(</span><span class="o">|</span><span class="n">contents</span><span class="o">|</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">              </span><span class="n">contents</span><span class="p">.</span><span class="n">trim</span><span class="p">(</span><span class="p">)</span><span class="p">.</span><span class="n">parse</span>::<span class="o">&lt;</span><span class="kt">i32</span><span class="o">&gt;</span><span class="p">(</span><span class="p">)</span><span class="w">
</span><span class="w"></span><span class="w">                      </span><span class="p">.</span><span class="n">map_err</span><span class="p">(</span><span class="o">|</span><span class="n">err</span><span class="o">|</span><span class="w"> </span><span class="n">err</span><span class="p">.</span><span class="n">to_string</span><span class="p">(</span><span class="p">)</span><span class="p">)</span><span class="w">
</span><span class="w"></span><span class="w">         </span><span class="p">}</span><span class="p">)</span><span class="w">
</span><span class="w"></span><span class="w">         </span><span class="p">.</span><span class="n">map</span><span class="p">(</span><span class="o">|</span><span class="n">n</span><span class="o">|</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">main</span><span class="p">(</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="k">match</span><span class="w"> </span><span class="n">file_double</span><span class="p">(</span><span class="s">&#34;foobar&#34;</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="nb">Ok</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="o">&gt;</span><span class="w"> </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;{}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="nb">Err</span><span class="p">(</span><span class="n">err</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="o">&gt;</span><span class="w"> </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;Error: {}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">err</span><span class="p">)</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div>
</div>

<p>This code looks a bit hairy. It can take quite a bit of practice before code
like this becomes easy to write. The way I write it is by <em>following the
types</em>. As soon as I changed the return type of <code>file_double</code> to
<code>Result&lt;i32, String&gt;</code>, I had to start looking for the right combinators. In
this case, we only used three different combinators: <code>and_then</code>, <code>map</code> and
<code>map_err</code>.</p>
<p><code>and_then</code> is used to chain multiple computations where each computation could
return an error. After opening the file, there are two more computations that
could fail: reading from the file and parsing the contents as a number.
Correspondingly, there are two calls to <code>and_then</code>.</p>
<p><code>map</code> is used to apply a function to the <code>Ok(...)</code> value of a <code>Result</code>. For
example, the very last call to <code>map</code> multiplies the <code>Ok(...)</code> value (which is
an <code>i32</code>) by <code>2</code>. If an error had occurred before that point, this operation
would have been skipped because of how <code>map</code> is defined.</p>
<p><code>map_err</code> is the trick the makes all of this work. <code>map_err</code> is just like
<code>map</code>, except it applies a function to the <code>Err(...)</code> value of a <code>Result</code>. In
this case, we want to convert all of our errors to one type: <code>String</code>. Since
both <code>io::Error</code> and <code>num::ParseIntError</code> implement <code>ToString</code>, we can call the
<code>to_string()</code> method to convert them.</p>
<p>With all of that said, the code is still hairy. Mastering use of combinators is
important, but they have their limits. Let's try a different approach: early
returns.</p>
<h3 id="early-returns">Early returns</h3>
<p>I'd like to take the code from the previous section and rewrite it using <em>early
returns</em>. Early returns let you exit the function early. We can't return early
in <code>file_double</code> from inside another closure, so we'll need to revert back to
explicit case analysis.</p>

  <div class="named-code" id="code-io-basic-error-string-early-return">

  <span class="named-code-name">io-basic-error-string-early-return</span>
  <div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">fs</span>::<span class="n">File</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">io</span>::<span class="n">Read</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">path</span>::<span class="n">Path</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">file_double</span><span class="o">&lt;</span><span class="n">P</span>: <span class="nb">AsRef</span><span class="o">&lt;</span><span class="n">Path</span><span class="o">&gt;</span><span class="o">&gt;</span><span class="p">(</span><span class="n">file_path</span>: <span class="nc">P</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="nb">String</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">file</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">match</span><span class="w"> </span><span class="n">File</span>::<span class="n">open</span><span class="p">(</span><span class="n">file_path</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="nb">Ok</span><span class="p">(</span><span class="n">file</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="o">&gt;</span><span class="w"> </span><span class="n">file</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="nb">Err</span><span class="p">(</span><span class="n">err</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="o">&gt;</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="nb">Err</span><span class="p">(</span><span class="n">err</span><span class="p">.</span><span class="n">to_string</span><span class="p">(</span><span class="p">)</span><span class="p">)</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="p">}</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">contents</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">String</span>::<span class="n">new</span><span class="p">(</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="kd">let</span><span class="w"> </span><span class="nb">Err</span><span class="p">(</span><span class="n">err</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">file</span><span class="p">.</span><span class="n">read_to_string</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">contents</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="nb">Err</span><span class="p">(</span><span class="n">err</span><span class="p">.</span><span class="n">to_string</span><span class="p">(</span><span class="p">)</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">n</span>: <span class="kt">i32</span> <span class="o">=</span><span class="w"> </span><span class="k">match</span><span class="w"> </span><span class="n">contents</span><span class="p">.</span><span class="n">trim</span><span class="p">(</span><span class="p">)</span><span class="p">.</span><span class="n">parse</span><span class="p">(</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="nb">Ok</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="o">&gt;</span><span class="w"> </span><span class="n">n</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="nb">Err</span><span class="p">(</span><span class="n">err</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="o">&gt;</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="nb">Err</span><span class="p">(</span><span class="n">err</span><span class="p">.</span><span class="n">to_string</span><span class="p">(</span><span class="p">)</span><span class="p">)</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="p">}</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="nb">Ok</span><span class="p">(</span><span class="mi">2</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">main</span><span class="p">(</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="k">match</span><span class="w"> </span><span class="n">file_double</span><span class="p">(</span><span class="s">&#34;foobar&#34;</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="nb">Ok</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="o">&gt;</span><span class="w"> </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;{}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="nb">Err</span><span class="p">(</span><span class="n">err</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="o">&gt;</span><span class="w"> </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;Error: {}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">err</span><span class="p">)</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div>
</div>

<p>Reasonable people can disagree over whether this code is better that the code
that uses combinators, but if you aren't familiar with the combinator approach,
this code looks simpler to read to me. It uses explicit case analysis with
<code>match</code> and <code>if let</code>. If an error occurs, it simply stops executing the
function and returns the error (by converting it to a string).</p>
<p>Isn't this a step backwards though? Previously, I said that the key to
ergonomic error handling is reducing explicit case analysis, yet we've reverted
back to explicit case analysis here. It turns out, there are <em>multiple</em> ways to
reduce explicit case analysis. Combinators aren't the only way.</p>
<h3 id="the-try-macro-operator">The <code>try!</code> macro/<code>?</code> operator</h3>
<p>In older versions of Rust (Rust 1.12 or older), a cornerstone of error handling
in Rust is the <code>try!</code> macro. The <code>try!</code> macro abstracts case analysis just like
combinators, but unlike combinators, it also abstracts <em>control flow</em>. Namely,
it can abstract the <em>early return</em> pattern seen above.</p>
<p>Here is a simplified definition of a <code>try!</code> macro:</p>

  <div class="named-code" id="code-try-def-simple">

  <span class="named-code-name">try-def-simple</span>
  <div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="n">macro_rules</span><span class="o">!</span><span class="w"> </span><span class="n">try</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="p">(</span><span class="cp">$e</span>:<span class="nc">expr</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="o">&gt;</span><span class="w"> </span><span class="p">(</span><span class="k">match</span><span class="w"> </span><span class="cp">$e</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="nb">Ok</span><span class="p">(</span><span class="n">val</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="o">&gt;</span><span class="w"> </span><span class="n">val</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="nb">Err</span><span class="p">(</span><span class="n">err</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="o">&gt;</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="nb">Err</span><span class="p">(</span><span class="n">err</span><span class="p">)</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="p">}</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div>
</div>

<p>(The
<a href="http://doc.rust-lang.org/std/macro.try!.html">real definition</a>
is a bit more sophisticated. We will address that later.)</p>
<p>Using the <code>try!</code> macro makes it very easy to simplify our last example. Since
it does the case analysis and the early return for us, we get tighter code that
is easier to read:</p>

  <div class="named-code" id="code-io-basic-error-try">

  <span class="named-code-name">io-basic-error-try</span>
  <div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">fs</span>::<span class="n">File</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">io</span>::<span class="n">Read</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">path</span>::<span class="n">Path</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">file_double</span><span class="o">&lt;</span><span class="n">P</span>: <span class="nb">AsRef</span><span class="o">&lt;</span><span class="n">Path</span><span class="o">&gt;</span><span class="o">&gt;</span><span class="p">(</span><span class="n">file_path</span>: <span class="nc">P</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="nb">String</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">file</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">try</span><span class="o">!</span><span class="p">(</span><span class="n">File</span>::<span class="n">open</span><span class="p">(</span><span class="n">file_path</span><span class="p">)</span><span class="p">.</span><span class="n">map_err</span><span class="p">(</span><span class="o">|</span><span class="n">e</span><span class="o">|</span><span class="w"> </span><span class="n">e</span><span class="p">.</span><span class="n">to_string</span><span class="p">(</span><span class="p">)</span><span class="p">)</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">contents</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">String</span>::<span class="n">new</span><span class="p">(</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="n">try</span><span class="o">!</span><span class="p">(</span><span class="n">file</span><span class="p">.</span><span class="n">read_to_string</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">contents</span><span class="p">)</span><span class="p">.</span><span class="n">map_err</span><span class="p">(</span><span class="o">|</span><span class="n">e</span><span class="o">|</span><span class="w"> </span><span class="n">e</span><span class="p">.</span><span class="n">to_string</span><span class="p">(</span><span class="p">)</span><span class="p">)</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">try</span><span class="o">!</span><span class="p">(</span><span class="n">contents</span><span class="p">.</span><span class="n">trim</span><span class="p">(</span><span class="p">)</span><span class="p">.</span><span class="n">parse</span>::<span class="o">&lt;</span><span class="kt">i32</span><span class="o">&gt;</span><span class="p">(</span><span class="p">)</span><span class="p">.</span><span class="n">map_err</span><span class="p">(</span><span class="o">|</span><span class="n">e</span><span class="o">|</span><span class="w"> </span><span class="n">e</span><span class="p">.</span><span class="n">to_string</span><span class="p">(</span><span class="p">)</span><span class="p">)</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="nb">Ok</span><span class="p">(</span><span class="mi">2</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">main</span><span class="p">(</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="k">match</span><span class="w"> </span><span class="n">file_double</span><span class="p">(</span><span class="s">&#34;foobar&#34;</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="nb">Ok</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="o">&gt;</span><span class="w"> </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;{}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="nb">Err</span><span class="p">(</span><span class="n">err</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="o">&gt;</span><span class="w"> </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;Error: {}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">err</span><span class="p">)</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div>
</div>

<p>The <code>map_err</code> calls are still necessary given
<a href="rust-error-handling.html#code-try-def-simple">our definition of <code>try!</code></a>.
This is because the error types still need to be converted to <code>String</code>.
The good news is that we will soon learn how to remove those <code>map_err</code> calls!
The bad news is that we will need to learn a bit more about a couple important
traits in the standard library before we can remove the <code>map_err</code> calls.</p>
<p>In newer versions of Rust (Rust 1.13 or newer), the <code>try!</code> macro was replaced
with the <code>?</code> operator. While it is intended to grow new powers that we won't
cover here, using <code>?</code> instead of <code>try!</code> is simple:</p>

  <div class="named-code" id="code-io-basic-error-question">

  <span class="named-code-name">io-basic-error-question</span>
  <div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">fs</span>::<span class="n">File</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">io</span>::<span class="n">Read</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">path</span>::<span class="n">Path</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">file_double</span><span class="o">&lt;</span><span class="n">P</span>: <span class="nb">AsRef</span><span class="o">&lt;</span><span class="n">Path</span><span class="o">&gt;</span><span class="o">&gt;</span><span class="p">(</span><span class="n">file_path</span>: <span class="nc">P</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="nb">String</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">file</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">File</span>::<span class="n">open</span><span class="p">(</span><span class="n">file_path</span><span class="p">)</span><span class="p">.</span><span class="n">map_err</span><span class="p">(</span><span class="o">|</span><span class="n">e</span><span class="o">|</span><span class="w"> </span><span class="n">e</span><span class="p">.</span><span class="n">to_string</span><span class="p">(</span><span class="p">)</span><span class="p">)</span><span class="o">?</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">contents</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">String</span>::<span class="n">new</span><span class="p">(</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="n">file</span><span class="p">.</span><span class="n">read_to_string</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">contents</span><span class="p">)</span><span class="p">.</span><span class="n">map_err</span><span class="p">(</span><span class="o">|</span><span class="n">e</span><span class="o">|</span><span class="w"> </span><span class="n">e</span><span class="p">.</span><span class="n">to_string</span><span class="p">(</span><span class="p">)</span><span class="p">)</span><span class="o">?</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">contents</span><span class="p">.</span><span class="n">trim</span><span class="p">(</span><span class="p">)</span><span class="p">.</span><span class="n">parse</span>::<span class="o">&lt;</span><span class="kt">i32</span><span class="o">&gt;</span><span class="p">(</span><span class="p">)</span><span class="p">.</span><span class="n">map_err</span><span class="p">(</span><span class="o">|</span><span class="n">e</span><span class="o">|</span><span class="w"> </span><span class="n">e</span><span class="p">.</span><span class="n">to_string</span><span class="p">(</span><span class="p">)</span><span class="p">)</span><span class="o">?</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="nb">Ok</span><span class="p">(</span><span class="mi">2</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">main</span><span class="p">(</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="k">match</span><span class="w"> </span><span class="n">file_double</span><span class="p">(</span><span class="s">&#34;foobar&#34;</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="nb">Ok</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="o">&gt;</span><span class="w"> </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;{}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="nb">Err</span><span class="p">(</span><span class="n">err</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="o">&gt;</span><span class="w"> </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;Error: {}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">err</span><span class="p">)</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div>
</div>

<h3 id="defining-your-own-error-type">Defining your own error type</h3>
<p>Before we dive into some of the standard library error traits, I'd like to wrap
up this section by removing the use of <code>String</code> as our error type in the
previous examples.</p>
<p>Using <code>String</code> as we did in our previous examples is convenient because it's
easy to convert errors to strings, or even make up your own errors as strings
on the spot. However, using <code>String</code> for your errors has some downsides.</p>
<p>The first downside is that the error messages tend to clutter your code. It's
possible to define the error messages elsewhere, but unless you're unusually
disciplined, it is very tempting to embed the error message into your code.
Indeed, we did exactly this in a
<a href="rust-error-handling.html#code-error-double-string">previous example</a>.</p>
<p>The second and more important downside is that <code>String</code>s are <em>lossy</em>. That is,
if all errors are converted to strings, then the errors we pass to the caller
become completely opaque. The only reasonable thing the caller can do with a
<code>String</code> error is show it to the user. Certainly, inspecting the string to
determine the type of error is not robust. (Admittedly, this downside is far
more important inside of a library as opposed to, say, an application.)</p>
<p>For example, the <code>io::Error</code> type embeds an
<a href="http://doc.rust-lang.org/std/io/enum.ErrorKind.html"><code>io::ErrorKind</code></a>,
which is <em>structured data</em> that represents what went wrong during an IO
operation. This is important because you might want to react differently
depending on the error. (e.g., A <code>BrokenPipe</code> error might mean quitting your
program gracefully while a <code>NotFound</code> error might mean exiting with an error
code and showing an error to the user.) With <code>io::ErrorKind</code>, the caller can
examine the type of an error with case analysis, which is strictly superior
to trying to tease out the details of an error inside of a <code>String</code>.</p>
<p>Instead of using a <code>String</code> as an error type in our previous example of reading
an integer from a file, we can define our own error type that represents errors
with <em>structured data</em>. We endeavor to not drop information from underlying
errors in case the caller wants to inspect the details.</p>
<p>The ideal way to represent <em>one of many possibilities</em> is to define our own
sum type using <code>enum</code>. In our case, an error is either an <code>io::Error</code> or a
<code>num::ParseIntError</code>, so a natural definition arises:</p>

  <div class="named-code" id="code-io-basic-error-custom-1">

  <span class="named-code-name">io-basic-error-custom</span>
  <div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">io</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">num</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="c1">// We derive `Debug` because all types should probably derive `Debug`.
</span><span class="c1"></span><span class="c1">// This gives us a reasonable human readable description of `CliError` values.
</span><span class="c1"></span><span class="cp">#[</span><span class="cp">derive(Debug)</span><span class="cp">]</span><span class="w">
</span><span class="w"></span><span class="k">enum</span> <span class="nc">CliError</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="n">Io</span><span class="p">(</span><span class="n">io</span>::<span class="n">Error</span><span class="p">)</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="n">Parse</span><span class="p">(</span><span class="n">num</span>::<span class="n">ParseIntError</span><span class="p">)</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div>
</div>

<p>Tweaking our code is very easy. Instead of converting errors to strings, we
simply convert them to our <code>CliError</code> type using the corresponding value
constructor:</p>

  <div class="named-code" id="code-io-basic-error-custom-2">

  <span class="named-code-name">io-basic-error-custom</span>
  <div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">fs</span>::<span class="n">File</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">io</span>::<span class="n">Read</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">path</span>::<span class="n">Path</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">file_double</span><span class="o">&lt;</span><span class="n">P</span>: <span class="nb">AsRef</span><span class="o">&lt;</span><span class="n">Path</span><span class="o">&gt;</span><span class="o">&gt;</span><span class="p">(</span><span class="n">file_path</span>: <span class="nc">P</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="n">CliError</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">file</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">File</span>::<span class="n">open</span><span class="p">(</span><span class="n">file_path</span><span class="p">)</span><span class="p">.</span><span class="n">map_err</span><span class="p">(</span><span class="n">CliError</span>::<span class="n">Io</span><span class="p">)</span><span class="o">?</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">contents</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">String</span>::<span class="n">new</span><span class="p">(</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="n">file</span><span class="p">.</span><span class="n">read_to_string</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">contents</span><span class="p">)</span><span class="p">.</span><span class="n">map_err</span><span class="p">(</span><span class="n">CliError</span>::<span class="n">Io</span><span class="p">)</span><span class="o">?</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">n</span>: <span class="kt">i32</span> <span class="o">=</span><span class="w"> </span><span class="n">contents</span><span class="p">.</span><span class="n">trim</span><span class="p">(</span><span class="p">)</span><span class="p">.</span><span class="n">parse</span><span class="p">(</span><span class="p">)</span><span class="p">.</span><span class="n">map_err</span><span class="p">(</span><span class="n">CliError</span>::<span class="n">Parse</span><span class="p">)</span><span class="o">?</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="nb">Ok</span><span class="p">(</span><span class="mi">2</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">main</span><span class="p">(</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="k">match</span><span class="w"> </span><span class="n">file_double</span><span class="p">(</span><span class="s">&#34;foobar&#34;</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="nb">Ok</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="o">&gt;</span><span class="w"> </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;{}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="nb">Err</span><span class="p">(</span><span class="n">err</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="o">&gt;</span><span class="w"> </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;Error: {:?}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">err</span><span class="p">)</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div>
</div>

<p>The only change here is switching <code>map_err(|e| e.to_string())</code> (which converts
errors to strings) to <code>map_err(CliError::Io)</code> or <code>map_err(CliError::Parse)</code>.
The <em>caller</em> gets to decide the level of detail to report to the user. In
effect, using a <code>String</code> as an error type removes choices from the caller while
using a custom <code>enum</code> error type like <code>CliError</code> gives the caller all of the
conveniences as before in addition to <em>structured data</em> describing the error.</p>
<p>A rule of thumb is to define your own error type, but a <code>String</code> error type
will do in a pinch, particularly if you're writing an application. If you're
writing a library, defining your own error type should be strongly preferred so
that you don't remove choices from the caller unnecessarily.</p>
<h2 id="standard-library-traits-used-for-error-handling">Standard library traits used for error handling</h2>
<p>The standard library defines two integral traits for error handling:
<a href="http://doc.rust-lang.org/std/error/trait.Error.html"><code>std::error::Error</code></a>
and
<a href="http://doc.rust-lang.org/std/convert/trait.From.html"><code>std::convert::From</code></a>.
While <code>Error</code> is designed specifically for generically describing errors, the
<code>From</code> trait serves a more general role for converting values between two
distinct types.</p>
<h3 id="the-error-trait">The <code>Error</code> trait</h3>
<p>The <code>Error</code> trait is
<a href="http://doc.rust-lang.org/std/error/trait.Error.html">defined in the standard
library</a>:</p>

  <div class="named-code" id="code-error-def">

  <span class="named-code-name">error-def</span>
  <div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">fmt</span>::<span class="p">{</span><span class="n">Debug</span><span class="p">,</span><span class="w"> </span><span class="n">Display</span><span class="p">}</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="k">trait</span><span class="w"> </span><span class="n">Error</span>: <span class="nc">Debug</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">Display</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">  </span><span class="sd">/// A short description of the error.
</span><span class="sd"></span><span class="w">  </span><span class="k">fn</span> <span class="nf">description</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="kt">str</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="w">  </span><span class="sd">/// The lower level cause of this error, if any.
</span><span class="sd"></span><span class="w">  </span><span class="k">fn</span> <span class="nf">cause</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Option</span><span class="o">&lt;</span><span class="o">&amp;</span><span class="n">Error</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nb">None</span><span class="w"> </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div>
</div>

<p>This trait is super generic because it is meant to be implemented for <em>all</em>
types that represent errors. This will prove useful for writing composable code
as we'll see later. Otherwise, the trait allows you to do at least the
following things:</p>
<ul>
<li>Obtain a <code>Debug</code> representation of the error.</li>
<li>Obtain a user-facing <code>Display</code> representation of the error.</li>
<li>Obtain a short description of the error (via the <code>description</code> method).</li>
<li>Inspect the causal chain of an error, if one exists (via the <code>cause</code> method).</li>
</ul>
<p>The first two are a result of <code>Error</code> requiring impls for both <code>Debug</code> and
<code>Display</code>. The latter two are from the two methods defined on <code>Error</code>. The
power of <code>Error</code> comes from the fact that all error types impl <code>Error</code>, which
means errors can be existentially quantified as a
<a href="http://doc.rust-lang.org/1.0.0-beta.5/book/trait-objects.html">trait object</a>.
This manifests as either <code>Box&lt;Error&gt;</code> or <code>&amp;Error</code>. Indeed, the <code>cause</code> method
returns an <code>&amp;Error</code>, which is itself a trait object. We'll revisit the
<code>Error</code> trait's utility as a trait object later.</p>
<p>For now, it suffices to show an example implementing the <code>Error</code> trait. Let's
use the error type we defined in the
<a href="rust-error-handling.html#defining-your-own-error-type">previous section</a>:</p>

  <div class="named-code" id="code-error-impl-1">

  <span class="named-code-name">error-impl</span>
  <div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">io</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">num</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="c1">// We derive `Debug` because all types should probably derive `Debug`.
</span><span class="c1"></span><span class="c1">// This gives us a reasonable human readable description of `CliError` values.
</span><span class="c1"></span><span class="cp">#[</span><span class="cp">derive(Debug)</span><span class="cp">]</span><span class="w">
</span><span class="w"></span><span class="k">enum</span> <span class="nc">CliError</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="n">Io</span><span class="p">(</span><span class="n">io</span>::<span class="n">Error</span><span class="p">)</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="n">Parse</span><span class="p">(</span><span class="n">num</span>::<span class="n">ParseIntError</span><span class="p">)</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div>
</div>

<p>This particular error type represents the possibility of two types of errors
occurring: an error dealing with I/O or an error converting a string to a
number. The error could represent as many error types as you want by adding new
variants to the <code>enum</code> definition.</p>
<p>Implementing <code>Error</code> is pretty straight-forward. It's mostly going to be a lot
explicit case analysis.</p>

  <div class="named-code" id="code-error-impl-2">

  <span class="named-code-name">error-impl</span>
  <div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">error</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">fmt</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">fmt</span>::<span class="n">Display</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">CliError</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="k">fn</span> <span class="nf">fmt</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">f</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">fmt</span>::<span class="n">Formatter</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">fmt</span>::<span class="nb">Result</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="k">match</span><span class="w"> </span><span class="o">*</span><span class="bp">self</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">            </span><span class="c1">// Both underlying errors already impl `Display`, so we defer to
</span><span class="c1"></span><span class="w">            </span><span class="c1">// their implementations.
</span><span class="c1"></span><span class="w">            </span><span class="n">CliError</span>::<span class="n">Io</span><span class="p">(</span><span class="k">ref</span><span class="w"> </span><span class="n">err</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="o">&gt;</span><span class="w"> </span><span class="n">write</span><span class="o">!</span><span class="p">(</span><span class="n">f</span><span class="p">,</span><span class="w"> </span><span class="s">&#34;IO error: {}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">err</span><span class="p">)</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">            </span><span class="n">CliError</span>::<span class="n">Parse</span><span class="p">(</span><span class="k">ref</span><span class="w"> </span><span class="n">err</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="o">&gt;</span><span class="w"> </span><span class="n">write</span><span class="o">!</span><span class="p">(</span><span class="n">f</span><span class="p">,</span><span class="w"> </span><span class="s">&#34;Parse error: {}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">err</span><span class="p">)</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">error</span>::<span class="n">Error</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">CliError</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="k">fn</span> <span class="nf">description</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="kt">str</span> <span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="c1">// Both underlying errors already impl `Error`, so we defer to their
</span><span class="c1"></span><span class="w">        </span><span class="c1">// implementations.
</span><span class="c1"></span><span class="w">        </span><span class="k">match</span><span class="w"> </span><span class="o">*</span><span class="bp">self</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">            </span><span class="n">CliError</span>::<span class="n">Io</span><span class="p">(</span><span class="k">ref</span><span class="w"> </span><span class="n">err</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="o">&gt;</span><span class="w"> </span><span class="n">err</span><span class="p">.</span><span class="n">description</span><span class="p">(</span><span class="p">)</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">            </span><span class="c1">// Normally we can just write `err.description()`, but the error
</span><span class="c1"></span><span class="w">            </span><span class="c1">// type has a concrete method called `description`, which conflicts
</span><span class="c1"></span><span class="w">            </span><span class="c1">// with the trait method. For now, we must explicitly call
</span><span class="c1"></span><span class="w">            </span><span class="c1">// `description` through the `Error` trait.
</span><span class="c1"></span><span class="w">            </span><span class="n">CliError</span>::<span class="n">Parse</span><span class="p">(</span><span class="k">ref</span><span class="w"> </span><span class="n">err</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="o">&gt;</span><span class="w"> </span><span class="n">error</span>::<span class="n">Error</span>::<span class="n">description</span><span class="p">(</span><span class="n">err</span><span class="p">)</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="k">fn</span> <span class="nf">cause</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Option</span><span class="o">&lt;</span><span class="o">&amp;</span><span class="n">error</span>::<span class="n">Error</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="k">match</span><span class="w"> </span><span class="o">*</span><span class="bp">self</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">            </span><span class="c1">// N.B. Both of these implicitly cast `err` from their concrete
</span><span class="c1"></span><span class="w">            </span><span class="c1">// types (either `&amp;io::Error` or `&amp;num::ParseIntError`)
</span><span class="c1"></span><span class="w">            </span><span class="c1">// to a trait object `&amp;Error`. This works because both error types
</span><span class="c1"></span><span class="w">            </span><span class="c1">// implement `Error`.
</span><span class="c1"></span><span class="w">            </span><span class="n">CliError</span>::<span class="n">Io</span><span class="p">(</span><span class="k">ref</span><span class="w"> </span><span class="n">err</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="o">&gt;</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="n">err</span><span class="p">)</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">            </span><span class="n">CliError</span>::<span class="n">Parse</span><span class="p">(</span><span class="k">ref</span><span class="w"> </span><span class="n">err</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="o">&gt;</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="n">err</span><span class="p">)</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div>
</div>

<p>I note that this is a very typical implementation of <code>Error</code>: match on your
different error types and satisfy the contracts defined for <code>description</code> and
<code>cause</code>.</p>
<h3 id="the-from-trait">The <code>From</code> trait</h3>
<p>The <code>std::convert::From</code> trait is
<a href="http://doc.rust-lang.org/std/convert/trait.From.html">defined in the standard
library</a>:</p>

  <div class="named-code" id="code-from-def">

  <span class="named-code-name">from-def</span>
  <div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">trait</span><span class="w"> </span><span class="nb">From</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="k">fn</span> <span class="nf">from</span><span class="p">(</span><span class="n">T</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Self</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div>
</div>

<p>Deliciously simple, yes? <code>From</code> is very useful because it gives us a generic
way to talk about conversion <em>from</em> a particular type <code>T</code> to some other type
(in this case, &ldquo;some other type&rdquo; is the subject of the impl, or <code>Self</code>).
The crux of <code>From</code> is the
<a href="http://doc.rust-lang.org/std/convert/trait.From.html">set of implementations provided by the standard
library</a>.</p>
<p>Here are a few simple examples demonstrating how <code>From</code> works:</p>

  <div class="named-code" id="code-from-examples">

  <span class="named-code-name">from-examples</span>
  <div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="kd">let</span><span class="w"> </span><span class="n">string</span>: <span class="nb">String</span> <span class="o">=</span><span class="w"> </span><span class="nb">From</span>::<span class="n">from</span><span class="p">(</span><span class="s">&#34;foo&#34;</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="kd">let</span><span class="w"> </span><span class="n">bytes</span>: <span class="nb">Vec</span><span class="o">&lt;</span><span class="kt">u8</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">From</span>::<span class="n">from</span><span class="p">(</span><span class="s">&#34;foo&#34;</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="kd">let</span><span class="w"> </span><span class="n">cow</span>: ::<span class="n">std</span>::<span class="n">borrow</span>::<span class="n">Cow</span><span class="o">&lt;</span><span class="kt">str</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">From</span>::<span class="n">from</span><span class="p">(</span><span class="s">&#34;foo&#34;</span><span class="p">)</span><span class="p">;</span><span class="w">
</span></code></pre></div>
</div>

<p>OK, so <code>From</code> is useful for converting between strings. But what about errors?
It turns out, there is one critical impl:</p>



  
  

  
  
  
  

<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">impl</span><span class="o">&lt;</span><span class="na">&#39;a</span><span class="p">,</span><span class="w"> </span><span class="n">E</span>: <span class="nc">Error</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="na">&#39;a</span><span class="o">&gt;</span><span class="w"> </span><span class="nb">From</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="nb">Box</span><span class="o">&lt;</span><span class="n">Error</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="na">&#39;a</span><span class="o">&gt;</span><span class="w">
</span></code></pre></div>


<!-- raw HTML omitted -->
<p>This impl says that for <em>any</em> type that impls <code>Error</code>, we can convert it to a
trait object <code>Box&lt;Error&gt;</code>. This may not seem terribly surprising, but it is
useful in a generic context.</p>
<p>Remember the two errors we were dealing with previously? Specifically,
<code>io::Error</code> and <code>num::ParseIntError</code>. Since both impl <code>Error</code>, they work with
<code>From</code>:</p>

  <div class="named-code" id="code-from-examples-errors">

  <span class="named-code-name">from-examples-errors</span>
  <div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">error</span>::<span class="n">Error</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">fs</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">io</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">num</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="c1">// We have to jump through some hoops to actually get error values.
</span><span class="c1"></span><span class="kd">let</span><span class="w"> </span><span class="n">io_err</span>: <span class="nc">io</span>::<span class="n">Error</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">io</span>::<span class="n">Error</span>::<span class="n">last_os_error</span><span class="p">(</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="kd">let</span><span class="w"> </span><span class="n">parse_err</span>: <span class="nc">num</span>::<span class="n">ParseIntError</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&#34;not a number&#34;</span><span class="p">.</span><span class="n">parse</span>::<span class="o">&lt;</span><span class="kt">i32</span><span class="o">&gt;</span><span class="p">(</span><span class="p">)</span><span class="p">.</span><span class="n">unwrap_err</span><span class="p">(</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="c1">// OK, here are the conversions.
</span><span class="c1"></span><span class="kd">let</span><span class="w"> </span><span class="n">err1</span>: <span class="nb">Box</span><span class="o">&lt;</span><span class="n">Error</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">From</span>::<span class="n">from</span><span class="p">(</span><span class="n">io_err</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="kd">let</span><span class="w"> </span><span class="n">err2</span>: <span class="nb">Box</span><span class="o">&lt;</span><span class="n">Error</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">From</span>::<span class="n">from</span><span class="p">(</span><span class="n">parse_err</span><span class="p">)</span><span class="p">;</span><span class="w">
</span></code></pre></div>
</div>

<p>There is a really important pattern to recognize here. Both <code>err1</code> and <code>err2</code>
have the <em>same type</em>. This is because they are existentially quantified types,
or trait objects. In particular, their underlying type is <em>erased</em> from the
compiler's knowledge, so it truly sees <code>err1</code> and <code>err2</code> as exactly the same.
Additionally, we constructed <code>err1</code> and <code>err2</code> using precisely the same
function call: <code>From::from</code>. This is because <code>From::from</code> is overloaded on both
its argument and its return type.</p>
<p>This pattern is important because it solves a problem we had earlier: it gives
us a way to reliably convert errors to the same type using the same function.</p>
<p>Time to revisit an old friend; the <code>try!</code> macro/<code>?</code> operator.</p>
<h3 id="the-real-try-macro-operator">The real <code>try!</code> macro/<code>?</code> operator</h3>
<p>Previously, I presented this definition of <code>try!</code>:</p>



  
  

  
  
  
  

<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="n">macro_rules</span><span class="o">!</span><span class="w"> </span><span class="n">try</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="p">(</span><span class="cp">$e</span>:<span class="nc">expr</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="o">&gt;</span><span class="w"> </span><span class="p">(</span><span class="k">match</span><span class="w"> </span><span class="cp">$e</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="nb">Ok</span><span class="p">(</span><span class="n">val</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="o">&gt;</span><span class="w"> </span><span class="n">val</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="nb">Err</span><span class="p">(</span><span class="n">err</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="o">&gt;</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="nb">Err</span><span class="p">(</span><span class="n">err</span><span class="p">)</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="p">}</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div>


<p>This is not it's real definition. It's real definition is
<a href="http://doc.rust-lang.org/std/macro.try!.html">in the standard library</a>:</p>

  <div class="named-code" id="code-try-def">

  <span class="named-code-name">try-def</span>
  <div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="n">macro_rules</span><span class="o">!</span><span class="w"> </span><span class="n">try</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="p">(</span><span class="cp">$e</span>:<span class="nc">expr</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="o">&gt;</span><span class="w"> </span><span class="p">(</span><span class="k">match</span><span class="w"> </span><span class="cp">$e</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="nb">Ok</span><span class="p">(</span><span class="n">val</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="o">&gt;</span><span class="w"> </span><span class="n">val</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="nb">Err</span><span class="p">(</span><span class="n">err</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="o">&gt;</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="nb">Err</span><span class="p">(</span>::<span class="n">std</span>::<span class="n">convert</span>::<span class="nb">From</span>::<span class="n">from</span><span class="p">(</span><span class="n">err</span><span class="p">)</span><span class="p">)</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="p">}</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div>
</div>

<p>There's one tiny but powerful change: the error value is passed through
<code>From::from</code>. This makes the <code>try!</code> macro a lot more powerful because it gives
you automatic type conversion for free. This is also very similar to how the
<code>?</code> operator works, which is defined slightly differently. Namely, <code>x?</code>
desugars to something like the following:</p>

  <div class="named-code" id="code-questionmark-def">

  <span class="named-code-name">questionmark-def</span>
  <div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">match</span><span class="w"> </span>::<span class="n">std</span>::<span class="n">ops</span>::<span class="n">Try</span>::<span class="n">into_result</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="nb">Ok</span><span class="p">(</span><span class="n">v</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="o">&gt;</span><span class="w"> </span><span class="n">v</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="nb">Err</span><span class="p">(</span><span class="n">e</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="o">&gt;</span><span class="w"> </span><span class="k">return</span><span class="w"> </span>::<span class="n">std</span>::<span class="n">ops</span>::<span class="n">Try</span>::<span class="n">from_error</span><span class="p">(</span><span class="nb">From</span>::<span class="n">from</span><span class="p">(</span><span class="n">e</span><span class="p">)</span><span class="p">)</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div>
</div>

<p>The <a href="https://doc.rust-lang.org/std/ops/trait.Try.html"><code>Try</code> trait</a> is still
unstable and beyond the scope of this article, but the essence of it is that
it provides a way to abstract over many different types of success/failure
scenarios, without being tightly coupled to <code>Result&lt;T, E&gt;</code>. As you can see
though, the <code>x?</code> syntax still calls <code>From::from</code>, which is how we achieve
automatic error conversion.</p>
<p>Since most code written today uses <code>?</code> instead of <code>try!</code>, we will use <code>?</code> for
the remainder of this post.</p>
<p>Let's take a look at code we wrote previously to read a file and convert its
contents to an integer:</p>



  
  

  
  
  
  

<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">fs</span>::<span class="n">File</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">io</span>::<span class="n">Read</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">path</span>::<span class="n">Path</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">file_double</span><span class="o">&lt;</span><span class="n">P</span>: <span class="nb">AsRef</span><span class="o">&lt;</span><span class="n">Path</span><span class="o">&gt;</span><span class="o">&gt;</span><span class="p">(</span><span class="n">file_path</span>: <span class="nc">P</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="nb">String</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">file</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">File</span>::<span class="n">open</span><span class="p">(</span><span class="n">file_path</span><span class="p">)</span><span class="p">.</span><span class="n">map_err</span><span class="p">(</span><span class="o">|</span><span class="n">e</span><span class="o">|</span><span class="w"> </span><span class="n">e</span><span class="p">.</span><span class="n">to_string</span><span class="p">(</span><span class="p">)</span><span class="p">)</span><span class="o">?</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">contents</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">String</span>::<span class="n">new</span><span class="p">(</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="n">file</span><span class="p">.</span><span class="n">read_to_string</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">contents</span><span class="p">)</span><span class="p">.</span><span class="n">map_err</span><span class="p">(</span><span class="o">|</span><span class="n">e</span><span class="o">|</span><span class="w"> </span><span class="n">e</span><span class="p">.</span><span class="n">to_string</span><span class="p">(</span><span class="p">)</span><span class="p">)</span><span class="o">?</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">contents</span><span class="p">.</span><span class="n">trim</span><span class="p">(</span><span class="p">)</span><span class="p">.</span><span class="n">parse</span>::<span class="o">&lt;</span><span class="kt">i32</span><span class="o">&gt;</span><span class="p">(</span><span class="p">)</span><span class="p">.</span><span class="n">map_err</span><span class="p">(</span><span class="o">|</span><span class="n">e</span><span class="o">|</span><span class="w"> </span><span class="n">e</span><span class="p">.</span><span class="n">to_string</span><span class="p">(</span><span class="p">)</span><span class="p">)</span><span class="o">?</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="nb">Ok</span><span class="p">(</span><span class="mi">2</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div>


<p>Earlier, I promised that we could get rid of the <code>map_err</code> calls. Indeed, all
we have to do is pick a type that <code>From</code> works with. As we saw in the previous
section, <code>From</code> has an impl that let's it convert any error type into a
<code>Box&lt;Error&gt;</code>:</p>

  <div class="named-code" id="code-io-basic-error-try-from">

  <span class="named-code-name">io-basic-error-try-from</span>
  <div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">error</span>::<span class="n">Error</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">fs</span>::<span class="n">File</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">io</span>::<span class="n">Read</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">path</span>::<span class="n">Path</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">file_double</span><span class="o">&lt;</span><span class="n">P</span>: <span class="nb">AsRef</span><span class="o">&lt;</span><span class="n">Path</span><span class="o">&gt;</span><span class="o">&gt;</span><span class="p">(</span><span class="n">file_path</span>: <span class="nc">P</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="nb">Box</span><span class="o">&lt;</span><span class="n">Error</span><span class="o">&gt;</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">file</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">File</span>::<span class="n">open</span><span class="p">(</span><span class="n">file_path</span><span class="p">)</span><span class="o">?</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">contents</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">String</span>::<span class="n">new</span><span class="p">(</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="n">file</span><span class="p">.</span><span class="n">read_to_string</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">contents</span><span class="p">)</span><span class="o">?</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">contents</span><span class="p">.</span><span class="n">trim</span><span class="p">(</span><span class="p">)</span><span class="p">.</span><span class="n">parse</span>::<span class="o">&lt;</span><span class="kt">i32</span><span class="o">&gt;</span><span class="p">(</span><span class="p">)</span><span class="o">?</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="nb">Ok</span><span class="p">(</span><span class="mi">2</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div>
</div>

<p>We are getting very close to ideal error handling. Our code has very little
overhead as a result from error handling because the <code>?</code> operator encapsulates
three things simultaneously:</p>
<ol>
<li>Case analysis.</li>
<li>Control flow.</li>
<li>Error type conversion.</li>
</ol>
<p>When all three things are combined, we get code that is unencumbered by
combinators, calls to <code>unwrap</code> or case analysis.</p>
<p>There's one little nit left: the <code>Box&lt;Error&gt;</code> type is <em>opaque</em>. If we return a
<code>Box&lt;Error&gt;</code> to the caller, the caller can't (easily) inspect underlying error
type. The situation is certainly better than <code>String</code> because the caller can
call methods like
<a href="http://doc.rust-lang.org/std/error/trait.Error.html#tymethod.description"><code>description</code></a>
and
<a href="http://doc.rust-lang.org/std/error/trait.Error.html#method.cause"><code>cause</code></a>,
but the limitation remains: <code>Box&lt;Error&gt;</code> is opaque. (N.B. This isn't entirely
true because Rust does have runtime reflection, which is useful in some
scenarios that are
<a href="https://crates.io/crates/error">beyond the scope of this article</a>.)</p>
<p>It's time to revisit our custom <code>CliError</code> type and tie everything together.</p>
<h3 id="composing-custom-error-types">Composing custom error types</h3>
<p>In the last section, we looked at the real <code>?</code> operator and how it does
automatic type conversion for us by calling <code>From::from</code> on the error value.
In particular, we converted errors to <code>Box&lt;Error&gt;</code>, which works, but the type
is opaque to callers.</p>
<p>To fix this, we use the same remedy that we're already familiar with: a custom
error type. Once again, here is the code that reads the contents of a file and
converts it to an integer:</p>

  <div class="named-code" id="code-io-basic-error-custom-from-1">

  <span class="named-code-name">io-basic-error-custom-from</span>
  <div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">fs</span>::<span class="n">File</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">io</span>::<span class="p">{</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">Read</span><span class="p">}</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">num</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">path</span>::<span class="n">Path</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="c1">// We derive `Debug` because all types should probably derive `Debug`.
</span><span class="c1"></span><span class="c1">// This gives us a reasonable human readable description of `CliError` values.
</span><span class="c1"></span><span class="cp">#[</span><span class="cp">derive(Debug)</span><span class="cp">]</span><span class="w">
</span><span class="w"></span><span class="k">enum</span> <span class="nc">CliError</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="n">Io</span><span class="p">(</span><span class="n">io</span>::<span class="n">Error</span><span class="p">)</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="n">Parse</span><span class="p">(</span><span class="n">num</span>::<span class="n">ParseIntError</span><span class="p">)</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">file_double_verbose</span><span class="o">&lt;</span><span class="n">P</span>: <span class="nb">AsRef</span><span class="o">&lt;</span><span class="n">Path</span><span class="o">&gt;</span><span class="o">&gt;</span><span class="p">(</span><span class="n">file_path</span>: <span class="nc">P</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="n">CliError</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">file</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">File</span>::<span class="n">open</span><span class="p">(</span><span class="n">file_path</span><span class="p">)</span><span class="p">.</span><span class="n">map_err</span><span class="p">(</span><span class="n">CliError</span>::<span class="n">Io</span><span class="p">)</span><span class="o">?</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">contents</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">String</span>::<span class="n">new</span><span class="p">(</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="n">file</span><span class="p">.</span><span class="n">read_to_string</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">contents</span><span class="p">)</span><span class="p">.</span><span class="n">map_err</span><span class="p">(</span><span class="n">CliError</span>::<span class="n">Io</span><span class="p">)</span><span class="o">?</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">n</span>: <span class="kt">i32</span> <span class="o">=</span><span class="w"> </span><span class="n">contents</span><span class="p">.</span><span class="n">trim</span><span class="p">(</span><span class="p">)</span><span class="p">.</span><span class="n">parse</span><span class="p">(</span><span class="p">)</span><span class="p">.</span><span class="n">map_err</span><span class="p">(</span><span class="n">CliError</span>::<span class="n">Parse</span><span class="p">)</span><span class="o">?</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="nb">Ok</span><span class="p">(</span><span class="mi">2</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div>
</div>

<p>Notice that we still have the calls to <code>map_err</code>. Why? Well, recall the
definitions of the
<a href="rust-error-handling.html#code-questionmark-def"><code>?</code> operator</a> and <a href="rust-error-handling.html#code-from-def"><code>From</code></a>. The
problem is that there is no <code>From</code> impl that allows us to convert from error
types like <code>io::Error</code> and <code>num::ParseIntError</code> to our own custom <code>CliError</code>.
Of course, it is easy to fix this! Since we defined <code>CliError</code>, we can impl
<code>From</code> with it:</p>

  <div class="named-code" id="code-io-basic-error-custom-from-2">

  <span class="named-code-name">io-basic-error-custom-from</span>
  <div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">impl</span><span class="w"> </span><span class="nb">From</span><span class="o">&lt;</span><span class="n">io</span>::<span class="n">Error</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">CliError</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="k">fn</span> <span class="nf">from</span><span class="p">(</span><span class="n">err</span>: <span class="nc">io</span>::<span class="n">Error</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">CliError</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="n">CliError</span>::<span class="n">Io</span><span class="p">(</span><span class="n">err</span><span class="p">)</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="nb">From</span><span class="o">&lt;</span><span class="n">num</span>::<span class="n">ParseIntError</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">CliError</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="k">fn</span> <span class="nf">from</span><span class="p">(</span><span class="n">err</span>: <span class="nc">num</span>::<span class="n">ParseIntError</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">CliError</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="n">CliError</span>::<span class="n">Parse</span><span class="p">(</span><span class="n">err</span><span class="p">)</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div>
</div>

<p>All these impls are doing is teaching <code>From</code> how to create a <code>CliError</code> from
other error types. In our case, construction is as simple as invoking the
corresponding value constructor. Indeed, it is <em>typically</em> this easy.</p>
<p>We can finally rewrite <code>file_double</code>:</p>

  <div class="named-code" id="code-io-basic-error-custom-from-3">

  <span class="named-code-name">io-basic-error-custom-from</span>
  <div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">file_double</span><span class="o">&lt;</span><span class="n">P</span>: <span class="nb">AsRef</span><span class="o">&lt;</span><span class="n">Path</span><span class="o">&gt;</span><span class="o">&gt;</span><span class="p">(</span><span class="n">file_path</span>: <span class="nc">P</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="n">CliError</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">file</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">File</span>::<span class="n">open</span><span class="p">(</span><span class="n">file_path</span><span class="p">)</span><span class="o">?</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">contents</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">String</span>::<span class="n">new</span><span class="p">(</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="n">file</span><span class="p">.</span><span class="n">read_to_string</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">contents</span><span class="p">)</span><span class="o">?</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">n</span>: <span class="kt">i32</span> <span class="o">=</span><span class="w"> </span><span class="n">contents</span><span class="p">.</span><span class="n">trim</span><span class="p">(</span><span class="p">)</span><span class="p">.</span><span class="n">parse</span><span class="p">(</span><span class="p">)</span><span class="o">?</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="nb">Ok</span><span class="p">(</span><span class="mi">2</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div>
</div>

<p>The only thing we did here was remove the calls to <code>map_err</code>. They are no
longer needed because the <code>?</code> operator invokes <code>From::from</code> on the error value.
This works because we've provided <code>From</code> impls for all the error types that
could appear.</p>
<p>If we modified our <code>file_double</code> function to perform some other operation, say,
convert a string to a float, then we'd need to add a new variant to our error
type:</p>



  
  

  
  
  
  

<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">enum</span> <span class="nc">CliError</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="n">Io</span><span class="p">(</span><span class="n">io</span>::<span class="n">Error</span><span class="p">)</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="n">ParseInt</span><span class="p">(</span><span class="n">num</span>::<span class="n">ParseIntError</span><span class="p">)</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="n">ParseFloat</span><span class="p">(</span><span class="n">num</span>::<span class="n">ParseFloatError</span><span class="p">)</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div>


<p>To reflect this change we need to update the previous
<code>impl From&lt;num::ParseIntError&gt; for CliError</code> and add the new
<code>impl From&lt;num::ParseFloatError&gt; for CliError</code>:</p>



  
  

  
  
  
  

<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">impl</span><span class="w"> </span><span class="nb">From</span><span class="o">&lt;</span><span class="n">num</span>::<span class="n">ParseIntError</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">CliError</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="k">fn</span> <span class="nf">from</span><span class="p">(</span><span class="n">err</span>: <span class="nc">num</span>::<span class="n">ParseIntError</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">CliError</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="n">CliError</span>::<span class="n">ParseInt</span><span class="p">(</span><span class="n">err</span><span class="p">)</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="nb">From</span><span class="o">&lt;</span><span class="n">num</span>::<span class="n">ParseFloatError</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">CliError</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="k">fn</span> <span class="nf">from</span><span class="p">(</span><span class="n">err</span>: <span class="nc">num</span>::<span class="n">ParseFloatError</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">CliError</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="n">CliError</span>::<span class="n">ParseFloat</span><span class="p">(</span><span class="n">err</span><span class="p">)</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div>


<p>And that's it!</p>
<h3 id="advice-for-library-writers">Advice for library writers</h3>
<p>Idioms for Rust libraries are still forming, but if your library needs to
report custom errors, then you should probably define your own error type.
It's up to you whether or not to expose its representation
(like <a href="http://doc.rust-lang.org/std/io/enum.ErrorKind.html"><code>ErrorKind</code></a>)
or keep it hidden
(like
<a href="http://doc.rust-lang.org/std/num/struct.ParseIntError.html"><code>ParseIntError</code></a>).
Regardless of how you do it, it's usually good practice to at least provide
some information about the error beyond just its <code>String</code> representation. But
certainly, this will vary depending on use cases.</p>
<p>At a minimum, you should probably implement the
<a href="http://doc.rust-lang.org/std/error/trait.Error.html"><code>Error</code></a>
trait. This will give users of your library some minimum flexibility for
<a href="rust-error-handling.html#the-real-try-macro">composing errors</a>. Implementing the <code>Error</code> trait also
means that users are guaranteed the ability to obtain a string representation
of an error (because it requires impls for both <code>fmt::Debug</code> and
<code>fmt::Display</code>).</p>
<p>Beyond that, it can also be useful to provide implementations of <code>From</code> on your
error types. This allows you (the library author) and your users to
<a href="rust-error-handling.html#composing-custom-error-types">compose more detailed errors</a>. For example,
<a href="https://burntsushi.net/rustdoc/csv/1.0.0-beta.5/enum.Error.html"><code>csv::Error</code></a>
provides <code>From</code> impls for both <code>io::Error</code> and <code>byteorder::Error</code>.</p>
<p>Finally, depending on your tastes, you may also want to define a
<a href="rust-error-handling.html#the-result-type-alias-idiom"><code>Result</code> type alias</a>, particularly if your
library defines a single error type. This is used in the standard library
for <a href="http://doc.rust-lang.org/std/io/type.Result.html"><code>io::Result</code></a>
and <a href="http://doc.rust-lang.org/std/fmt/type.Result.html"><code>fmt::Result</code></a>.</p>
<h2 id="case-study-a-program-to-read-population-data">Case study: A program to read population data</h2>
<p>This article was long, and depending on your background, it might be rather
dense. While there is plenty of example code to go along with the prose, most
of it was specifically designed to be pedagogical. While I'm not quite smart
enough to craft pedagogical examples that are also <em>not</em> toy examples, I
certainly can write about a case study.</p>
<p>For this, I'd like to build up a command line program that lets you
query world population data. The objective is simple: you give it a location
and it will tell you the population. Despite the simplicity, there is a lot
that can go wrong!</p>
<p>The data we'll be using comes from the
<a href="https://github.com/petewarden/dstkdata">Data Science Toolkit</a>. I've prepared
some data from it for this exercise. You can either grab the
<a href="https://burntsushi.net/stuff/worldcitiespop.csv.gz">world population data</a>
(41MB gzip compressed, 145MB uncompressed) or just the
<a href="https://burntsushi.net/stuff/uscitiespop.csv.gz">US population data</a>
(2.2MB gzip compressed, 7.2MB uncompressed).</p>
<p>Up until now, I've kept the code limited to Rust's standard library. For a real
task like this though, we'll want to at least use something to parse CSV data,
parse the program arguments and decode that stuff into Rust types automatically. For that, we'll use the
<a href="https://crates.io/crates/csv"><code>csv</code></a>,
<a href="https://crates.io/crates/docopt"><code>docopt</code></a>
and <a href="https://crates.io/crates/rustc-serialize"><code>rustc-serialize</code></a> crates.</p>
<h3 id="its-on-github">It's on Github</h3>
<p>The final code for this case study is
<a href="https://github.com/BurntSushi/rust-error-handling-case-study">on Github</a>.
If you have Rust and Cargo installed, then all you need to do is:</p>



<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">git clone git://github.com/BurntSushi/rust-error-handling-case-study
<span class="nb">cd</span> rust-error-handling-case-study
cargo build --release
./target/release/city-pop --help</code></pre></div>


<p>We'll build up this project in pieces. Read on and follow along!</p>
<h3 id="initial-setup">Initial setup</h3>
<p>I'm not going to spend a lot of time on setting up a project with Cargo because
it is already covered well in
<a href="http://doc.rust-lang.org/1.0.0-beta.5/book/hello-cargo.html">the Rust book</a>
and
<a href="http://doc.crates.io/guide.html">Cargo's documentation</a>.</p>
<p>To get started from scratch, run <code>cargo new --bin city-pop</code> and make sure your
<code>Cargo.toml</code> looks something like this:</p>



<div class="highlight"><pre class="chroma"><code class="language-text" data-lang="text">[package]
name = &#34;city-pop&#34;
version = &#34;0.1.0&#34;
authors = [&#34;Andrew Gallant &lt;jamslam@gmail.com&gt;&#34;]

[[bin]]
name = &#34;city-pop&#34;

[dependencies]
csv = &#34;0.*&#34;
docopt = &#34;0.*&#34;
rustc-serialize = &#34;0.*&#34;</code></pre></div>


<!-- raw HTML omitted -->
<p>You should already be able to run:</p>



<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">cargo build --release
./target/release/city-pop
<span class="c1">#Outputs: Hello, world!</span></code></pre></div>


<h3 id="argument-parsing">Argument parsing</h3>
<p>Let's get argument parsing out of the way. I won't go into too much detail on
Docopt, but there is a
<a href="http://docopt.org/">nice web page</a> describing it and
<a href="https://burntsushi.net/rustdoc/docopt/">documentation for the Rust crate</a>.
The short story is that Docopt generates an argument parser <em>from the usage
string</em>. Once the parsing is done, we can decode the program arguments into a
Rust struct. Here's our program with the appropriate <code>extern crate</code> statements,
the usage string, our <code>Args</code> struct and an empty <code>main</code>:</p>



  
  

  
  
  
  

<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">extern</span><span class="w"> </span><span class="k">crate</span><span class="w"> </span><span class="n">docopt</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">extern</span><span class="w"> </span><span class="k">crate</span><span class="w"> </span><span class="n">rustc_serialize</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="k">static</span><span class="w"> </span><span class="n">USAGE</span>: <span class="kp">&amp;</span><span class="nb">&#39;static</span><span class="w"> </span><span class="kt">str</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="err">&#34;</span><span class="w">
</span><span class="w"></span><span class="n">Usage</span>: <span class="nc">city</span><span class="o">-</span><span class="n">pop</span><span class="w"> </span><span class="p">[</span><span class="n">options</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;</span><span class="n">data</span><span class="o">-</span><span class="n">path</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&lt;</span><span class="n">city</span><span class="o">&gt;</span><span class="w">
</span><span class="w"></span><span class="w">       </span><span class="n">city</span><span class="o">-</span><span class="n">pop</span><span class="w"> </span><span class="o">-</span><span class="o">-</span><span class="n">help</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="n">Options</span>:
    <span class="o">-</span><span class="n">h</span><span class="p">,</span><span class="w"> </span><span class="o">-</span><span class="o">-</span><span class="n">help</span><span class="w">     </span><span class="n">Show</span><span class="w"> </span><span class="n">this</span><span class="w"> </span><span class="n">usage</span><span class="w"> </span><span class="n">message</span><span class="p">.</span><span class="w">
</span><span class="w"></span><span class="err">&#34;</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">Args</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="n">arg_data_path</span>: <span class="nb">String</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="n">arg_city</span>: <span class="nb">String</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">main</span><span class="p">(</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div>


<p>Okay, time to get coding. The
<a href="https://burntsushi.net/rustdoc/docopt/struct.Docopt.html#method.new">docs for
Docopt</a>
say we can create a new parser with <code>Docopt::new</code> and then decode the current
program arguments into a struct with <code>Docopt::decode</code>. The catch is that both
of these functions can return a
<a href="https://burntsushi.net/rustdoc/docopt/enum.Error.html"><code>docopt::Error</code></a>.
We can start with explicit case analysis:</p>



  
  

  
  
  
  

<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="c1">// These use statements were added below the `extern` statements.
</span><span class="c1"></span><span class="c1">// I&#39;ll elide them in the future. Don&#39;t worry! It&#39;s all on Github:
</span><span class="c1"></span><span class="c1">// https://github.com/BurntSushi/rust-error-handling-case-study
</span><span class="c1"></span><span class="c1">//use std::io::{self, Write};
</span><span class="c1"></span><span class="c1">//use std::process;
</span><span class="c1"></span><span class="c1">//use docopt::Docopt;
</span><span class="c1"></span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">main</span><span class="p">(</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">args</span>: <span class="nc">Args</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">match</span><span class="w"> </span><span class="n">Docopt</span>::<span class="n">new</span><span class="p">(</span><span class="n">USAGE</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="nb">Err</span><span class="p">(</span><span class="n">err</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">            </span><span class="n">writeln</span><span class="o">!</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">io</span>::<span class="n">stderr</span><span class="p">(</span><span class="p">)</span><span class="p">,</span><span class="w"> </span><span class="s">&#34;{}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">err</span><span class="p">)</span><span class="p">.</span><span class="n">unwrap</span><span class="p">(</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">            </span><span class="n">process</span>::<span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="nb">Ok</span><span class="p">(</span><span class="n">dopt</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="o">&gt;</span><span class="w"> </span><span class="k">match</span><span class="w"> </span><span class="n">dopt</span><span class="p">.</span><span class="n">decode</span><span class="p">(</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">            </span><span class="nb">Err</span><span class="p">(</span><span class="n">err</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">                </span><span class="n">writeln</span><span class="o">!</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">io</span>::<span class="n">stderr</span><span class="p">(</span><span class="p">)</span><span class="p">,</span><span class="w"> </span><span class="s">&#34;{}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">err</span><span class="p">)</span><span class="p">.</span><span class="n">unwrap</span><span class="p">(</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">                </span><span class="n">process</span>::<span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">            </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="w">            </span><span class="nb">Ok</span><span class="p">(</span><span class="n">args</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="o">&gt;</span><span class="w"> </span><span class="n">args</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="p">}</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div>


<p>This is not so nice. One thing we can do to make the code a bit clearer is to
write a macro to print messages to <code>stderr</code> and then exit:</p>

  <div class="named-code" id="code-fatal-def">

  <span class="named-code-name">fatal-def</span>
  <div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="n">macro_rules</span><span class="o">!</span><span class="w"> </span><span class="n">fatal</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="p">(</span><span class="cp">$(</span><span class="cp">$tt</span>:<span class="nc">tt</span><span class="p">)</span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">io</span>::<span class="n">Write</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="n">writeln</span><span class="o">!</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span>::<span class="n">std</span>::<span class="n">io</span>::<span class="n">stderr</span><span class="p">(</span><span class="p">)</span><span class="p">,</span><span class="w"> </span><span class="cp">$(</span><span class="cp">$tt</span><span class="p">)</span><span class="o">*</span><span class="p">)</span><span class="p">.</span><span class="n">unwrap</span><span class="p">(</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">        </span>::<span class="n">std</span>::<span class="n">process</span>::<span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="p">}</span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div>
</div>

<p>The <code>unwrap</code> is probably OK here, because if it fails, it means your program
could not write to <code>stderr</code>. A good rule of thumb here is that it's OK to
abort, but certainly, you could do something else if you needed to.</p>
<p>The code looks nicer, but the explicit case analysis is still a drag:</p>



  
  

  
  
  
  

<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="kd">let</span><span class="w"> </span><span class="n">args</span>: <span class="nc">Args</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">match</span><span class="w"> </span><span class="n">Docopt</span>::<span class="n">new</span><span class="p">(</span><span class="n">USAGE</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="nb">Err</span><span class="p">(</span><span class="n">err</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="o">&gt;</span><span class="w"> </span><span class="n">fatal</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;{}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">err</span><span class="p">)</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="nb">Ok</span><span class="p">(</span><span class="n">dopt</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="o">&gt;</span><span class="w"> </span><span class="k">match</span><span class="w"> </span><span class="n">dopt</span><span class="p">.</span><span class="n">decode</span><span class="p">(</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="nb">Err</span><span class="p">(</span><span class="n">err</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="o">&gt;</span><span class="w"> </span><span class="n">fatal</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;{}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">err</span><span class="p">)</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="nb">Ok</span><span class="p">(</span><span class="n">args</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="o">&gt;</span><span class="w"> </span><span class="n">args</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="p">;</span><span class="w">
</span></code></pre></div>


<p>Thankfully, the
<a href="https://burntsushi.net/rustdoc/docopt/enum.Error.html"><code>docopt::Error</code></a>
type defines a convenient method
<a href="https://burntsushi.net/rustdoc/docopt/enum.Error.html#method.exit"><code>exit</code></a>,
which effectively does what we just did. Combine that with our knowledge of
combinators, and we have concise, easy to read code:</p>



  
  

  
  
  
  

<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="kd">let</span><span class="w"> </span><span class="n">args</span>: <span class="nc">Args</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Docopt</span>::<span class="n">new</span><span class="p">(</span><span class="n">USAGE</span><span class="p">)</span><span class="w">
</span><span class="w"></span><span class="w">                        </span><span class="p">.</span><span class="n">and_then</span><span class="p">(</span><span class="o">|</span><span class="n">d</span><span class="o">|</span><span class="w"> </span><span class="n">d</span><span class="p">.</span><span class="n">decode</span><span class="p">(</span><span class="p">)</span><span class="p">)</span><span class="w">
</span><span class="w"></span><span class="w">                        </span><span class="p">.</span><span class="n">unwrap_or_else</span><span class="p">(</span><span class="o">|</span><span class="n">err</span><span class="o">|</span><span class="w"> </span><span class="n">err</span><span class="p">.</span><span class="n">exit</span><span class="p">(</span><span class="p">)</span><span class="p">)</span><span class="p">;</span><span class="w">
</span></code></pre></div>


<p>If this code completes successfully, then <code>args</code> will be filled from the values
provided by the user.</p>
<h3 id="writing-the-logic">Writing the logic</h3>
<p>We're all different in how we write code, but when I'm not sure how to go about
coding a problem, error handling is usually the last thing I want to think
about. This isn't very good practice for good design, but it can be useful for
rapidly prototyping. In our case, because Rust forces us to be explicit about
error handling, it will also make it obvious what parts of our program can
cause errors. Why? Because Rust will make us call <code>unwrap</code>! This can give us a
nice bird's eye view of how we need to approach error handling.</p>
<p>In this case study, the logic is really simple. All we need to do is parse the
CSV data given to us and print out a field in matching rows. Let's do it. (Make
sure to add <code>extern crate csv;</code> to the top of your file.)</p>



  
  

  
  
  
  

<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="c1">// This struct represents the data in each row of the CSV file.
</span><span class="c1"></span><span class="c1">// Type based decoding absolves us of a lot of the nitty gritty error
</span><span class="c1"></span><span class="c1">// handling, like parsing strings as integers or floats.
</span><span class="c1"></span><span class="k">struct</span> <span class="nc">Row</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="n">country</span>: <span class="nb">String</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="n">city</span>: <span class="nb">String</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="n">accent_city</span>: <span class="nb">String</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="n">region</span>: <span class="nb">String</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="c1">// Not every row has data for the population, latitude or longitude!
</span><span class="c1"></span><span class="w">    </span><span class="c1">// So we express them as `Option` types, which admits the possibility of
</span><span class="c1"></span><span class="w">    </span><span class="c1">// absence. The CSV parser will fill in the correct value for us.
</span><span class="c1"></span><span class="w">    </span><span class="n">population</span>: <span class="nb">Option</span><span class="o">&lt;</span><span class="kt">u64</span><span class="o">&gt;</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="n">latitude</span>: <span class="nb">Option</span><span class="o">&lt;</span><span class="kt">f64</span><span class="o">&gt;</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="n">longitude</span>: <span class="nb">Option</span><span class="o">&lt;</span><span class="kt">f64</span><span class="o">&gt;</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">main</span><span class="p">(</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">args</span>: <span class="nc">Args</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Docopt</span>::<span class="n">new</span><span class="p">(</span><span class="n">USAGE</span><span class="p">)</span><span class="w">
</span><span class="w"></span><span class="w">                            </span><span class="p">.</span><span class="n">and_then</span><span class="p">(</span><span class="o">|</span><span class="n">d</span><span class="o">|</span><span class="w"> </span><span class="n">d</span><span class="p">.</span><span class="n">decode</span><span class="p">(</span><span class="p">)</span><span class="p">)</span><span class="w">
</span><span class="w"></span><span class="w">                            </span><span class="p">.</span><span class="n">unwrap_or_else</span><span class="p">(</span><span class="o">|</span><span class="n">err</span><span class="o">|</span><span class="w"> </span><span class="n">err</span><span class="p">.</span><span class="n">exit</span><span class="p">(</span><span class="p">)</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">file</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fs</span>::<span class="n">File</span>::<span class="n">open</span><span class="p">(</span><span class="n">args</span><span class="p">.</span><span class="n">arg_data_path</span><span class="p">)</span><span class="p">.</span><span class="n">unwrap</span><span class="p">(</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">rdr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">csv</span>::<span class="n">Reader</span>::<span class="n">from_reader</span><span class="p">(</span><span class="n">file</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="n">row</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">rdr</span><span class="p">.</span><span class="n">decode</span>::<span class="o">&lt;</span><span class="n">Row</span><span class="o">&gt;</span><span class="p">(</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">row</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">row</span><span class="p">.</span><span class="n">unwrap</span><span class="p">(</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="n">row</span><span class="p">.</span><span class="n">city</span><span class="w"> </span><span class="o">=</span><span class="o">=</span><span class="w"> </span><span class="n">args</span><span class="p">.</span><span class="n">arg_city</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">            </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;{}, {}: {:?}&#34;</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">                     </span><span class="n">row</span><span class="p">.</span><span class="n">city</span><span class="p">,</span><span class="w"> </span><span class="n">row</span><span class="p">.</span><span class="n">country</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">                     </span><span class="n">row</span><span class="p">.</span><span class="n">population</span><span class="p">.</span><span class="n">expect</span><span class="p">(</span><span class="s">&#34;population count&#34;</span><span class="p">)</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div>


<p>Let's outline the errors. We can start with the obvious: the three places that
<code>unwrap</code> is called:</p>
<ol>
<li><a href="http://doc.rust-lang.org/std/fs/struct.File.html#method.open"><code>fs::File::open</code></a>
can return an
<a href="http://doc.rust-lang.org/std/io/struct.Error.html"><code>io::Error</code></a>.</li>
<li><a href="https://burntsushi.net/rustdoc/csv/struct.Reader.html#method.decode"><code>csv::Reader::decode</code></a>
decodes one record at a time, and
<a href="https://burntsushi.net/rustdoc/csv/struct.DecodedRecords.html">decoding a
record</a>
(look at the <code>Item</code> associated type on the <code>Iterator</code> impl)
can produce a
<a href="https://burntsushi.net/rustdoc/csv/1.0.0-beta.5/enum.Error.html"><code>csv::Error</code></a>.</li>
<li>If <code>row.population</code> is <code>None</code>, then calling <code>expect</code> will panic.</li>
</ol>
<p>Are there any others? What if we can't find a matching city? Tools like <code>grep</code>
will return an error code, so we probably should too. So we have logic errors
specific to our problem, IO errors and CSV parsing errors. We're going to
explore two different ways to approach handling these errors.</p>
<p>I'd like to start with <code>Box&lt;Error&gt;</code>. Later, we'll see how defining our own
error type can be useful.</p>
<h3 id="error-handling-with-boxerror">Error handling with <code>Box&lt;Error&gt;</code></h3>
<p><code>Box&lt;Error&gt;</code> is nice because it <em>just works</em>. You don't need to define your own
error types and you don't need any <code>From</code> implementations. The downside is that
since <code>Box&lt;Error&gt;</code> is a trait object, it <em>erases the type</em>, which means the
compiler can no longer reason about its underlying type.</p>
<p><a href="rust-error-handling.html#the-limits-of-combinators">Previously</a> we started refactoring our code by
changing the type of our function from <code>T</code> to <code>Result&lt;T, OurErrorType&gt;</code>. In
this case, <code>OurErrorType</code> is just <code>Box&lt;Error&gt;</code>. But what's <code>T</code>? And can we add
a return type to <code>main</code>?</p>
<p>The answer to the second question is no, we can't. That means we'll need to
write a new function. But what is <code>T</code>? The simplest thing we can do is to
return a list of matching <code>Row</code> values as a <code>Vec&lt;Row&gt;</code>. (Better code would
return an iterator, but that is left as an exercise to the reader.)</p>
<p>Let's refactor our code into its own function, but keep the calls to <code>unwrap</code>.
Note that we opt to handle the possibility of a missing population count by
simply ignoring that row.</p>



  
  

  
  
  
  

<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">struct</span> <span class="nc">Row</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="c1">// unchanged
</span><span class="c1"></span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">PopulationCount</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="n">city</span>: <span class="nb">String</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="n">country</span>: <span class="nb">String</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="c1">// This is no longer an `Option` because values of this type are only
</span><span class="c1"></span><span class="w">    </span><span class="c1">// constructed if they have a population count.
</span><span class="c1"></span><span class="w">    </span><span class="n">count</span>: <span class="kt">u64</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">search</span><span class="o">&lt;</span><span class="n">P</span>: <span class="nb">AsRef</span><span class="o">&lt;</span><span class="n">Path</span><span class="o">&gt;</span><span class="o">&gt;</span><span class="p">(</span><span class="n">file_path</span>: <span class="nc">P</span><span class="p">,</span><span class="w"> </span><span class="n">city</span>: <span class="kp">&amp;</span><span class="kt">str</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">PopulationCount</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">found</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vec</span><span class="o">!</span><span class="p">[</span><span class="p">]</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">file</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fs</span>::<span class="n">File</span>::<span class="n">open</span><span class="p">(</span><span class="n">file_path</span><span class="p">)</span><span class="p">.</span><span class="n">unwrap</span><span class="p">(</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">rdr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">csv</span>::<span class="n">Reader</span>::<span class="n">from_reader</span><span class="p">(</span><span class="n">file</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="n">row</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">rdr</span><span class="p">.</span><span class="n">decode</span>::<span class="o">&lt;</span><span class="n">Row</span><span class="o">&gt;</span><span class="p">(</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">row</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">row</span><span class="p">.</span><span class="n">unwrap</span><span class="p">(</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="k">match</span><span class="w"> </span><span class="n">row</span><span class="p">.</span><span class="n">population</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">            </span><span class="nb">None</span><span class="w"> </span><span class="o">=</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="c1">// skip it
</span><span class="c1"></span><span class="w">            </span><span class="nb">Some</span><span class="p">(</span><span class="n">count</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="o">&gt;</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">row</span><span class="p">.</span><span class="n">city</span><span class="w"> </span><span class="o">=</span><span class="o">=</span><span class="w"> </span><span class="n">city</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">                </span><span class="n">found</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">PopulationCount</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">                    </span><span class="n">city</span>: <span class="nc">row</span><span class="p">.</span><span class="n">city</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">                    </span><span class="n">country</span>: <span class="nc">row</span><span class="p">.</span><span class="n">country</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">                    </span><span class="n">count</span>: <span class="nc">count</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">                </span><span class="p">}</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">            </span><span class="p">}</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="n">found</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">main</span><span class="p">(</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">args</span>: <span class="nc">Args</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Docopt</span>::<span class="n">new</span><span class="p">(</span><span class="n">USAGE</span><span class="p">)</span><span class="w">
</span><span class="w"></span><span class="w">                            </span><span class="p">.</span><span class="n">and_then</span><span class="p">(</span><span class="o">|</span><span class="n">d</span><span class="o">|</span><span class="w"> </span><span class="n">d</span><span class="p">.</span><span class="n">decode</span><span class="p">(</span><span class="p">)</span><span class="p">)</span><span class="w">
</span><span class="w"></span><span class="w">                            </span><span class="p">.</span><span class="n">unwrap_or_else</span><span class="p">(</span><span class="o">|</span><span class="n">err</span><span class="o">|</span><span class="w"> </span><span class="n">err</span><span class="p">.</span><span class="n">exit</span><span class="p">(</span><span class="p">)</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="n">pop</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">search</span><span class="p">(</span><span class="o">&amp;</span><span class="n">args</span><span class="p">.</span><span class="n">arg_data_path</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">args</span><span class="p">.</span><span class="n">arg_city</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;{}, {}: {:?}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">pop</span><span class="p">.</span><span class="n">city</span><span class="p">,</span><span class="w"> </span><span class="n">pop</span><span class="p">.</span><span class="n">country</span><span class="p">,</span><span class="w"> </span><span class="n">pop</span><span class="p">.</span><span class="n">count</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div>


<p>While we got rid of one use of <code>expect</code> (which is a nicer variant of <code>unwrap</code>),
we still should handle the absence of any search results.</p>
<p>To convert this to proper error handling, we need to do the following:</p>
<ol>
<li>Change the return type of <code>search</code> to be <code>Result&lt;Vec&lt;PopulationCount&gt;, Box&lt;Error&gt;&gt;</code>.</li>
<li>Use the <code>?</code> operator so that errors are returned to the caller instead of
panicking the program.</li>
<li>Handle the error in <code>main</code>.</li>
</ol>
<p>Let's try it:</p>



  
  

  
  
  
  

<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">search</span><span class="o">&lt;</span><span class="n">P</span>: <span class="nb">AsRef</span><span class="o">&lt;</span><span class="n">Path</span><span class="o">&gt;</span><span class="o">&gt;</span><span class="w">
</span><span class="w"></span><span class="w">         </span><span class="p">(</span><span class="n">file_path</span>: <span class="nc">P</span><span class="p">,</span><span class="w"> </span><span class="n">city</span>: <span class="kp">&amp;</span><span class="kt">str</span><span class="p">)</span><span class="w">
</span><span class="w"></span><span class="w">         </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="n">PopulationCount</span><span class="o">&gt;</span><span class="p">,</span><span class="w"> </span><span class="nb">Box</span><span class="o">&lt;</span><span class="n">Error</span><span class="o">+</span><span class="nb">Send</span><span class="o">+</span><span class="nb">Sync</span><span class="o">&gt;</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">found</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vec</span><span class="o">!</span><span class="p">[</span><span class="p">]</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">file</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fs</span>::<span class="n">File</span>::<span class="n">open</span><span class="p">(</span><span class="n">file_path</span><span class="p">)</span><span class="o">?</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">rdr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">csv</span>::<span class="n">Reader</span>::<span class="n">from_reader</span><span class="p">(</span><span class="n">file</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="n">row</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">rdr</span><span class="p">.</span><span class="n">decode</span>::<span class="o">&lt;</span><span class="n">Row</span><span class="o">&gt;</span><span class="p">(</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">row</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">row</span><span class="o">?</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="k">match</span><span class="w"> </span><span class="n">row</span><span class="p">.</span><span class="n">population</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">            </span><span class="nb">None</span><span class="w"> </span><span class="o">=</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="c1">// skip it
</span><span class="c1"></span><span class="w">            </span><span class="nb">Some</span><span class="p">(</span><span class="n">count</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="o">&gt;</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">row</span><span class="p">.</span><span class="n">city</span><span class="w"> </span><span class="o">=</span><span class="o">=</span><span class="w"> </span><span class="n">city</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">                </span><span class="n">found</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">PopulationCount</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">                    </span><span class="n">city</span>: <span class="nc">row</span><span class="p">.</span><span class="n">city</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">                    </span><span class="n">country</span>: <span class="nc">row</span><span class="p">.</span><span class="n">country</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">                    </span><span class="n">count</span>: <span class="nc">count</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">                </span><span class="p">}</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">            </span><span class="p">}</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="n">found</span><span class="p">.</span><span class="n">is_empty</span><span class="p">(</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="nb">Err</span><span class="p">(</span><span class="nb">From</span>::<span class="n">from</span><span class="p">(</span><span class="s">&#34;No matching cities with a population were found.&#34;</span><span class="p">)</span><span class="p">)</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="nb">Ok</span><span class="p">(</span><span class="n">found</span><span class="p">)</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div>


<p>Instead of <code>x.unwrap()</code>, we now have <code>x?</code>. Since our function returns a
<code>Result&lt;T, E&gt;</code>, the <code>?</code> operator will return early from the function if an
error occurs.</p>
<p>There is one big gotcha in this code: we used <code>Box&lt;Error + Send + Sync&gt;</code>
instead of <code>Box&lt;Error&gt;</code>. We did this so we could convert a plain string to an
error type. We need these extra bounds so that we can use the
<a href="http://doc.rust-lang.org/std/convert/trait.From.html">corresponding <code>From</code>
impls</a>:</p>



  
  

  
  
  
  

<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="c1">// We are making use of this impl in the code above, since we call `From::from`
</span><span class="c1"></span><span class="c1">// on a `&amp;&#39;static str`.
</span><span class="c1"></span><span class="k">impl</span><span class="o">&lt;</span><span class="na">&#39;a</span><span class="p">,</span><span class="w"> </span><span class="na">&#39;b</span><span class="o">&gt;</span><span class="w"> </span><span class="nb">From</span><span class="o">&lt;</span><span class="o">&amp;</span><span class="na">&#39;b</span><span class="w"> </span><span class="kt">str</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="nb">Box</span><span class="o">&lt;</span><span class="n">Error</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nb">Send</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nb">Sync</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="na">&#39;a</span><span class="o">&gt;</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="c1">// But this is also useful when you need to allocate a new string for an
</span><span class="c1"></span><span class="c1">// error message, usually with `format!`.
</span><span class="c1"></span><span class="k">impl</span><span class="w"> </span><span class="nb">From</span><span class="o">&lt;</span><span class="nb">String</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="nb">Box</span><span class="o">&lt;</span><span class="n">Error</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nb">Send</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nb">Sync</span><span class="o">&gt;</span><span class="w">
</span></code></pre></div>


<!-- raw HTML omitted -->
<p>Now that we've seen how to do proper error handling with <code>Box&lt;Error&gt;</code>, let's
try a different approach with our own custom error type. But first, let's take
a quick break from error handling and add support for reading from <code>stdin</code>.</p>
<h3 id="reading-from-stdin">Reading from stdin</h3>
<p>In our program, we accept a single file for input and do one pass over the
data. This means we probably should be able to accept input on stdin. But maybe
we like the current format too&mdash;so let's have both!</p>
<p>Adding support for stdin is actually quite easy. There are only two things we
have to do:</p>
<ol>
<li>Tweak the program arguments so that a single parameter&mdash;the city&mdash;can be
accepted while the population data is read from stdin.</li>
<li>Modify the <code>search</code> function to take an <em>optional</em> file path. When <code>None</code>,
it should know to read from stdin.</li>
</ol>
<p>First, here's the new usage and <code>Args</code> struct:</p>



  
  

  
  
  
  

<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">static</span><span class="w"> </span><span class="n">USAGE</span>: <span class="kp">&amp;</span><span class="nb">&#39;static</span><span class="w"> </span><span class="kt">str</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="err">&#34;</span><span class="w">
</span><span class="w"></span><span class="n">Usage</span>: <span class="nc">city</span><span class="o">-</span><span class="n">pop</span><span class="w"> </span><span class="p">[</span><span class="n">options</span><span class="p">]</span><span class="w"> </span><span class="p">[</span><span class="o">&lt;</span><span class="n">data</span><span class="o">-</span><span class="n">path</span><span class="o">&gt;</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;</span><span class="n">city</span><span class="o">&gt;</span><span class="w">
</span><span class="w"></span><span class="w">       </span><span class="n">city</span><span class="o">-</span><span class="n">pop</span><span class="w"> </span><span class="o">-</span><span class="o">-</span><span class="n">help</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="n">Options</span>:
    <span class="o">-</span><span class="n">h</span><span class="p">,</span><span class="w"> </span><span class="o">-</span><span class="o">-</span><span class="n">help</span><span class="w">     </span><span class="n">Show</span><span class="w"> </span><span class="n">this</span><span class="w"> </span><span class="n">usage</span><span class="w"> </span><span class="n">message</span><span class="p">.</span><span class="w">
</span><span class="w"></span><span class="err">&#34;</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">Args</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="n">arg_data_path</span>: <span class="nb">Option</span><span class="o">&lt;</span><span class="nb">String</span><span class="o">&gt;</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="n">arg_city</span>: <span class="nb">String</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div>


<p>All we did is make the <code>data-path</code> argument optional in the Docopt usage
string, and make the corresponding struct member <code>arg_data_path</code> optional. The
<code>docopt</code> crate will handle the rest.</p>
<p>Modifying <code>search</code> is slightly trickier. The <code>csv</code> crate can build a parser out
of
<a href="https://burntsushi.net/rustdoc/csv/struct.Reader.html#method.from_reader">any type that implements
<code>io::Read</code></a>.
But how can we use the same code over both types? There's actually a couple
ways we could go about this. One way is to write <code>search</code> such that it is
generic on some type parameter <code>R</code> that satisfies <code>io::Read</code>. Another way is to
just use trait objects:</p>



  
  

  
  
  
  

<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">search</span><span class="o">&lt;</span><span class="n">P</span>: <span class="nb">AsRef</span><span class="o">&lt;</span><span class="n">Path</span><span class="o">&gt;</span><span class="o">&gt;</span><span class="w">
</span><span class="w"></span><span class="w">         </span><span class="p">(</span><span class="n">file_path</span>: <span class="kp">&amp;</span><span class="nb">Option</span><span class="o">&lt;</span><span class="n">P</span><span class="o">&gt;</span><span class="p">,</span><span class="w"> </span><span class="n">city</span>: <span class="kp">&amp;</span><span class="kt">str</span><span class="p">)</span><span class="w">
</span><span class="w"></span><span class="w">         </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="n">PopulationCount</span><span class="o">&gt;</span><span class="p">,</span><span class="w"> </span><span class="nb">Box</span><span class="o">&lt;</span><span class="n">Error</span><span class="o">+</span><span class="nb">Send</span><span class="o">+</span><span class="nb">Sync</span><span class="o">&gt;</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">found</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vec</span><span class="o">!</span><span class="p">[</span><span class="p">]</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">input</span>: <span class="nb">Box</span><span class="o">&lt;</span><span class="n">io</span>::<span class="n">Read</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">match</span><span class="w"> </span><span class="o">*</span><span class="n">file_path</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="nb">None</span><span class="w"> </span><span class="o">=</span><span class="o">&gt;</span><span class="w"> </span><span class="nb">Box</span>::<span class="n">new</span><span class="p">(</span><span class="n">io</span>::<span class="n">stdin</span><span class="p">(</span><span class="p">)</span><span class="p">)</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="nb">Some</span><span class="p">(</span><span class="k">ref</span><span class="w"> </span><span class="n">file_path</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="o">&gt;</span><span class="w"> </span><span class="nb">Box</span>::<span class="n">new</span><span class="p">(</span><span class="n">fs</span>::<span class="n">File</span>::<span class="n">open</span><span class="p">(</span><span class="n">file_path</span><span class="p">)</span><span class="o">?</span><span class="p">)</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="p">}</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">rdr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">csv</span>::<span class="n">Reader</span>::<span class="n">from_reader</span><span class="p">(</span><span class="n">input</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="c1">// The rest remains unchanged!
</span><span class="c1"></span><span class="p">}</span><span class="w">
</span></code></pre></div>


<h3 id="error-handling-with-a-custom-type">Error handling with a custom type</h3>
<p>Previously, we learned how to
<a href="rust-error-handling.html#composing-custom-error-types">compose errors using a custom error type</a>.
We did this by defining our error type as an <code>enum</code> and implementing <code>Error</code>
and <code>From</code>.</p>
<p>Since we have three distinct errors (IO, CSV parsing and not found), let's
define an <code>enum</code> with three variants:</p>



  
  

  
  
  
  

<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">enum</span> <span class="nc">CliError</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="n">Io</span><span class="p">(</span><span class="n">io</span>::<span class="n">Error</span><span class="p">)</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="n">Csv</span><span class="p">(</span><span class="n">csv</span>::<span class="n">Error</span><span class="p">)</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="n">NotFound</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div>


<p>And now for impls on <code>Display</code> and <code>Error</code>:</p>



  
  

  
  
  
  

<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">impl</span><span class="w"> </span><span class="n">fmt</span>::<span class="n">Display</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">CliError</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="k">fn</span> <span class="nf">fmt</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">f</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">fmt</span>::<span class="n">Formatter</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">fmt</span>::<span class="nb">Result</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="k">match</span><span class="w"> </span><span class="o">*</span><span class="bp">self</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">            </span><span class="n">CliError</span>::<span class="n">Io</span><span class="p">(</span><span class="k">ref</span><span class="w"> </span><span class="n">err</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="o">&gt;</span><span class="w"> </span><span class="n">err</span><span class="p">.</span><span class="n">fmt</span><span class="p">(</span><span class="n">f</span><span class="p">)</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">            </span><span class="n">CliError</span>::<span class="n">Csv</span><span class="p">(</span><span class="k">ref</span><span class="w"> </span><span class="n">err</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="o">&gt;</span><span class="w"> </span><span class="n">err</span><span class="p">.</span><span class="n">fmt</span><span class="p">(</span><span class="n">f</span><span class="p">)</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">            </span><span class="n">CliError</span>::<span class="n">NotFound</span><span class="w"> </span><span class="o">=</span><span class="o">&gt;</span><span class="w"> </span><span class="n">write</span><span class="o">!</span><span class="p">(</span><span class="n">f</span><span class="p">,</span><span class="w"> </span><span class="err">&#34;</span><span class="n">No</span><span class="w"> </span><span class="n">matching</span><span class="w"> </span><span class="n">cities</span><span class="w"> </span><span class="n">with</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="err">\</span><span class="w">
</span><span class="w"></span><span class="w">                                             </span><span class="n">population</span><span class="w"> </span><span class="n">were</span><span class="w"> </span><span class="n">found</span><span class="p">.</span><span class="err">&#34;</span><span class="p">)</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">Error</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">CliError</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="k">fn</span> <span class="nf">description</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="kt">str</span> <span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="k">match</span><span class="w"> </span><span class="o">*</span><span class="bp">self</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">            </span><span class="n">CliError</span>::<span class="n">Io</span><span class="p">(</span><span class="k">ref</span><span class="w"> </span><span class="n">err</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="o">&gt;</span><span class="w"> </span><span class="n">err</span><span class="p">.</span><span class="n">description</span><span class="p">(</span><span class="p">)</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">            </span><span class="n">CliError</span>::<span class="n">Csv</span><span class="p">(</span><span class="k">ref</span><span class="w"> </span><span class="n">err</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="o">&gt;</span><span class="w"> </span><span class="n">err</span><span class="p">.</span><span class="n">description</span><span class="p">(</span><span class="p">)</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">            </span><span class="n">CliError</span>::<span class="n">NotFound</span><span class="w"> </span><span class="o">=</span><span class="o">&gt;</span><span class="w"> </span><span class="s">&#34;not found&#34;</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div>


<p>Before we can use our <code>CliError</code> type in our <code>search</code> function, we need to
provide a couple <code>From</code> impls. How do we know which impls to provide? Well,
we'll need to convert from both <code>io::Error</code> and <code>csv::Error</code> to <code>CliError</code>.
Those are the only external errors, so we'll only need two <code>From</code> impls for
now:</p>



  
  

  
  
  
  

<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">impl</span><span class="w"> </span><span class="nb">From</span><span class="o">&lt;</span><span class="n">io</span>::<span class="n">Error</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">CliError</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="k">fn</span> <span class="nf">from</span><span class="p">(</span><span class="n">err</span>: <span class="nc">io</span>::<span class="n">Error</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">CliError</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="n">CliError</span>::<span class="n">Io</span><span class="p">(</span><span class="n">err</span><span class="p">)</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="nb">From</span><span class="o">&lt;</span><span class="n">csv</span>::<span class="n">Error</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">CliError</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="k">fn</span> <span class="nf">from</span><span class="p">(</span><span class="n">err</span>: <span class="nc">csv</span>::<span class="n">Error</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">CliError</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="n">CliError</span>::<span class="n">Csv</span><span class="p">(</span><span class="n">err</span><span class="p">)</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div>


<p>The <code>From</code> impls are important because of how the
<a href="rust-error-handling.html#code-questionmark-def"><code>?</code> operator is defined</a>. In particular, if an error
occurs, <code>From::from</code> is called on the error, which in this case, will convert
it to our own error type <code>CliError</code>.</p>
<p>With the <code>From</code> impls done, we only need to make two small tweaks to our
<code>search</code> function: the return type and the &ldquo;not found&rdquo; error. Here it is in
full:</p>



  
  

  
  
  
  

<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">search</span><span class="o">&lt;</span><span class="n">P</span>: <span class="nb">AsRef</span><span class="o">&lt;</span><span class="n">Path</span><span class="o">&gt;</span><span class="o">&gt;</span><span class="w">
</span><span class="w"></span><span class="w">         </span><span class="p">(</span><span class="n">file_path</span>: <span class="kp">&amp;</span><span class="nb">Option</span><span class="o">&lt;</span><span class="n">P</span><span class="o">&gt;</span><span class="p">,</span><span class="w"> </span><span class="n">city</span>: <span class="kp">&amp;</span><span class="kt">str</span><span class="p">)</span><span class="w">
</span><span class="w"></span><span class="w">         </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="n">PopulationCount</span><span class="o">&gt;</span><span class="p">,</span><span class="w"> </span><span class="n">CliError</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">found</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vec</span><span class="o">!</span><span class="p">[</span><span class="p">]</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">input</span>: <span class="nb">Box</span><span class="o">&lt;</span><span class="n">io</span>::<span class="n">Read</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">match</span><span class="w"> </span><span class="o">*</span><span class="n">file_path</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="nb">None</span><span class="w"> </span><span class="o">=</span><span class="o">&gt;</span><span class="w"> </span><span class="nb">Box</span>::<span class="n">new</span><span class="p">(</span><span class="n">io</span>::<span class="n">stdin</span><span class="p">(</span><span class="p">)</span><span class="p">)</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="nb">Some</span><span class="p">(</span><span class="k">ref</span><span class="w"> </span><span class="n">file_path</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="o">&gt;</span><span class="w"> </span><span class="nb">Box</span>::<span class="n">new</span><span class="p">(</span><span class="n">fs</span>::<span class="n">File</span>::<span class="n">open</span><span class="p">(</span><span class="n">file_path</span><span class="p">)</span><span class="o">?</span><span class="p">)</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="p">}</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">rdr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">csv</span>::<span class="n">Reader</span>::<span class="n">from_reader</span><span class="p">(</span><span class="n">input</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="n">row</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">rdr</span><span class="p">.</span><span class="n">decode</span>::<span class="o">&lt;</span><span class="n">Row</span><span class="o">&gt;</span><span class="p">(</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">row</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">row</span><span class="o">?</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="k">match</span><span class="w"> </span><span class="n">row</span><span class="p">.</span><span class="n">population</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">            </span><span class="nb">None</span><span class="w"> </span><span class="o">=</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="c1">// skip it
</span><span class="c1"></span><span class="w">            </span><span class="nb">Some</span><span class="p">(</span><span class="n">count</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="o">&gt;</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">row</span><span class="p">.</span><span class="n">city</span><span class="w"> </span><span class="o">=</span><span class="o">=</span><span class="w"> </span><span class="n">city</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">                </span><span class="n">found</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">PopulationCount</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">                    </span><span class="n">city</span>: <span class="nc">row</span><span class="p">.</span><span class="n">city</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">                    </span><span class="n">country</span>: <span class="nc">row</span><span class="p">.</span><span class="n">country</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">                    </span><span class="n">count</span>: <span class="nc">count</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">                </span><span class="p">}</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">            </span><span class="p">}</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="n">found</span><span class="p">.</span><span class="n">is_empty</span><span class="p">(</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="nb">Err</span><span class="p">(</span><span class="n">CliError</span>::<span class="n">NotFound</span><span class="p">)</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="nb">Ok</span><span class="p">(</span><span class="n">found</span><span class="p">)</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div>


<p>No other changes are necessary.</p>
<h3 id="adding-functionality">Adding functionality</h3>
<p>If you're anything like me, writing generic code feels good because
generalizing stuff is cool! But sometimes, the juice isn't worth the squeeze.
Look at what we just did in the previous step:</p>
<ol>
<li>Defined a new error type.</li>
<li>Added impls for <code>Error</code>, <code>Display</code> and two for <code>From</code>.</li>
</ol>
<p>The big downside here is that our program didn't improve a whole lot. I'm
personally fond of it because I like using <code>enum</code>s for representing errors, but
there is quite a bit of overhead to doing so, especially in short programs like
this.</p>
<p><em>One</em> useful aspect of using a custom error type like we've done here is that
the <code>main</code> function can now choose to handle errors differently. Previously,
with <code>Box&lt;Error&gt;</code>, it didn't have much of a choice: just print the message.
We're still doing that here, but what if we wanted to, say, add a <code>--quiet</code>
flag? The <code>--quiet</code> flag should silence any verbose output.</p>
<p>Right now, if the program doesn't find a match, it will output a message saying
so. This can be a little clumsy, especially if you intend for the program to
be used in shell scripts.</p>
<p>So let's start by adding the flags. Like before, we need to tweak the usage
string and add a flag to the <code>Args</code> struct. The <code>docopt</code> crate does the rest:</p>



  
  

  
  
  
  

<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">static</span><span class="w"> </span><span class="n">USAGE</span>: <span class="kp">&amp;</span><span class="nb">&#39;static</span><span class="w"> </span><span class="kt">str</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="err">&#34;</span><span class="w">
</span><span class="w"></span><span class="n">Usage</span>: <span class="nc">city</span><span class="o">-</span><span class="n">pop</span><span class="w"> </span><span class="p">[</span><span class="n">options</span><span class="p">]</span><span class="w"> </span><span class="p">[</span><span class="o">&lt;</span><span class="n">data</span><span class="o">-</span><span class="n">path</span><span class="o">&gt;</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;</span><span class="n">city</span><span class="o">&gt;</span><span class="w">
</span><span class="w"></span><span class="w">       </span><span class="n">city</span><span class="o">-</span><span class="n">pop</span><span class="w"> </span><span class="o">-</span><span class="o">-</span><span class="n">help</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="n">Options</span>:
    <span class="o">-</span><span class="n">h</span><span class="p">,</span><span class="w"> </span><span class="o">-</span><span class="o">-</span><span class="n">help</span><span class="w">     </span><span class="n">Show</span><span class="w"> </span><span class="n">this</span><span class="w"> </span><span class="n">usage</span><span class="w"> </span><span class="n">message</span><span class="p">.</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="o">-</span><span class="n">q</span><span class="p">,</span><span class="w"> </span><span class="o">-</span><span class="o">-</span><span class="n">quiet</span><span class="w">    </span><span class="n">Don</span><span class="na">&#39;t</span><span class="w"> </span><span class="n">show</span><span class="w"> </span><span class="n">noisy</span><span class="w"> </span><span class="n">messages</span><span class="p">.</span><span class="w">
</span><span class="w"></span><span class="err">&#34;</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">Args</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="n">arg_data_path</span>: <span class="nb">Option</span><span class="o">&lt;</span><span class="nb">String</span><span class="o">&gt;</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="n">arg_city</span>: <span class="nb">String</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="n">flag_quiet</span>: <span class="kt">bool</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div>


<p>Now we just need to implement our &ldquo;quiet&rdquo; functionality. This requires us to
tweak the case analysis in <code>main</code>:</p>



  
  

  
  
  
  

<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">match</span><span class="w"> </span><span class="n">search</span><span class="p">(</span><span class="o">&amp;</span><span class="n">args</span><span class="p">.</span><span class="n">arg_data_path</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">args</span><span class="p">.</span><span class="n">arg_city</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="nb">Err</span><span class="p">(</span><span class="n">CliError</span>::<span class="n">NotFound</span><span class="p">)</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">args</span><span class="p">.</span><span class="n">flag_quiet</span><span class="w"> </span><span class="o">=</span><span class="o">&gt;</span><span class="w"> </span><span class="n">process</span>::<span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="nb">Err</span><span class="p">(</span><span class="n">err</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="o">&gt;</span><span class="w"> </span><span class="n">fatal</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;{}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">err</span><span class="p">)</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="nb">Ok</span><span class="p">(</span><span class="n">pops</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">pop</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">pops</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;{}, {}: {:?}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">pop</span><span class="p">.</span><span class="n">city</span><span class="p">,</span><span class="w"> </span><span class="n">pop</span><span class="p">.</span><span class="n">country</span><span class="p">,</span><span class="w"> </span><span class="n">pop</span><span class="p">.</span><span class="n">count</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div>


<p>Certainly, we don't want to be quiet if there was an IO error or if the data
failed to parse. Therefore, we use case analysis to check if the error type is
<code>NotFound</code> <em>and</em> if <code>--quiet</code> has been enabled. If the search failed, we still
quit with an exit code (following <code>grep</code>'s convention).</p>
<p>If we had stuck with <code>Box&lt;Error&gt;</code>, then it would be pretty tricky to implement
the <code>--quiet</code> functionality.</p>
<p>This pretty much sums up our case study. From here, you should be ready to go
out into the world and write your own programs and libraries with proper error
handling.</p>
<h2 id="the-short-story">The short story</h2>
<p>Since this article is long, it is useful to have a quick summary for error
handling in Rust. These are my &ldquo;rules of thumb.&rdquo; They are emphatically <em>not</em>
commandments. There are probably good reasons to break every one of these
heuristics!</p>
<ul>
<li>If you're writing short example code that would be overburdened by error
handling, it's probably just fine to use <code>unwrap</code> (whether that's
<a href="http://doc.rust-lang.org/std/result/enum.Result.html#method.unwrap"><code>Result::unwrap</code></a>,
<a href="http://doc.rust-lang.org/std/option/enum.Option.html#method.unwrap"><code>Option::unwrap</code></a>
or preferably
<a href="http://doc.rust-lang.org/std/option/enum.Option.html#method.expect"><code>Option::expect</code></a>).
Consumers of your code should know to use proper error handling. (If they
don't, send them here!)</li>
<li>If you're writing a quick &lsquo;n&rsquo; dirty program, don't feel ashamed if you use
<code>unwrap</code>. Be warned: if it winds up in someone else's hands, don't be
surprised if they are agitated by poor error messages!</li>
<li>If you're writing a quick &lsquo;n&rsquo; dirty program and feel ashamed about panicking
anyway, then you should probably use <code>Box&lt;Error&gt;</code>
(or <code>Box&lt;Error + Send + Sync&gt;</code>) as shown in examples above. Another promising
alternative is the <a href="https://crates.io/crates/anyhow"><code>anyhow</code></a> crate and its
<code>anyhow::Error</code> type. When using <code>anyhow</code>, your errors will automatically
have backtraces attached to them when using nightly Rust.</li>
<li>Otherwise, in a program, define your own error types with appropriate
<a href="http://doc.rust-lang.org/std/convert/trait.From.html"><code>From</code></a>
and
<a href="http://doc.rust-lang.org/std/error/trait.Error.html"><code>Error</code></a>
impls to make the <code>?</code> operator macro more ergnomic.</li>
<li>If you're writing a library and your code can produce errors, define your own
error type and implement the
<a href="http://doc.rust-lang.org/std/error/trait.Error.html"><code>std::error::Error</code></a>
trait. Where appropriate, implement
<a href="http://doc.rust-lang.org/std/convert/trait.From.html"><code>From</code></a> to make both
your library code and the caller's code easier to write. (Because of Rust's
coherence rules, callers will not be able to impl <code>From</code> on your error type,
so your library should do it.)</li>
<li>Learn the combinators defined on
<a href="http://doc.rust-lang.org/std/option/enum.Option.html"><code>Option</code></a>
and
<a href="http://doc.rust-lang.org/std/result/enum.Result.html"><code>Result</code></a>.
Using them exclusively can be a bit tiring at times, but I've personally
found a healthy mix of the <code>?</code> operator and combinators to be quite
appealing. <code>and_then</code>, <code>map</code> and <code>unwrap_or</code> are my favorites.</li>
</ul>
      </article>

      

    </div>
  </div>
</div>
    <footer class="footer">
      <div class="p2 wrap">
        <div class="measure mt1 center">
      <nav class="social-icons icons">
<a class="fa fa-rss rss" href="index.xml"></a>

</nav>

          <small>
            All content is dual licensed under the UNLICENSE and MIT licenses.<br>
            Powered by <a href="http://gohugo.io/" target="_blank">Hugo</a> &amp; <a href="https://github.com/azmelanar/hugo-theme-pixyll" target="_blank">Pixyll</a>
          </small>
        </div>
      </div>
    </footer>
</body>
</html>

