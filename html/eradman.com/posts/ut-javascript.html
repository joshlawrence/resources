<!DOCTYPE html>
<html>
  <head>
    <title>
      Testing JavaScript with HTML Fixtures
    </title>
    <meta content='text/html; charset=US-ASCII' http-equiv='Content-Type'>
    <link href='../main.css' rel='stylesheet' type='text/css'>
    <link href='../code.css' rel='stylesheet' type='text/css'>
  </head>
  <body>
    <h3 style='margin-left: 5px; margin-top: 20px;'>
      <a href='../index.html' id='myname'>Eric Radman</a>
      <span id='mytitle'>: a Journal</span>
    </h3>
    <div id='article'>
      <h1>Testing JavaScript with HTML Fixtures</h1>
      <h2>
        Refresh-Button Testing
      </h2>
      <p>
        To meaningfully test JavaScript that is part of a web application one needs
        to interact with the browser's DOM. Most large and small JS test frameworks
        approach this problem by creating and document and then adding the tests to the
        document:
      </p>
      <pre>&#x000A;<span class="Comment">&lt;!doctype html&gt;</span>&#x000A;<span class="htmlTag">&lt;</span><span class="htmlTagName">html</span><span class="htmlTag">&gt;</span>&#x000A;  <span class="htmlTag">&lt;</span><span class="htmlTagName">head</span><span class="htmlTag">&gt;&lt;</span><span class="htmlTagName">meta</span><span class="htmlTag"> </span><span class="htmlArg">charset</span><span class="htmlTag">=</span><span class="Constant">&quot;utf-8&quot;</span><span class="htmlTag">&gt;</span><span class="htmlEndTag">&lt;/</span><span class="htmlTagName">head</span><span class="htmlEndTag">&gt;</span>&#x000A;  <span class="htmlTag">&lt;</span><span class="htmlTagName">body</span><span class="htmlTag">&gt;</span>&#x000A;  <span class="Comment">&lt;!</span><span class="Comment">-- insert HTML and SVG here --</span><span class="Comment">&gt;</span>&#x000A;  <span class="htmlEndTag">&lt;/</span><span class="htmlTagName">body</span><span class="htmlEndTag">&gt;</span>&#x000A;  <span class="htmlTag">&lt;</span><span class="htmlSpecialTagName">script</span><span class="htmlTag"> </span><span class="htmlArg">src</span><span class="htmlTag">=</span><span class="Constant">&quot;testrunner.js&quot;</span><span class="htmlTag">&gt;</span><span class="htmlEndTag">&lt;/</span><span class="htmlSpecialTagName">script</span><span class="htmlEndTag">&gt;</span>&#x000A;  <span class="htmlTag">&lt;</span><span class="htmlSpecialTagName">script</span><span class="htmlTag"> </span><span class="htmlArg">src</span><span class="htmlTag">=</span><span class="Constant">&quot;mycode.js&quot;</span><span class="htmlTag">&gt;</span><span class="htmlEndTag">&lt;/</span><span class="htmlSpecialTagName">script</span><span class="htmlEndTag">&gt;</span>&#x000A;<span class="htmlEndTag">&lt;/</span><span class="htmlTagName">html</span><span class="htmlEndTag">&gt;</span>&#x000A;<span class="htmlEndTag">&lt;/</span><span class="htmlTagName">code</span><span class="htmlEndTag">&gt;</span>&#x000A;</pre>
      <p>
        The obvious problem is that this cannot be easily included in automated tests
        since a manual browser load and refresh is required.
      </p>
      <p>
        The second difficulty is that each individual tests require careful setup and
        teardown if they modify the document they're embedded in. If you are testing
        client code for a web application it almost certainly does modify the DOM state,
        which results in interacting unit tests.
      </p>
      <h2>
        Fresh Fixtures in Node.js
      </h2>
      <p>
        For the command line, <em>node</em> is an obvious place to start because it
        has good exception handling (if you can put up with the long backtraces) and a
        rich library. Now instead of writing a document with embedded tests we can start
        writing tests that interact with data (the document):
      </p>
      <pre>&#x000A;<span class="Identifier">var</span> assert = require(<span class="Constant">'assert'</span>);&#x000A;</pre>
      <p>
        The downside to starting with Node is that there is no HTML, CSS or SVG. No
        DOM.  To solve this problem we can use
        <a href='https://github.com/tmpvar/jsdom'>jsdom,</a>
        a library with nearly 90 dependencies. Once installed we can construct a
        document:
      </p>
      <pre>&#x000A;<span class="Identifier">var</span> jsdom = require(<span class="Constant">&quot;jsdom&quot;</span>).jsdom;&#x000A;</pre>
      <p>
        Immedately we are faced with the sad fact that JavaScript does no have the
        concept of a `heredoc`. This can be emulated in heroic ways by calling the
        `.toString()` method on a function containing a large comment.
      </p>
      <pre>&#x000A;<span class="Identifier">function</span> hereDoc(f) <span class="Identifier">{</span>&#x000A;  <span class="Statement">return</span> f.toString().&#x000A;      replace(<span class="Constant">/^[^\/]+\/\*!?/</span>, <span class="Constant">''</span>).&#x000A;      replace(<span class="Constant">/\*\/[^\/]+$/</span>, <span class="Constant">''</span>);&#x000A;<span class="Identifier">}</span>&#x000A;<span class="Identifier">var</span> html = hereDoc(<span class="Identifier">function</span>() <span class="Identifier">{</span><span class="Comment">/*!</span>&#x000A;<span class="Comment">&lt;!doctype html&gt;</span>&#x000A;<span class="Comment">&lt;html&gt;</span>&#x000A;<span class="Comment">...</span>&#x000A;<span class="Comment">&lt;/html&gt;</span>&#x000A;<span class="Comment">*/</span><span class="Identifier">}</span>);</pre>
      <p>
        Alternatively we could load the string from a file. Now we'll include the
        library we want to test:
      </p>
      <pre>&#x000A;<span class="Identifier">var</span> app = require(<span class="Constant">'../public/ui.js'</span>);&#x000A;</pre>
      <p>
        We still have to choose a test runner. The following example uses Mocha. The
        important part is that we get a new jsdom object instantiated before each
        test, so careful setup or teardown is not required:
      </p>
      <pre>&#x000A;describe(<span class="Constant">&quot;app&quot;</span>, <span class="Identifier">function</span>() <span class="Identifier">{</span>&#x000A;    <span class="Identifier">var</span> <span class="Statement">window</span> = <span class="Statement">null</span>;&#x000A;&#x000A;    beforeEach(<span class="Identifier">function</span>()<span class="Identifier">{</span>&#x000A;        <span class="Statement">window</span> = jsdom(html).defaultView;&#x000A;    <span class="Identifier">}</span>);&#x000A;&#x000A;    describe(<span class="Constant">&quot;test 1&quot;</span>, <span class="Identifier">function</span>() <span class="Identifier">{</span>&#x000A;        it(<span class="Constant">&quot;contains an embeded product ID&quot;</span>, <span class="Identifier">function</span> () <span class="Identifier">{</span>&#x000A;            content_div = <span class="Statement">window</span>.<span class="Statement">document</span>.getElementById(<span class="Constant">'content'</span>)<span class="Identifier">[</span>0<span class="Identifier">]</span>;&#x000A;            assert.equal(chart_div.innerHTML, <span class="Constant">&quot;...&quot;</span>);&#x000A;        <span class="Identifier">}</span>);&#x000A;    <span class="Identifier">}</span>);&#x000A;<span class="Identifier">}</span>);&#x000A;</pre>
      <h2>
        Native Browser Tests with phantom-assert
      </h2>
      <p>
        At the time of this writing <em>jsdom</em> no longer supports <a
        href="http://nodejs.org/">node.js</a>, and requires <a
        href="https://iojs.org/">io.js</a> instead. If this is or a lengthy chain of NPM
        modules is not an option in your environment then it is possible to write
        automated tests using a test runner for <a
        href="http://phantomjs.org/">phantomjs</a>. The project I crated to prove this
        concept is <a
        href="https://bitbucket.org/eradman/phantom-assert">phantom-assert</a>, and
        works by injecting each test function into the page and resetting the page
        content inbetween each test. A simple example looks like this:
      </p>
      <pre>&#x000A;<span class="Identifier">var</span> html = <span class="Constant">&quot;fixture.html&quot;</span>;&#x000A;<span class="Identifier">var</span> tests = <span class="Identifier">[]</span>;&#x000A;&#x000A;tests.push(<span class="Identifier">function</span> count_chart_elements () <span class="Identifier">{</span>&#x000A;    assert(<span class="Statement">document</span>.getElementsByClassName(<span class="Constant">'chart'</span>).length, 1);&#x000A;<span class="Identifier">}</span>)&#x000A;</pre>
      <p>
        Using this model is impossible to create interacting tests because the page
        content is refreshed after each test.%em
        phantom-assert</em> is not a
        micro-framework, it is a polished example who's source code can be read in less
        than 5 minutes. This level of minimalism eliminates the need for configuration
        because the framework itself can be easily modified and embedded directly into
        your project.
      </p>
      <h2>
        Other Test Frameworks
      </h2>
      <p>
        If you are interested in a more complete test harness, <a
        href="https://bitbucket.org/zserge/klud.js">klud.js</a> is a micro-framework
        that may fit your needs.
      </p>
      <p>
        For functional testing or any testing on PhantomJS, <a
        href="http://casperjs.org/">CasperJS</a> is full-featured and well
        supported.
      </p>
    </div>
    <p class='timestamp'>
      Last updated on November 26, 2016
    </p>
  </body>
</html>
