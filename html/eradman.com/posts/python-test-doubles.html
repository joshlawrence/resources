<!DOCTYPE html>
<html>
  <head>
    <title>
      Using Test Doubles in Python
    </title>
    <meta content='text/html; charset=US-ASCII' http-equiv='Content-Type'>
    <link href='../main.css' rel='stylesheet' type='text/css'>
    <link href='../code.css' rel='stylesheet' type='text/css'>
  </head>
  <body>
    <h3 style='margin-left: 5px; margin-top: 20px;'>
      <a href='../index.html' id='myname'>Eric Radman</a>
      <span id='mytitle'>: a Journal</span>
    </h3>
    <div id='article'>
      <h1>Using Test Doubles in Python</h1>
      <p>
        When I first start doing test-first programming I immediately started looking
        for libraries that would help me create test doubles. One such library I've used
        is <a href="http://pypi.python.org/pypi/fudge/1.0.2">fudge</a>. Another approach
        is to build a fake class that knows how to keep state for the specific object
        that you'd like to replace.
      </p>
      <h2>A New Object</h2>
      <p>
        I rarely create a test double by subclassing the real thing. If we create a
        new class that implements only the method calls we use, the implementation can
        be kept simple and invocations of methods that we don't expect use will raise
        an exception. The following example can be used in place of
        <em>smtplib.SMTP</em>
      </p>
      <pre>&#x000A;<span class="PreProc">import</span> smtplib&#x000A;&#x000A;<span class="Statement">class</span> <span class="Identifier">fake_SMTP</span>:&#x000A;    calls = []&#x000A;&#x000A;    <span class="Statement">def</span> <span class="Identifier">__init__</span>(self, _server):&#x000A;        self.calls.append(<span class="Constant">&quot;</span><span class="Constant">__init__('%s')</span><span class="Constant">&quot;</span> % _server)&#x000A;&#x000A;    <span class="Statement">def</span> <span class="Identifier">sendmail</span>(self, _from, _to, _msg):&#x000A;        self.calls.append(<span class="Constant">&quot;</span><span class="Constant">sendmail('%s', %s, &lt;msg&gt;</span><span class="Constant">&quot;</span> % (_from, _to))&#x000A;&#x000A;    <span class="Statement">def</span> <span class="Identifier">quit</span>(self):&#x000A;        self.calls.append(<span class="Constant">&quot;</span><span class="Constant">quit()</span><span class="Constant">&quot;</span>)&#x000A;</pre>
      <p>
        Now replace the class we're going to test in <em>smtplib</em>
      </p>
      <pre>&#x000A;<span class="Identifier">setattr</span>(smtplib, <span class="Constant">'</span><span class="Constant">SMTP</span><span class="Constant">'</span>, fake_SMTP)&#x000A;</pre>
      <p>
        <em>fake_SMTP</em> is instantiated and called in the same way as the real
      </p>
      <em>
        SMTP</em> and it simply uses a list to record the signature of each method
        call, allowing me to test concretely and precisely.
      </em>
      <pre>&#x000A;<span class="Comment"># system-under-test: alert.py</span>&#x000A;<span class="PreProc">import</span> alert&#x000A;&#x000A;<span class="Statement">def</span> <span class="Identifier">test_send_message</span>():&#x000A;    message = <span class="Constant">&quot;</span><span class="Constant">hi</span><span class="Constant">&quot;</span>&#x000A;    alert.send_message([<span class="Constant">'</span><span class="Constant">eradman@eradman.com</span><span class="Constant">'</span>], message)&#x000A;    assert_equals(fake_SMTP.calls,&#x000A;        [<span class="Constant">&quot;</span><span class="Constant">__init__('localhost')</span><span class="Constant">&quot;</span>,&#x000A;        <span class="Constant">&quot;</span><span class="Constant">sendmail('user', ['eradman@eradman.com'], &lt;msg&gt;</span><span class="Constant">&quot;</span>,&#x000A;        <span class="Constant">&quot;</span><span class="Constant">quit()</span><span class="Constant">&quot;</span>])&#x000A;</pre>
      <p>
        This method is powerful; I'm free to specify the order in which method calls
        are recorded, and with what details. In this case I'm not interested in what
        the message body is, so I only record a token <em>&lt;msg&gt;</em>. It would be
        just as easy to record the frist two lines or to track the method calls with a
        dictionary instead of a list.
      </p>
      <h2>Built-In Classes</h2>
      <p>
        Unfortunately Python does not allow you to modify some of it's core
        modules written in C. One way around this is to use a method the simply
        calls the real thing.
      </p>
      <pre>&#x000A;<span class="PreProc">import</span> datetime&#x000A;&#x000A;<span class="Statement">def</span> <span class="Identifier">now</span>():&#x000A;    <span class="Statement">return</span> datetime.now()&#x000A;</pre>
      <p>
        This method can be mocked using <em>setattr()</em> provided the rest
        of the codebase uses this method.
      </p>
      <h2>Test Discovery and Invocation</h2>
      <p>
        Python's unittest package includes a discovery method, but it's rarely
        useful because every test file is loaded into the same process, making
        namespace pollution nearly impossible to avoid. Instead prefer using a simple
        shell script to discover and load tests.
      </p>
      <pre>&#x000A;<span class="Comment">#!/bin/ksh</span>&#x000A;<span class="Comment"># Find tests starting with ut_ and run them. Each module must invoke unittest</span>&#x000A;<span class="Comment"># on it's own using</span>&#x000A;<span class="Comment">#</span>&#x000A;<span class="Comment"># if __name__ == '__main__':</span>&#x000A;<span class="Comment">#     unittest.main()</span>&#x000A;<span class="Comment">#</span>&#x000A;&#x000A;<span class="Statement">case</span> <span class="Statement">&quot;</span><span class="PreProc">$1</span><span class="Statement">&quot;</span> <span class="Statement">in</span>&#x000A;    -h<span class="Statement">)</span> <span class="Statement">shift</span><span class="Statement">;</span> <span class="Statement">echo</span><span class="Constant"> </span><span class="Statement">&quot;</span><span class="Constant">usage: </span><span class="Special">`basename </span><span class="PreProc">$0</span><span class="Special">`</span><span class="Constant"> [search_pattern]</span><span class="Statement">&quot;</span>&#x000A;        <span class="Statement">exit</span><span class="Statement">;;</span>&#x000A;<span class="Statement">esac</span>&#x000A;&#x000A;<span class="Identifier">WD</span>=<span class="Special">`dirname </span><span class="PreProc">$0</span><span class="Special">`</span>&#x000A;<span class="Identifier">PATTERN</span>=<span class="PreProc">$1</span>&#x000A;&#x000A;<span class="Identifier">PYTHONPATH</span>=<span class="PreProc">$PYTHONPATH</span>:<span class="PreProc">$WD</span>&#x000A;<span class="Statement">find</span> tests/ <span class="Special">-name</span> <span class="Statement">&quot;</span><span class="PreProc">${</span><span class="PreProc">PATTERN</span><span class="Statement">:=</span>ut_*.py<span class="PreProc">}</span><span class="Statement">&quot;</span> | xargs <span class="Special">-P</span> <span class="Constant">2</span> <span class="Special">-n</span> <span class="Constant">1</span> python&#x000A;</pre>
      <p>
        Notice the use of <em>xargs</em> gave us a concurrent test runner at the
        cost of the additional RAM required for multiple intances of the Python
        interpreter. Experiment with the <em>-P</em> option to find out what's
        optimal.
      </p>
      <h2>
        Developer Friendly Test Fixutres in Python
      </h2>
      <p>
        Starting with 2.7, Python's <em>unittest</em> includes a very nice way to
        compare dictionaries. Instead of printing the two unequal values,
      </p>
      <em>
        assertDictEqual</em> print a human-readable diff</p>
      </em>
      <pre>&#x000A;<span class="PreProc">import</span> unittest&#x000A;&#x000A;a = {<span class="Constant">'</span><span class="Constant">key1</span><span class="Constant">'</span>: <span class="Constant">5</span>, <span class="Constant">'</span><span class="Constant">key2</span><span class="Constant">'</span>: <span class="Constant">7</span>}&#x000A;b = {<span class="Constant">'</span><span class="Constant">key1</span><span class="Constant">'</span>: <span class="Constant">6</span>, <span class="Constant">'</span><span class="Constant">key2</span><span class="Constant">'</span>: <span class="Constant">7</span>, <span class="Constant">'</span><span class="Constant">key3</span><span class="Constant">'</span>: <span class="Constant">9</span>}&#x000A;&#x000A;<span class="Statement">class</span> <span class="Identifier">Test1</span>(unittest.TestCase):&#x000A;    <span class="Statement">def</span> <span class="Identifier">test_1</span>(self):&#x000A;        self.assertDictEqual(a, b)&#x000A;&#x000A;unittest.main()&#x000A;</pre>
      <p>
        This makes comparing otherwise complex structures easy. This capability
        saves time, but more importantly it encourages concrete testing rather than
        sampling.
      </p>
      <pre>&#x000A;AssertionError: {'key2': 7, 'key1': 5} != {'key3': 9, 'key2': 7, 'key1': 6}&#x000A;- {'key1': 5, 'key2': 7}&#x000A;?          ^&#x000A;&#x000A;+ {'key1': 6, 'key2': 7, 'key3': 9}&#x000A;?          ^           +++++++++++&#x000A;</pre>
      <p>
        Comparing Blocks of Text
      </p>
      <p>
        Sometimes subclassing <em>unittest.TestCase</em> is sensible, but if you
        inherit from more than one derived class this can become messy.  In Python it
        may be better to create a new object to mix in that will use <em>difflib</em>
        to raise an exception with a messaged formatted as a unified diff
      </p>
      <pre>&#x000A;<span class="Statement">class</span> <span class="Identifier">CustomCompare</span>(<span class="Identifier">object</span>):&#x000A;    <span class="Statement">def</span> <span class="Identifier">assertTextEqual</span>(self, s1, s2):&#x000A;        diff = <span class="Identifier">list</span>(difflib.unified_diff(s1.splitlines(), s2.splitlines()))&#x000A;        <span class="Statement">if</span> diff != []:&#x000A;            <span class="Statement">raise</span> <span class="Type">AssertionError</span>(<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">&quot;</span>.join(diff))&#x000A;</pre>
      <p>
        Now add this to your test case
      </p>
      <pre>&#x000A;<span class="Statement">class</span> <span class="Identifier">Test1</span>(unittest.TestCase, Comparison):&#x000A;    <span class="Statement">def</span> <span class="Identifier">test_1</span>(self):&#x000A;        self.assertTextEqual(a, b)&#x000A;</pre>
      <p>
        The result look like this:
      </p>
      <pre>&#x000A;AssertionError:&#x000A;&#x000A;@@ -1,4 +1,4 @@&#x000A;&#x000A; one&#x000A;-two&#x000A;+Two&#x000A; three</pre>
    </div>
    <p class='timestamp'>
      Last updated on November 26, 2016
    </p>
  </body>
</html>
