%h1 Refactoring Legacy Systems

%h2 Write-Ahead Logging

%p
  Instead of keeping a recording what did happen, keep a list of improvements
  that will be made, and them execute them. The obvious benefit is that you and
  your team can maintain focus. It may be less obvious that the checklist
  communicates architectural values and thereby limits the type of changes that
  might be made.

%p
  If you're fortunate enough to be using <a
  href="http://mercurial-scm.org">Mercurial</a> or <a
  href="http://git-scm.org">Git</a> each feature can be easily managed as an
  atomic unit of work by switching to a new <a
  href="http://learn.github.com/p/branching.html">branch</a> for each
  intermediate step.

%h2 Write Regression Tests

%p
  Retrofitting an existing code base with unit tests is not always feasible,
  since the practice of unit testing is itself typically the motive for writing
  code that is more functional in nature. In this case some good functional
  tests are critical.

:codeblock
  tests/recover-checkpoint/01_setup.py
  tests/recover-checkpoint/02_run.py
  tests/recover-checkpoint/03_continue.py
  tests/recover-checkpoint/04_verify.py

%h2 Perform Rolling Upgrades

%p
  The goal of a refactoring sprint is to reach a consistent state again as
  quickly as possible. As soon as a coherent set of changes appears to be
  stable, initiate a series of upgrades that will incrementally prove the
  stability of the new code. Partitioning the deployment of configuration or
  packages also allows a team to make more aggressive changes and to start the
  next iteration faster.  This scheme also presents an excellent context for
  implementing run-time health checks.

%h2 Fix Easy Tests First

%p
  After major surgery it's tempting to try to solve the failures of the most
  complex tests, but this is a little like trying to chop a large by aiming
  strait for the center. Instead look for cracks leading around the edge and
  start to solve the little problems first.

%h2 Treat Exceptions as Fatal

%p
  The most efficient way to create tangled code is to use exceptions as a
  general-purpose signaling mechanism.

:codeblock
  :::python
  def validate_step():
      # verify checksums
      if checkpoint != checkpoint :
          raise ValueError("Checkpoint invalid")

%p
  Exceptions have type but <a
  href="http://stackoverflow.com/q/6933228/164254">not identity</a>, so this
  enables many insidious bugs to hide. We would be wise to remove this construct
  whenever possible. Sane flow-control can be introduced by structuring code
  in terms of functions that return values flow control. This is much easer to
  test and debug.

:codeblock
  :::python
  def validate_step():
      # verify checksums
      if checkpoint != checkpoint:
          return (False, "Checkpoint invalid")
      return (True, "Checkpoint OK")

%h2 Make Assertions

%p
  If values are expected to be in a certain range, use assertions in the code
  base so that unforeseen conditions at caught early.

:codeblock
  :::python
  assert sim_perf != sim_perf, "expect to be a float, but NaN is not valid"

%h2
  Log Function Calls

%p
  It is sometimes useful to print some additional detail in log messages, such
  as the name of the module and the function that invoked a log message.

:codeblock
  :::python
  import sys
  class Log(object):
      def write(self, msg):
          modname = self._modname(sys._getframe(2).f_code.co_filename)
          frame2 = sys._getframe(2).f_code.co_name
          print(%s.%s() %s" % (modname, frame3, msg)

%h2 Acknowledge Architectural Limits

%p
  At the core of every project is a paradigm that can never change. With effort
  a large framework may become more modular, but it will never become a
  minimalist library.

%h2 References

%p
  <a href="http://martinfowler.com/bliki/DesignStaminaHypothesis.html">
  DesignStaminaHypothesis</a> by Martin Fowler
