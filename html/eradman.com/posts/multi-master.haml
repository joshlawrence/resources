%h1 Introducing Multi-Master

%h2 UDR and BDR
%p
  Thanks to work excellent work of 2ndQuadrant, the components needed to
  support unidirectional and bidirectional replication are [mostly] integrated
  into PostgreSQL. Logical replication allows a range of options including the
  replication of part of a cluster and multi-master configurations.

%h2 Build/Install
%h3 on Linux
%p
  At the time of this writing (PG 9.5) still does not bundle everything required
  to run logical replication out of the box, so fetch the latest tarballs from
  <a href="http://packages.2ndquadrant.com/postgresql-bdr94-2ndquadrant/tarballs/">packages.2ndquadrant.com</a>
  and build them

:codeblock
  cd postgres-bdr
  ./configure --prefix=/usr/pgsql-9.4-bdr --enable-debug
  make
  sudo make install
  cd contrib
  make
  sudo make install

  cd bdr-plugin
  PATH=/usr/pgsql-9.4-bdr/bin:$PATH ./configure --prefix=/usr/pgsql-9.4-bdr --enable-bdr
  make
  sudo make install

%h3 on BSD
%p
  Installation on the BSDs is similar
:codeblock
  FLEX=/usr/local/bin/gflex ./configure
  gmake -j2
  doas gmake install
  cd contrib
  doas gmake install

  PATH=/usr/local/pgsql/bin:$PATH ./configure
  gmake -j2
  doas gmake install

%h2 Starting up the Cluster
%p
  On each node initialize the databases

/sudo chown postgres:postgres /pg_data
:codeblock
  su -l postgres
  /usr/pgsql-9.4/bin/initdb -D /pg_data/9.4-bdr -A trust

%p
  Enable BDR in <em>postgresql.conf</em> thusly:

:codeblock
  :::config
  listen_addresses = '*'

  shared_preload_libraries = 'bdr'
  wal_level = 'logical'
  track_commit_timestamp = on
  max_connections = 100
  max_wal_senders = 10
  max_replication_slots = 10
  max_worker_processes = 10

%p
  And then set up the appropriate permissions in <em>pg_hba.conf</em>

:codeblock
  :::config
  local   replication     postgres                                trust
  host    replication     postgres        127.0.0.1/32            trust
  host    replication     postgres        ::1/128                 trust

  host all all 10.0.0.0/8  password

  host replication postgres 10.232.24.48/32 trust
  host replication postgres 10.232.25.92/32 trust

  host replication bdrsync 10.232.24.48/32 password
  host replication bdrsync 10.232.25.92/32 password

%p
  Next fire up the servers (as the user <em>postgres</em>) and create a user to
  be used for BDR

:codeblock
  /usr/pgsql-9.4/bin/pg_ctl -D /pg_data/9.4-bdr start
  psql -c "CREATE USER bdrsync superuser;"
  psql -c "ALTER USER bdrsync WITH PASSWORD '12345#';"

%p
  For each host we will create an unprivileged user and a blank database

:codeblock
  /usr/pgsql-9.4/bin/createuser amsv2
  /usr/pgsql-9.4/bin/createdb -O amsv2 amstest
  psql amstest -c 'CREATE EXTENSION btree_gist;'
  psql amstest -c 'CREATE EXTENSION bdr;'

%p
  Finally it is time to join the nodes together in a bdr group:

:codeblock
  :::sql
  SELECT bdr.bdr_group_create(
      local_node_name := 'node1',
      node_external_dsn := 'host=10.232.24.48 user=bdrsync dbname=amstest password=12345#'
  );

  SELECT bdr.bdr_group_join(
      local_node_name := 'node2',
      node_external_dsn := 'host=10.232.25.92 user=bdrsync dbname=amstest password=12345#',
      join_using_dsn := 'host=10.232.24.48 user=bdrsync dbname=amstest password=12345#'
  );

/
  SELECT bdr.bdr_group_join(
  local_node_name := 'node3',
  node_external_dsn := 'host=10.232.24.49 user=bdrsync dbname=amstest password=12345#',
  join_using_dsn := 'host=10.232.24.48 user=bdrsync dbname=amstest password=12345#'
  );

%h3 Verifying Associations
%p
  Each peer uses a replication slot to identify other nodes that changes
  propagate to

:codeblock
  amstest=# select * from bdr.bdr_node_slots;
  node_name |                slot_name
  -----------+-----------------------------------------
  node1     | bdr_17168_6231255027739465518_1_17948
  node3     | bdr_17168_6231542136481997963_1_17162
  (2 rows)

%p
  Also see the documentation on <a
  href="http://bdr-project.org/docs/0.9.0/catalog-bdr-nodes.html">BDR-related
  system catalogs</a>.

%p
  In production a lot of useful summary data can be seen in the
  <em>bdr.pg_stat_bdr</em> table.


%h2 Caveats of BDR

%h3 DDL Aquires Global Locks

%p
  All data manipulation of any sort is blocked on other masters if a table is
  altered:

:codeblock
  amstest=# insert into t2 values (70);
  ERROR:  database is locked against ddl by another node
  HINT:  Node (6226337458219448371,1,16385) in the cluster is already performing DDL

%h3 Properties of Roles
%ol
  %li
    Roles are not part of a database and are therefore not replicated
  %li
    Other masters will repeatedly try to change ownership
  %li
    All ownership changes must be applied. Setting the owner of a table to
    <em>A</em> must succeed before setting the owner to <em>B</em>.

%p
  Since clients receive errors DDL needs to be planned carefully

%h2 Global IDs

%p
  With logical replication sequences are local to the database. This is a
  challenge because for each database a scheme for avoiding ID conflicts.
  postgres-bdr includes a special sequence that will host an election between
  nodes and will negotiate ID blocks

:codeblock
  :::sql
  CREATE SEQUENCE global_job_id USING bdr;
  ALTER TABLE job ALTER COLUMN id SET DEFAULT nextval('global_job_id');

%p
  If we do not have enough nodes to establish a quorum then each node will
  eventually use up it's pre-allocated block of IDs. This does not block; it
  raises an error

:codeblock
  ERROR:  could not find free sequence value for global sequence public.global_job_id

%p
  While the initial ID of a sequence can be set when importing data; there is no
  direct way to increment the ID of an existing counter. We can force it this
  way:

:codeblock
  :::sql
  ALTER SEQUENCE global_job_id RESTART WITH 1000000;
  --ERROR:  ALTER SEQUENCE ... restart is not supported for bdr sequences

%p
  Perhaps the best we can do is increment the counter manually

:codeblock
  :::sql
  SELECT max(nextval('global_job_id')) FROM generate_series(1,1000);

/ http://bdr-project.org/docs/0.9.0/catalog-bdr-nodes.html

%h2 Dump/Restore

%h3 Import Existing Data
%p
  Before importing the data itself it is important to ensure that the schema
  itself works

:codeblock
  pg_restore -c -U amstest -d amstest -O -Fc -x -s /archive/ams.dump

%p
  Before trying to make a logical dump, remove BDR-related bookkeeping

:codeblock
  psql amstest -c 'truncate bdr.bdr_queued_commands;'
  psql amstest -c 'truncate bdr.bdr_queued_drops;'
  pg_dump amstest > /tmp/amsv2.dump

%p
  To convert all sequences to global add a directive to the top of the dump file

:codeblock
  :::sql
  SET LOCAL default_sequenceam = 'bdr';

This requires a restore using the single-transaction flag

:codeblock
  psql amstest -1 < /tmp/amsv2.dump

%h3 Recreating a Database
%p
  To remove the replication slots and demote a remote node run the following on
  each instance

:codeblock
  :::sql
  SELECT bdr.bdr_part_by_node_names(ARRAY['node2']);
  DELETE FROM bdr.bdr_nodes WHERE node_name='node2';
  SELECT pg_terminate_backend(pid) FROM pg_stat_activity WHERE client_port is null;

%p
  To destroy a database locally you first need to ensure that all clients have
  disconnected. Force this using

:codeblock
  :::sql
  SELECT pg_drop_replication_slot(slot_name)
  FROM pg_replication_slots
  WHERE database='amstest';

:codeblock
  dropdb amstest

  There is no simple way to convert a node to a sremove an orphaned disconnected node from a
  group. This is the <a
  href="https://github.com/2ndQuadrant/bdr/issues/127">current workaround</a>

:codeblock
  :::sql
  BEGIN;
  SET LOCAL bdr.skip_ddl_locking = on;
  SET LOCAL bdr.permit_unsafe_ddl_commands = on;
  SET LOCAL bdr.skip_ddl_replication = on;
  SECURITY LABEL FOR bdr ON DATABASE amstest IS NULL;
  DELETE FROM bdr.bdr_connections;
  DELETE FROM bdr.bdr_nodes;
  SELECT bdr.bdr_connections_changed();
  COMMIT;
