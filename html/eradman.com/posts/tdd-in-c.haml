%h1 Test-Driven Development in C

%p
  The Internet is now littered with frameworks writing unit tests for C, which
  is unfortunate because they suggest that writing test code for C requires a kind
  of parallel project that is bolted on the side. Worse yet, papers and
  presentations on the subject suggest adapting your project to a C++ framework
  along with it's clumsy idioms. A dogged insistence on <a
  href="http://martinfowler.com/articles/designDead.html">simplicity</a>
  when structuring a project written in C enables you to pick the techniques that
  fit particular designs. The business of writing tests requires some scafolding,
  but <a href="http://marc.info/?l=openbsd-ports&m=139474670315494">not
  much</a>.

%h2 A Simple Test Runner

%p
  Start by including the header file of the module or system under test.  The
  following is based on <a
  href="http://www.jera.com/techinfo/jtns/jtn002.html">MinUnit</a>, a minimal unit
  testing framework for C by John Brewer

:codeblock
  :::c
  /* runner.c */

  #include <stdio.h>
  #include "sut.h"

  int tests_run = 0;

%p
  Next define some simple macros that will print a meaningful error and return
%em
  1</em> if the test condition is not true. <em>do { ... } while(0)</em> is a
  standard way to include multiple statements in a macro, and the block gives
  variable declarations local storage.

:codeblock
  :::c
  #define FAIL() printf("\nfailure in %s() line %d\n", __func__, __LINE__)
  #define _assert(test) do { if (!(test)) { FAIL(); return 1; } } while(0)
  #define _verify(test) do { int r=test(); tests_run++; if(r) return r; } while(0)

%p
  The test runner itself is responsible for calling the <em>run_test</em> macro,
  which simply run each test in turn until one fails.

:codeblock
  :::c
  int square_01() {
      int x=5;
      _assert(square(x) == 25);
      return 0;
  }

  int all_tests() {
      _verify(square_01);
      return 0;
  }

  int main(int argc, char **argv) {
      int result = all_tests();
      if (result == 0)
          printf("PASSED\n");
      printf("Tests run: %d\n", tests_run);

      return result != 0;

%h2 Link-level Stubbing

%p
  Among the techniques available for faking functions in C, link-level stubs
  are a great place to begin because they require no changes to production code!
  One of the first functions you may want to replace is <em>main()</em>, so that
  the test runner is the new entry point for the resulting binary.

:codeblock
  :::make
  runner: runner.o sut.o
          strip -N main sut.o _sut.o
          ${CC} -o $@ runner.o _sut.o ${LDFLAGS}

%p
  Here we create a stripped version of the object code (<em>utility.o</em>) ,
  which allows the linker to connect the new main from <em>runner.o</em>.  Of
  course the test runner should always be executed as part of the build.

:codeblock
  :::make
  all: utility runner test

  test:
          ./runner

%h2 Faking Interfaces with the C Preprocessor

%p
  Linking a test runner only works if functions have a global scope (e.g.,
  don't use the <em>static</em> storage class). It may be sensible to inject the
  test code into each module using the C preprocessor. This is a very powerful
  technique, but it means maintaining separate build configurations, which has
  several implications.

%p
  Everything needs to be built twice, so it really helps to use a fast
  compiler, such as <a href="http://pcc.ludd.ltu.se/">PCC</a>. Build scripts and
  makefiles are making very strategic substitutions here, so I would strongly
  recommend staying clear of auto-tools. Instead factor out common elements and
  include them in platform-specific build configurations.</p>

:codeblock
  :::make
  # config.mk
  CC = pcc
  INCS =
  LIBS =
  CFLAGS = -O -g -std=c99 -pedantic -Wall ${INCS}
  LDFLAGS = -static ${LIBS}

%p
  Compile each source file with the <em>-D</em> flag to set macros that the
  preprocessor can use.

:codeblock
  :::make
  include config.mk

  sut.o:
          @echo CC $<
          @${CC} -c -DTEST ${CFLAGS} $<

%p
  Preprocessor instructions can be placed anywhere, but one way of organizing
  code is to break it into two distinct segments. The first is the system under
  test, and should contain all of the core functionality of the module, the
  second will include <em>main()</em> and other definitions that may be replaced
  by fake functions in the specification header.

:codeblock
  :::c
  /* sut.c */

  /* functions to be tested */

  #ifdef TEST
  #include "sut_spec.h"
  #else

  /* functions to be faked */

  #endif

%h2 Dynamic Mocks Using Global Function Pointers

%p
  If you don't mind one step of indirection, functions can be aliased with a
  function pointer which the test runner can then redefine at runtime.

:codeblock
  :::c
  /* sut.c */

  int (*myfunc)(int);

  int myfunc_IO(int x) {
      /* ... */
  }
  int (*myfunc)(int) = myfunc_IO;

:codeblock
  :::c
  /* runner.c */

  int myfunc_fake(int x) {
      /* ... */
  }

  void redefine_func_pointers() {
      myfunc = myfunc_fake;
  }

%p
  Since globals in C are initialized to <em>0</em>, an <em>if</em> statement
  can be used in corner cases where you might want to determine if function
  pointer has been defined but not initialized. Replacing <em>main()</em> is an
  example of when you might need to do this.

:codeblock
  :::c
  /* sut.c */

  int (*test_runner_main)(int, char **);

  int main(int argc, char **argv) {
      if((*test_runner_main))
          return(test_runner_main(argc, argv));
      /* ... */
  }

:codeblock
  :::c
  /* runner.c */

  #include "sut.c"

  int test_main(int argc, char **argv) {
      /* run tests */
  }
  int (*test_runner_main)(int argc, char **argv) = test_main;

%h2
  Locating Assertions that Trigger a Segfaults

%p
  Many system calls are designed to be fast, not safe.  If a function such as
%em
  strcmp(3)</em> is given a NULL pointer it will trigger a segfault.
  Fortunately, it's possible to catch <em>SIGSEGV</em> and generate a core dump at
  the same time.

:codeblock
  :::c
  const char* func;
  int line;

  #define _() func=__func__; line=__LINE__;
  #define ok(test) do { _(); if (!(test)) { fail(); return 1; } } while(0)
  #define run(test) do { reset_state(); tests_run++; test(); } while(0)
  void fail() { printf("test failure in %s() line %d\n", func, line); }

  void sighandler(int signum) {
          fail();
          /* generate core dump */
          signal(signum, SIG_DFL);
          kill(getpid(), signum);
  }

:codeblock
  :::c
  /* main() */
      signal(SIGSEGV, sighandler)

%p
  In this test runner each assert macro records the line number and function
  name to global variables, which the signal handler uses to print the location of
  the assertion that failed.

%h2
  Compile-time Checks and Debugging

%p
  One valuable assurance is that all of your tests are run. Adding
  <em>-Wall</em> to CFLAGS will cause GCC to warn you if a function is defined
  but never called.

:codeblock
  runner.c:81: warning: `test_env_subset' defined but not used

%p
  It's often said that test-first programming makes us less dependent on the
  debugger, and that's true, but a test runner also creates an environment where
  a debugger can be easily employed because the runner systematically exercises
  one function at a time. Make sure that debugging is turned on, and that your
  linker is not striping executables (<em>-s</em>).

:codeblock
  :::make
  CFLAGS += -g

%p
  It is also sometimes handy to add a shell script to the build that
  automatically prints out a backtrace of any core dumps that occurred.

:codeblock
  :::sh
  #!/bin/sh

  cat <<EOF > /tmp/report.gdb
  bt full
  quit
  EOF

  for I in `ls *.core 2> /dev/null`; do
          echo "---"
          gdb -q -x /tmp/report.gdb ${I%.core} -c ${I}
  done

  rm /tmp/report.gdb

