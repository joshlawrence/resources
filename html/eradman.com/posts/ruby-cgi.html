<!DOCTYPE html>
<html>
  <head>
    <title>
      Ruby-CGI Tips
    </title>
    <link href='../main.css' rel='stylesheet' type='text/css'>
    <link href='../code.css' rel='stylesheet' type='text/css'>
  </head>
  <body>
    <h3 style='margin-left: 5px; margin-top: 20px;'>
      <a href='../index.html' id='myname'>Eric Radman</a>
      <span id='mytitle'>: a Journal</span>
    </h3>
    <div id='article'>
      <h1>Ruby-CGI Tips</h1>
      <h2>Stop Error Suppression</h2>
      <p>
        Producing a backtrace from a script can be a security hazard, but at least in
        the development stage it's very nice to see the error that the Ruby interpreter
        spits out. This can be done by wrapping the entire script in a block and then
        checking for exceptions. This ensures that the return code from the interpreter
        is always <em>true</em>. So in general this is the structure of a CGI that I
        employ:
      </p>
      <pre id='vimCodeElement'>&#x000A;<span class="PreProc">#!/usr/local/bin/ruby</span>&#x000A;<span class="Statement">begin</span>&#x000A;    <span class="PreProc">require</span> <span class="Special">&quot;</span><span class="Constant">cgi</span><span class="Special">&quot;</span>&#x000A;    cgi = <span class="Type">CGI</span>.new&#x000A;    puts <span class="Special">&quot;</span><span class="Constant">Content-type: text/html</span><span class="Special">&quot;</span>&#x000A;    puts&#x000A;    puts <span class="Special">&quot;</span><span class="Constant">&lt;html&gt; ... &lt;/html&gt;</span><span class="Special">&quot;</span>&#x000A;<span class="Statement">rescue</span> <span class="Type">Exception</span>&#x000A;    print <span class="Special">&quot;</span><span class="Constant">Content-Type: text/plain</span><span class="Special">\r\n\r\n</span><span class="Special">&quot;</span>&#x000A;    puts <span class="Identifier">$!</span>.inspect, <span class="Identifier">$!</span>.backtrace&#x000A;<span class="Statement">end</span>&#x000A;</pre>
      <h2>Use eRuby</h2>
      <p>
        It's great:
      </p>
      <pre id='vimCodeElement'>&#x000A;<span class="PreProc">#!/usr/local/bin/ruby</span>&#x000A;<span class="PreProc">require</span> <span class="Special">&quot;</span><span class="Constant">eruby</span><span class="Special">&quot;</span>&#x000A;import&#x000A;puts <span class="Special">&quot;</span><span class="Constant">Content-type: text/html</span><span class="Special">&quot;</span>&#x000A;puts&#x000A;title = <span class="Special">&quot;</span><span class="Constant">My first page</span><span class="Special">&quot;</span>&#x000A;<span class="Type">ERuby</span>::import(<span class="Special">'</span><span class="Constant">template.rhtml</span><span class="Special">'</span>)&#x000A;</pre>
      <p>
        No anything inside <em>&lt;% ... %&gt;</em> in <em>template.rhtml</em> is
        evaluated with the environment that called it.
      </p>
      <h2>
        Alias cgi-bin
      </h2>
      <p>
        I often keep CGI's in the <em>cgi-bin</em> folder, but I don't always deploy
        it that way. This what I do in Apache:
      </p>
      <pre id='vimCodeElement'>&#x000A;<span class="Identifier">ScriptAlias</span> /app/ <span class="Constant">&quot;/home/eradman/public_html/cgi-bin/&quot;</span>&#x000A;</pre>
      <p>
        Or in thttpd a more general pattern:
      </p>
      <pre id='vimCodeElement'>&#x000A;cgipat=**.cgi|/cgi-bin/*|/app/*&#x000A;</pre>
      <p>
        Also in Apache there's a nice option that can be used in any virtual host
        entry that declares anything with executable permissions to be treated as a
        CGI.
      </p>
      <pre id='vimCodeElement'>&#x000A;<span class="Identifier">XBitHack</span> <span class="Constant">on</span>&#x000A;</pre>
      <h2>
        Use [sym]links
      </h2>
      <p>
        Hard links are slightly faster, but some versioning utilities (CVS) break
        the link by creating a new copy of the file. So sym-links provide a simple way
        to make simple URLs without complex rewrite rules. Just make sure Apache is
        told to use them:
      </p>
      <pre id='vimCodeElement'>&#x000A;Options FollowSymLinks&#x000A;</pre>
      <p>
        Now my directory listing might look something like this:
      </p>
      <pre id='vimCodeElement'>&#x000A;$ ls -ali | grep lrwx&#x000A;2131786 lrwxr-xr-x  1 tei  users      11 Mar 24  2006 customer -&gt; customer.rb&#x000A;2131628 lrwxr-xr-x  1 tei  users      13 Apr 21  2006 delinquent -&gt; delinquent.rb&#x000A;2136943 lrwxr-xr-x  1 tei  users      11 Apr 28  2006 deposits -&gt; deposits.rb&#x000A;2131822 lrwxr-xr-x  1 tei  users       7 Mar 27  2006 main -&gt; main.rb&#x000A;2138537 lrwxr-xr-x  1 tei  users      11 Jul 14 11:27 orphaned -&gt; orphaned.rb&#x000A;2135727 lrwxr-xr-x  1 tei  users      11 Apr 26  2006 payments -&gt; payments.rb&#x000A;2131800 lrwxr-xr-x  1 tei  users       7 Mar 24  2006 user -&gt; user.rb&#x000A;</pre>
      <h2>Rewrite URL's</h2>
      <p>
        My favorite use of <em>mod_rewrite</em> is to pass part of a URL as an
        argument to a script:
      </p>
      <pre id='vimCodeElement'>&#x000A;<span class="Identifier">RewriteEngine</span> <span class="Constant">on</span>&#x000A;<span class="Identifier">RewriteRule</span> ^(.*)article/(.*)$  $1cgi-bin/article.rb?id=$2&#x000A;</pre>
      <p>
        Now any characters following <em>article/</em> will be passed to
      </p>
      <em>
        article.rb</em>'s <em>id</em> parameter.
      </em>
      <h2>CGI Indexes</h2>
      <p>
        You may not realize that the Apache <em>DirectoryIndex</em> will accept
        pathnames as well as filenames, so you can use an absolute URL path to rest for
        a default script:
      </p>
      <pre id='vimCodeElement'>&#x000A;<span class="Identifier">DirectoryIndex</span> index.html /cgi-bin/index.rb&#x000A;</pre>
      <p>
        This is cool because it's a URL, not a file system path
      </p>
      <h2>Redirecting Output</h2>
      <p>
        If you need to capture the output of ERuby or the functions of another
        library you can assign a file handle to <em>$stdout</em>.
      </p>
      <pre id='vimCodeElement'>&#x000A;saved_stdout = <span class="Identifier">$stdout</span>&#x000A;<span class="Statement">begin</span>&#x000A;    output = <span class="Type">File</span>.open(<span class="Special">&quot;</span><span class="Constant">report.lout</span><span class="Special">&quot;</span>,<span class="Special">&quot;</span><span class="Constant">w</span><span class="Special">&quot;</span>)&#x000A;    <span class="Identifier">$stdout</span> = output&#x000A;    <span class="Type">ERuby</span>::import(<span class="Special">'</span><span class="Constant">report.rl</span><span class="Special">'</span>)&#x000A;    output.close&#x000A;<span class="Statement">end</span>&#x000A;<span class="Identifier">$stdout</span> = saved_stdout&#x000A;</pre>
      <p>
        Now when <em>ERuby::import</em> is called <em>print</em> calls are written to
        the open file. Always save the original value of <em>$stdout</em> so that you
        can restore it after the code block is finished.
      </p>
    </div>
    <p class='timestamp'>
      Last updated on March 26, 2015
    </p>
  </body>
</html>
