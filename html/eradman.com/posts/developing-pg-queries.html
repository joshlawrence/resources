<!DOCTYPE html>
<html>
  <head>
    <title>
      Developing PostgreSQL Queries
    </title>
    <meta content='text/html; charset=US-ASCII' http-equiv='Content-Type'>
    <link href='../main.css' rel='stylesheet' type='text/css'>
    <link href='../code.css' rel='stylesheet' type='text/css'>
  </head>
  <body>
    <h3 style='margin-left: 5px; margin-top: 20px;'>
      <a href='../index.html' id='myname'>Eric Radman</a>
      <span id='mytitle'>: a Journal</span>
    </h3>
    <div id='article'>
      <h1>Developing PostgreSQL Queries</h1>
      <p>
        Unit testing SQL does not seem to be a popular discipline, but I think
        complex queries have a lot to gain from corroboration through automated testing.
        As in testing any other kind of code, unit tests help separate concerns, and
        facilitate decomposition such that the programmer can more easily think through
        the process for solving a hard problem.
      </p>
      <p>
        SQL is largely a declarative language for relational data, and as such the
        programmer is first concerned with telling the database engine what to do with
        very attention to how the internal execution will occur. Once a query produces
        the correct result it often must be adjusted so as to provide better
        performance. This kind of refactoring becomes much less perilous once a set of
        tests are in place to prove that a new approach delivers the same result.
      </p>
      <h2>A Simple Test Runner</h2>
      <p>
        At times you may choose not to implement a separate test runner in shell, but
        a simple wrapper script can provide valuable options for debugging. One of my
        favorite options to watch for a keywords such as <em>shell</em> which will drop
        me into the UI for the database before destroying it. This allows me to
        experiment with the test functions and sample data.
      </p>
      <pre>&#x000A;<span class="Comment">#!/bin/ksh</span>&#x000A;<span class="Statement">set</span><span class="Identifier"> </span><span class="Special">-e</span>&#x000A;<span class="Identifier">DB</span>=<span class="PreProc">${</span><span class="PreProc">USER</span><span class="PreProc">}</span>_test&#x000A;createdb <span class="PreProc">$DB</span>&#x000A;<span class="Statement">cat</span> <span class="Special">{</span>stage,query,verify<span class="Special">}</span>.sql | psql <span class="Special">-tAq</span> <span class="PreProc">$DB</span> <span class="Constant">2</span><span class="Statement">&gt;&amp;1</span> | <span class="Statement">grep</span> <span class="Special">-v</span> <span class="Statement">&quot;</span><span class="Constant">^NOTICE</span><span class="Statement">&quot;</span>&#x000A;<span class="Special">[[</span> <span class="Statement">&quot;</span><span class="PreProc">$1</span><span class="Statement">&quot;</span> <span class="Statement">==</span> <span class="Statement">'</span><span class="Constant">shell</span><span class="Statement">'</span> <span class="Special">]]</span> &amp;&amp; psql <span class="PreProc">$DB</span>&#x000A;dropdb <span class="PreProc">$DB</span>&#x000A;</pre>
      <p>
        This runner assembles a test in three parts: <em>stage.sql</em> sets up
        utility functions, tables, and sample data, <em>query.sql</em> creates the
        views to be tested, and <em>verify.sql</em> runs the queries and compares
        results.
      </p>
      <h2>Test Functions</h2>
      <p>
        Postgres is nice enough to provide polymorphic types which can be used to
        create a generic comparison function.
      </p>
      <pre>&#x000A;<span class="Statement">CREATE</span> <span class="Special">FUNCTION</span> assert(expected anyelement, got anyelement) RETURNS SETOF void&#x000A;<span class="Special">AS</span> $$&#x000A;<span class="Special">BEGIN</span>&#x000A;  <span class="Special">IF</span> got!=expected <span class="Special">THEN</span>&#x000A;    RAISE <span class="Special">EXCEPTION</span> <span class="Constant">'got % results, expected %'</span>, got, expected;&#x000A;  <span class="Special">END</span> <span class="Special">IF</span>;&#x000A;<span class="Special">END</span>;&#x000A;$$ LANGUAGE plpgsql;&#x000A;</pre>
      <p>
        This simple comparison function expects both arguments to be of the same
        type, and it won't automatically promote types on your behalf.
      </p>
      <pre>&#x000A;<span class="Comment">-- incorrect: count() returns a bigint</span>&#x000A;<span class="Statement">SELECT</span> assert(<span class="Constant">0</span>, (<span class="Statement">SELECT</span> <span class="Identifier">count</span>(*) <span class="Special">FROM</span> machines));&#x000A;<span class="Comment">-- correct</span>&#x000A;<span class="Statement">SELECT</span> assert(<span class="Constant">0</span>, (<span class="Statement">SELECT</span> <span class="Identifier">count</span>(*) <span class="Special">FROM</span> machines)::<span class="Type">integer</span>);&#x000A;</pre>
      <p>
        The <em>SETOF</em> keyword prevents the function from returning a blank
        record, instead it returns a zero-length list.
      </p>
      <h2>
        Populating Samle Data
      </h2>
      <p>
        <em>INSERT</em> statements can become very verbose. If PostgreSQL is the
        only target, <em>COPY</em> tends to be more compact and readable since tabs are
        the standard delimiter.
      </p>
      <pre>&#x000A;COPY machines (name, ram) <span class="Special">FROM</span> stdin;&#x000A;computenode1   <span class="Constant">16</span>&#x000A;computenode2   <span class="Constant">16</span>&#x000A;computenode3   <span class="Constant">96</span>&#x000A;computenode4   <span class="Constant">96</span>&#x000A;</pre>
      <p>
        In traditional TDD a minimal fresh fixture is constructed to only supply
        enough data to satisfy the unit test. The same practice works well when
        verifying database design as well. The sample data should not include every
        column the production database contains, only the columns required by the views
        or queries that are being exersised.
      </p>
      <h2>Query Under Test</h2>
      <p>
        Because we split the test cycle into three different phases (stage, query,
        verify), we have the opportunity to create a query file that will be used
        without alteration to configure the production database. A simple view might
        read as follows:
      </p>
      <pre>&#x000A;<span class="Statement">CREATE</span> <span class="Statement">OR</span> <span class="Identifier">REPLACE</span> <span class="Special">VIEW</span> himem_machines <span class="Special">AS</span>&#x000A;    <span class="Statement">SELECT</span> name <span class="Special">FROM</span> machines&#x000A;    <span class="Special">WHERE</span> ram &gt; <span class="Constant">16</span>;&#x000A;</pre>
      <h2>Testing for Expected Behavior</h2>
      <p>
        Now that we have sample data we can create a new table (prefixed with
      </p>
      <em>
        t_</em> for test or temporary) that should mirror the expected results of
        the views under test.
      </em>
      <pre>&#x000A;<span class="Statement">CREATE</span> TEMPORARY <span class="Special">TABLE</span> t_himem_machines (&#x000A;    name <span class="Type">character</span> varying(<span class="Constant">32</span>)&#x000A;);&#x000A;&#x000A;COPY machines (t_himem_machines) <span class="Special">FROM</span> stdin;&#x000A;computenode3&#x000A;computenode4&#x000A;\.&#x000A;</pre>
      <p>
        Now that we have sample data, a query, and an expected result we can write a
        view that shows the descrepency between the actual and expected results before
        the exception is raised
      </p>
      <pre>&#x000A;<span class="Statement">CREATE</span> TEMPORARY <span class="Special">VIEW</span> machine_diff <span class="Special">AS</span>&#x000A;    <span class="Statement">SELECT</span> <span class="Constant">'+'</span>, * <span class="Special">FROM</span> (&#x000A;      <span class="Statement">SELECT</span> * <span class="Special">FROM</span> himem_machines EXCEPT <span class="Statement">SELECT</span> * <span class="Special">FROM</span> sample_machines&#x000A;    ) <span class="Special">AS</span> T1&#x000A;    <span class="Statement">UNION</span> <span class="Statement">ALL</span>&#x000A;    <span class="Statement">SELECT</span> <span class="Constant">'-'</span>, * <span class="Special">FROM</span> (&#x000A;      <span class="Statement">SELECT</span> * <span class="Special">FROM</span> himem_machines EXCEPT <span class="Statement">SELECT</span> * <span class="Special">FROM</span> sample_machines&#x000A;    ) <span class="Special">AS</span> T2;&#x000A;&#x000A;<span class="Special">BEGIN</span>&#x000A;    <span class="Statement">SELECT</span> * <span class="Special">FROM</span> machine_diff;&#x000A;    <span class="Statement">SELECT</span> assert(<span class="Constant">0</span>, (<span class="Statement">SELECT</span> <span class="Identifier">count</span>(*) <span class="Special">FROM</span> machine_diff)::<span class="Type">integer</span>);&#x000A;    <span class="Statement">SELECT</span> <span class="Constant">'SQL: rerun_candidates ..ok'</span>;&#x000A;<span class="Special">END</span>;&#x000A;</pre>
      <h2>Unit Test Schemas</h2>
      <p>
        Schemas in Postgres can be used to overlay functionality, and even make
        stubbing system functions possible.
      </p>
      <pre>&#x000A;<span class="Statement">CREATE</span> ROLE unit_tester ROLE eradman;&#x000A;<span class="Statement">CREATE</span> SCHEMA unit_tests AUTHORIZATION unit_tester;&#x000A;<span class="Statement">SET</span> search_path <span class="Special">TO</span> unit_tests, <span class="Constant">&quot;$user&quot;</span>, <span class="Special">public</span>, pg_catalog;&#x000A;</pre>
      <p>
        <em>pg_catalog</em> is normally the first element of the search path, but by
        adding it explicitly you can override built-in functions. There's no concept of
        a global variable as such, but we can adjust the behavior of our mock functions
        by updating a parameters table under the <em>unit_tests</em> schema.
      </p>
      <pre>&#x000A;<span class="Comment">-- Mask now() in pg_catalog by creating one in the unit_tests schema</span>&#x000A;<span class="Statement">CREATE</span> <span class="Statement">OR</span> <span class="Identifier">REPLACE</span> <span class="Special">FUNCTION</span> now() RETURNS timestamp <span class="Special">AS</span> $$&#x000A;<span class="Special">BEGIN</span>&#x000A;    <span class="Special">RETURN</span> timestamp <span class="Constant">'2011-06-11'</span>;&#x000A;<span class="Special">END</span>;&#x000A;$$ LANGUAGE plpgsql;</pre>
    </div>
    <p class='timestamp'>
      Last updated on March 08, 2017
      <br>
      <a href='https://bitbucket.org/eradman/eradman.com'>eradman.com/source</a>
    </p>
  </body>
</html>
