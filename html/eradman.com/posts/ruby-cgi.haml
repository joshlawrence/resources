%h1 Ruby-CGI Tips

%h2 Stop Error Suppression

%p
  Producing a backtrace from a script can be a security hazard, but at least in
  the development stage it's very nice to see the error that the Ruby interpreter
  spits out. This can be done by wrapping the entire script in a block and then
  checking for exceptions. This ensures that the return code from the interpreter
  is always <em>true</em>. So in general this is the structure of a CGI that I
  employ:

:codeblock
  :::ruby
  #!/usr/local/bin/ruby
  begin
      require "cgi"
      cgi = CGI.new
      puts "Content-type: text/html"
      puts
      puts "<html> ... </html>"
  rescue Exception
      print "Content-Type: text/plain\r\n\r\n"
      puts $!.inspect, $!.backtrace
  end

%h2 Use eRuby

%p
  It's great:

:codeblock
  :::ruby
  #!/usr/local/bin/ruby
  require "eruby"
  import
  puts "Content-type: text/html"
  puts
  title = "My first page"
  ERuby::import('template.rhtml')

%p
  No anything inside <em>&lt;% ... %&gt;</em> in <em>template.rhtml</em> is
  evaluated with the environment that called it.

%h2
  Alias cgi-bin

%p
  I often keep CGI's in the <em>cgi-bin</em> folder, but I don't always deploy
  it that way. This what I do in Apache:

:codeblock
  :::apache
  ScriptAlias /app/ "/home/eradman/public_html/cgi-bin/"

%p
  Or in thttpd a more general pattern:

:codeblock
  cgipat=**.cgi|/cgi-bin/*|/app/*

%p
  Also in Apache there's a nice option that can be used in any virtual host
  entry that declares anything with executable permissions to be treated as a
  CGI.

:codeblock
  :::apache
  XBitHack on

%h2
  Use [sym]links

%p
  Hard links are slightly faster, but some versioning utilities (CVS) break
  the link by creating a new copy of the file. So sym-links provide a simple way
  to make simple URLs without complex rewrite rules. Just make sure Apache is
  told to use them:

:codeblock
  Options FollowSymLinks

%p
  Now my directory listing might look something like this:

:codeblock
  $ ls -ali | grep lrwx
  2131786 lrwxr-xr-x  1 tei  users      11 Mar 24  2006 customer -> customer.rb
  2131628 lrwxr-xr-x  1 tei  users      13 Apr 21  2006 delinquent -> delinquent.rb
  2136943 lrwxr-xr-x  1 tei  users      11 Apr 28  2006 deposits -> deposits.rb
  2131822 lrwxr-xr-x  1 tei  users       7 Mar 27  2006 main -> main.rb
  2138537 lrwxr-xr-x  1 tei  users      11 Jul 14 11:27 orphaned -> orphaned.rb
  2135727 lrwxr-xr-x  1 tei  users      11 Apr 26  2006 payments -> payments.rb
  2131800 lrwxr-xr-x  1 tei  users       7 Mar 24  2006 user -> user.rb

%h2 Rewrite URL's

%p
  My favorite use of <em>mod_rewrite</em> is to pass part of a URL as an
  argument to a script:

:codeblock
  :::apache
  RewriteEngine on
  RewriteRule ^(.*)article/(.*)$  $1cgi-bin/article.rb?id=$2

%p
  Now any characters following <em>article/</em> will be passed to
%em
  article.rb</em>'s <em>id</em> parameter.

%h2 CGI Indexes

%p
  You may not realize that the Apache <em>DirectoryIndex</em> will accept
  pathnames as well as filenames, so you can use an absolute URL path to rest for
  a default script:

:codeblock
  :::apache
  DirectoryIndex index.html /cgi-bin/index.rb

%p
  This is cool because it's a URL, not a file system path

%h2 Redirecting Output

%p
  If you need to capture the output of ERuby or the functions of another
  library you can assign a file handle to <em>$stdout</em>.

:codeblock
  :::ruby
  saved_stdout = $stdout
  begin
      output = File.open("report.lout","w")
      $stdout = output
      ERuby::import('report.rl')
      output.close
  end
  $stdout = saved_stdout

%p
  Now when <em>ERuby::import</em> is called <em>print</em> calls are written to
  the open file. Always save the original value of <em>$stdout</em> so that you
  can restore it after the code block is finished.
