<!DOCTYPE html>
<html>
  <head>
    <title>
      A Home Router with UPnP and Authpf
    </title>
    <meta content='text/html; charset=US-ASCII' http-equiv='Content-Type'>
    <link href='../main.css' rel='stylesheet' type='text/css'>
    <link href='../code.css' rel='stylesheet' type='text/css'>
  </head>
  <body>
    <h3 style='margin-left: 5px; margin-top: 20px;'>
      <a href='../index.html' id='myname'>Eric Radman</a>
      <span id='mytitle'>: a Journal</span>
    </h3>
    <div id='article'>
      <h1>A Home Router with UPnP and Authpf</h1>
      <p>
        Never has the quality of tools for building Internet infrastructure been
        richer, and yet it is exceedingly rare to configure your own home network.
        Even if you maintain a business networking there is always something new to
        learn when managing Internet access from home.
      </p>
      <h2>Initial Router Configuration</h2>
      <p>
        Your service provider most likely uses DHCP to hand out addresses. If you have
        used another router you can keep the same IP by setting <em>lladdr</em>
      </p>
      <pre>&#x000A;# /etc/hostname.em0&#x000A;dhcp NONE NONE NONE lladdr 4C:E6:76:AB:E8:26&#x000A;</pre>
      <p>
        For the inside address I use a virtual interface so that I can use a bridge to
        connect several interfaces together on the same subnet
      </p>
      <pre>&#x000A;# /etc/hostname.vether0&#x000A;inet 192.168.0.4/24&#x000A;inet6 2001:470:a020::1/48&#x000A;</pre>
      <p>
        Creating a bridge that includes this interface is as easy as adding the
        participating interfaces
      </p>
      <pre>&#x000A; #/etc/hostname.bridge0&#x000A; up&#x000A; add vether0&#x000A; add axe0&#x000A;</pre>
      <p>
        Now enable routing
      </p>
      <pre>&#x000A;<span class="Identifier">net.inet.ip.forwarding</span><span class="Statement">=</span><span class="Constant">1</span>&#x000A;<span class="Identifier">net.inet6.ip6.forwarding</span><span class="Statement">=</span><span class="Constant">1</span>&#x000A;</pre>
      <p>
        All of these changes can be applied simply by running <a
        href="http://man.openbsd.org/rc">rc(8)</a>
      </p>
      <pre>&#x000A;$ doas sh /etc/rc&#x000A;</pre>
      <h2>Firewall Config</h2>
      <p>
        Start out with a basic PF config that enables port-address translation
      </p>
      <pre>&#x000A;<span class="Comment"># macros</span>&#x000A;&#x000A;<span class="Comment"># tables</span>&#x000A;&#x000A;<span class="Comment"># options</span>&#x000A;<span class="Statement">set</span> skip on lo&#x000A;<span class="Statement">set</span> block-policy return&#x000A;&#x000A;<span class="Comment"># nat</span>&#x000A;match out on egress from <span class="Type">192.168.0.0</span><span class="Constant">/24</span> <span class="Statement">nat</span>-to (egress)&#x000A;<span class="Statement">pass</span>&#x000A;</pre>
      <h2>Tuning</h2>
      <p>
        There is only one tuning parameter I change is to increase the IP buffer size
        from 300 to 4000. This smooths out high packet-count traffic such a video call
        from impairing other services.
      </p>
      <pre>&#x000A;<span class="Identifier">net.inet.ip.maxqueue</span><span class="Statement">=</span><span class="Constant">4000</span>&#x000A;&#x000A;</pre>
      <h2>UPnP Functionality</h2>
      <p>
        Video calls (such as Facetime) that use a peer-to-peer media channel require
        some method of permitting inbound forwarding on arbitrary ports. To accomplish
        this we need a daemon such as <a
        href="http://miniupnp.tuxfamily.org/">MiniUPnP</a>. Devices will request
        open ports using <a
        href="https://en.wikipedia.org/wiki/Simple_Service_Discovery_Protocol">SSDP</a>.
      </p>
      <p>
        The basic config is as follows:
      </p>
      <pre>&#x000A;# /etc/miniupnpd.conf&#x000A;allow 1024-65535 192.168.0.0/24 1024-65535&#x000A;deny 0-65535 0.0.0.0/0 0-65535&#x000A;</pre>
      <p>
        Activate changes to PF by adding a pointer to the rules
      </p>
      <pre>&#x000A;<span class="Statement">anchor</span> &quot;miniupnpd&quot;&#x000A;</pre>
      <p>
        Now when a video call is place we should be able to see the new dynamic rules
      </p>
      <pre>&#x000A;# pfctl -a 'miniupnpd/*' -s rules&#x000A;pass in log quick on em0 inet proto udp from any to any port = 29999 \&#x000A;      label &quot;NAT-PMP 29999 udp&quot; rdr-to 192.168.0.88 port 29999&#x000A;pass in log quick on em0 inet proto tcp from any to any port = 29999 \&#x000A;      flags any label &quot;NAT-PMP 29999 tcp&quot; rdr-to 192.168.0.88 port 29999&#x000A;</pre>
      <h2>Authpf</h2>
      <p>
        <a href="http://www.openbsd.org/faq/pf/authpf.html">Authpf</a> is a method of
        activating a set of rules based on who has successfully authenticated via SSH.
        It is activated by setting a user's shell to <em>/usr/sbin/authpf</em>. Any
        number of users may have their own configurations. The basic configuration
        files for a user named <em>www-access</em> are:
      </p>
      <pre>&#x000A;/etc/authpf/authpf.conf&#x000A;/etc/authpf/authpf/users/www-access/authpf.message&#x000A;/etc/authpf/authpf/users/www-access/authpf.rules&#x000A;</pre>
      <p>
        For per-user configuration, <em>authpf.conf</em> may be empty, but must be
        present. The other two simply contain a signin message
      </p>
      <pre>&#x000A;Access enabled for all blocked devices&#x000A;</pre>
      <p>
        and the PF rules to apply
      </p>
      <pre>&#x000A;<span class="Statement">pass</span> in quick on !lo inet proto tcp from <span class="Type">any</span> to <span class="Type">any</span> port <span class="Constant">80</span>&#x000A;<span class="Statement">pass</span> in quick on !lo inet proto tcp from <span class="Type">any</span> to <span class="Type">any</span> port <span class="Constant">443</span>&#x000A;</pre>
      <p>
        After connecting via SSH the new rules will be attached
      </p>
      <pre>&#x000A;# pfctl -a 'authpf/*' -s rules&#x000A;anchor &quot;www-proxy(25253)&quot; all {&#x000A;  pass in quick on ! lo inet proto tcp from any to any port = 80 flags S/SA&#x000A;  pass in quick on ! lo inet proto tcp from any to any port = 443 flags S/SA&#x000A;}&#x000A;&#x000A;</pre>
      <h2>Content Filtering</h2>
      <p>
        I want my children and anyone else using guest Wifi at my home to have access
        to the Internet from their mobile devices, but not necessarily everything on
        the web. Blocking ports 80 and 443 is too broad since many applications speak
        over those ports.  OpenBSD's <em>relayd</em> provides an excellent mechanism
        for implementing transparent HTTP filtering.
      </p>
      <p>
        It is easy enough to filter by URL, but this is never what I want--I am
        interested in particular content. Here are the HTTP headers for the video
        player for PBS KIDS:
      </p>
      <pre>&#x000A;$ curl  -s -D - <a href="http://www-tc.pbskids.org/pbsk/video/lib/assets/swf/video-js.swf">http://www-tc.pbskids.org/pbsk/video/lib/assets/swf/video-js.swf</a>&#x000A;Content-Type: application/x-shockwave-flash&#x000A;Content-Length: 16743&#x000A;Connection: keep-alive&#x000A;Date: Wed, 30 Dec 2015 13:38:06 GMT&#x000A;Server: Apache&#x000A;Last-Modified: Wed, 09 Dec 2015 23:07:30 GMT&#x000A;Accept-Ranges: bytes&#x000A;Access-Control-Allow-Origin: *&#x000A;Cache-Control: max-age=3600&#x000A;Expires: Wed, 30 Dec 2015 14:38:06 GMT&#x000A;X-PBS-appsvrname: kids-fwcacheproxy10&#x000A;X-PBS-appsvrip: 10.100.10.21&#x000A;Via: www-cache.pbskids.org (t=1451482686108763), 1.1 0a9f4502819b08c3a7919c963887be2b.cloudfront.net (CloudFront)&#x000A;Cache-Control: s-maxage=3600&#x000A;Age: 40974&#x000A;X-Cache: Hit from cloudfront&#x000A;X-Amz-Cf-Id: 2gi8kI02gYSn-AW4a1tyiAj2LWD8geZb5yC9rfFZfDeV4tbGKoFXpQ==&#x000A;</pre>
      <p>
        For most web browsers blocking anything with a <em>Content-Type</em> of
        <em>application/x-shockwave-flash</em> will suffice, but the iPad app doesn't
        use Flash. Instead I added a rule to match anything with a header named
        <em>X-PBS-appsvrname</em>. Here are the basic rules
      </p>
      <pre>&#x000A;<span class="Comment"># /etc/relayd.conf</span>&#x000A;<span class="Constant">http</span> protocol httpfilter {&#x000A;  return error style 'body { background: <span class="Comment">#f3f3f3; color: #606060; }'</span>&#x000A;  <span class="Statement">pass</span>&#x000A;&#x000A;  match label &quot;Content blocked&quot;&#x000A;  <span class="Statement">block </span>response quick header &quot;Content-Type&quot; value &quot;application/x-shockwave-flash&quot;&#x000A;  <span class="Statement">block </span>response quick header &quot;Content-Type&quot; value &quot;video/x-flv&quot;&#x000A;  <span class="Statement">block </span>response quick header &quot;X-PBS-appsvrname&quot; value &quot;*&quot;&#x000A;}&#x000A;&#x000A;relay plaininspect {&#x000A;      listen on <span class="Type">127.0.0.1</span> port <span class="Constant">8080</span>&#x000A;      protocol httpfilter&#x000A;      forward to destination&#x000A;}&#x000A;</pre>
      <p>
        If we are willing to put up with certificate warnings on the clients we can
        also filter TLS (<em>https://</em>). The rules are almost identical to the
        filter for <em>http://</em>
      </p>
      <pre>&#x000A;<span class="Constant">http</span> protocol httpsfilter {&#x000A;  return error style 'body { background: <span class="Comment">#f3f3f3; color: #606060; }'</span>&#x000A;  <span class="Statement">pass</span>&#x000A;&#x000A;  match label &quot;Content blocked&quot;&#x000A;  <span class="Statement">block </span>response quick header &quot;Content-Type&quot; value &quot;video/quicktime&quot;&#x000A;&#x000A;  <span class="Comment"># Configuration directives for SSL/TLS Interception</span>&#x000A;  tls ca key &quot;/etc/ssl/private/ca.key&quot; password &quot;secret&quot;&#x000A;  tls ca cert &quot;/etc/ssl/ca.crt&quot;&#x000A;  tls { sslv3, tlsv1 }&#x000A;}&#x000A;&#x000A;relay tlsinspect {&#x000A;  listen on <span class="Type">127.0.0.1</span> port <span class="Constant">8443</span> tls&#x000A;  protocol httpsfilter&#x000A;  forward with tls to destination&#x000A;}&#x000A;</pre>
      <!-- https://github.com/reyk/relayd/blob/master/etc/relayd.conf -->
      <p>
        <em>relayd</em> needs two certificates: one to be used as a fake client
        (enter the passphrase "secret), and the other without a password for the
        server side
      </p>
      <pre>&#x000A;# openssl req -x509 -days 365 -newkey rsa:2048 \&#x000A;  -keyout /etc/ssl/relayd/ca.key -out /etc/ssl/relayd/ca.crt&#x000A;&#x000A;# openssl req -nodes -x509 -days 365 -newkey rsa:2048 \&#x000A;  -keyout /etc/ssl/private/127.0.0.1.key -out /etc/ssl/127.0.0.1.crt&#x000A;</pre>
      <p>
        Finally we redirect hosts not on a given whitelist using PF
      </p>
      <pre>&#x000A;<span class="Statement">table</span> <span class="Identifier">&lt;permitted&gt;</span> { <span class="Type">192.168.0.2</span>, <span class="Type">192.168.0.4</span> }&#x000A;<span class="Statement">pass</span> in on !egress inet proto tcp from <span class="Type">any</span> to port <span class="Constant">443</span> divert-to localhost port <span class="Constant">8443</span>&#x000A;<span class="Statement">pass</span> in on !egress inet proto tcp from <span class="Type">any</span> to port <span class="Constant">80</span> divert-to localhost port <span class="Constant">8080</span>&#x000A;<span class="Statement">pass</span> in on !lo inet proto tcp from <span class="Identifier">&lt;permitted&gt;</span> to <span class="Type">any</span> port {<span class="Constant">80</span>, <span class="Constant">443</span>}&#x000A;</pre>
      <p>
        Now rather than being subjected to the Internet as if we it were cable TV, we
        tell the Internet what it can do for us.
      </p>
      <h3>Exemptions</h3>
      <p>
        The difficult part to this arragement is that many applications on mobile
        devices communicate over the standard port for <em>https</em>. Selectively
        allowing services to run will often require a support ticket to find out
        exactally what kind of rule to add
      </p>
      <pre>&#x000A;<span class="Comment"># Zello uses 443 and 28225</span>&#x000A;<span class="Statement">pass</span> in on !lo inet proto tcp from <span class="Type">any</span> to karabas.loudtalks.com port <span class="Constant">443</span>&#x000A;</pre>
      <p>
        Another approach is to allow certain services (such as automatic updates) to
        run during a window of time. Here is a crontab that allows all web traffic
        from 4:00 to 8:00 in the morning
      </p>
      <pre>&#x000A;<span class="Constant">00</span>     <span class="PreProc"> 4</span>      <span class="Type"> *</span>      <span class="Constant"> *</span>      <span class="PreProc"> *</span>       <span class="Statement">pfctl -a http -f /etc/anchor.http_allow</span>&#x000A;<span class="Constant">00</span>     <span class="PreProc"> 8</span>      <span class="Type"> *</span>      <span class="Constant"> *</span>      <span class="PreProc"> *</span>       <span class="Statement">pfctl -a http -F rules</span>&#x000A;</pre>
      <pre>&#x000A;<span class="Comment">#/etc/anchor.http_allow</span>&#x000A;<span class="Statement">pass</span> in proto tcp from <span class="Type">192.168.0.0</span><span class="Constant">/24</span> to <span class="Type">any</span> port { <span class="Constant">80</span> <span class="Constant">443</span> }</pre>
    </div>
    <p class='timestamp'>
      Last updated on March 08, 2017
      <br>
      <a href='https://bitbucket.org/eradman/eradman.com'>eradman.com/source</a>
    </p>
  </body>
</html>
