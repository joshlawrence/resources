<!DOCTYPE html>
<html>
  <head>
    <title>
      Repeatable State with Salt
    </title>
    <meta content='text/html; charset=US-ASCII' http-equiv='Content-Type'>
    <link href='../main.css' rel='stylesheet' type='text/css'>
    <link href='../code.css' rel='stylesheet' type='text/css'>
  </head>
  <body>
    <h3 style='margin-left: 5px; margin-top: 20px;'>
      <a href='../index.html' id='myname'>Eric Radman</a>
      <span id='mytitle'>: a Journal</span>
    </h3>
    <div id='article'>
      <h1>Repeatable State with Salt</h1>
      <h2>Executable Documentation</h2>
      <p>
        If you have stood up services and then tried to document the steps that you
        will realize that communicating the changes to others or your future self is
        not easy. At least it's not easy if you care about the documentation being
        correct or relatively complete.
        <a href=" http://saltstack.com">Salt Stack</a> is an automation framework that
        works for large scale deployments, but also gives you a nice way to capture
        the configuration state of small-scale deployments such as your home firewall
        or personal web server. Salt has such readable configuration that it's like
        documentation that you can execute.
      </p>
      <h2>Commands</h2>
      <p>
        There are four commands that you need to know about
      </p>
      <table>
        <tr>
          <th>Command</th>
          <th>Description</th>
        </tr>
        <tr>
          <td><em>salt-key</em></td>
          <td>Manage minion connections</td>
        </tr>
        <tr>
          <td><em>salt</em></td>
          <td>Run rules by using salt master to push changes to the minions</td>
        </tr>
        <tr>
          <td><em>salt-call</em></td>
          <td>Pull rules from the salt master and apply locally</td>
        </tr>
        <tr>
          <td><em>salt-ssh</em></td>
          <td>Upload configuration and apply state over SSH</td>
        </tr>
      </table>
      <h2>Pushing changes with SSH</h2>
      <p>
        Salt is popular for it's scalable master-minion model, but it can be used with
        SSH as well. <em>salt-ssh</em> reads a configuration file called
        <em>Saltfile</em>
      </p>
      <pre>&#x000A;<span class="PreProc">---</span>&#x000A;<span class="Identifier">salt-ssh</span><span class="Special">:</span>&#x000A;  <span class="Identifier">config_dir</span><span class="Special">:</span> ./etc&#x000A;</pre>
      <p>
        In the file <em>etc/master</em> we can then specify where the repository is
        (<em>.</em> for the current directory). <em>state_verbose: False</em>
        produces a detailed report only for changes.
      </p>
      <pre>&#x000A;<span class="PreProc">---</span>&#x000A;<span class="Identifier">file_roots</span><span class="Special">:</span>&#x000A;  <span class="Identifier">base</span><span class="Special">:</span>&#x000A;        <span class="Statement">- </span>.&#x000A;<span class="Identifier">state_verbose</span><span class="Special">:</span> <span class="Constant">False</span>&#x000A;</pre>
      <p>
        There several downsides to using SSH. This mode is slow, and errors from the
        remote end (incomplete sudo configuration, missing python) tend to be
        obscure. <em>/etc/roster</em> specifies a list of hosts
      </p>
      <pre>&#x000A;<span class="PreProc">---</span>&#x000A;<span class="Identifier">home</span><span class="Special">:</span>&#x000A;  <span class="Identifier">host</span><span class="Special">:</span> home.eradman.com&#x000A;  <span class="Identifier">user</span><span class="Special">:</span> eradman&#x000A;  <span class="Identifier">sudo</span><span class="Special">:</span> <span class="Constant">True</span>&#x000A;</pre>
      <h2>Basic Configuration</h2>
      <p>
        To do a dry-run, use <em>test=True</em> with <em>state.highstate</em> or
        <em>state.sls</em>. The <em>highstate</em> method from the <em>state</em>
        module, applies all rules.
      </p>
      <pre>&#x000A;$ salt-ssh home state.highstate test=True&#x000A;</pre>
      <p>
        The rules are first defined in <em>top.sls</em>, which is a YAML file that
        maps hosts to rules.
      </p>
      <pre>&#x000A;<span class="PreProc">---</span>&#x000A;<span class="Identifier">base</span><span class="Special">:</span>&#x000A;  <span class="Constant">'</span><span class="Constant">workstation or t60.eradman.com</span><span class="Constant">'</span><span class="Special">:</span>&#x000A;    <span class="Statement">- </span>openbsd-common&#x000A;    <span class="Statement">- </span>workstation&#x000A;  <span class="Constant">'</span><span class="Constant">home</span><span class="Constant">'</span><span class="Special">:</span>&#x000A;    <span class="Statement">- </span>openbsd-common&#x000A;    <span class="Statement">- </span>home&#x000A;</pre>
      <p>
        The rule defined as <em>openbsd-common</em> can either be a YAML file called
        <em>openbsd-common.sls</em> or a directory containing
        <em>openbsd-common/init.sls</em>. The directory structure provides a logical
        place to put other files that you will reference, but that's up to you.
        intend to.
      </p>
      <p>
        The name of each rule can be arbitrary
      </p>
      <pre>&#x000A;<span class="Identifier">www-account</span><span class="Special">:</span>&#x000A;  <span class="Identifier">user.present</span><span class="Special">:</span>&#x000A;    <span class="Statement">- </span><span class="Identifier">name</span><span class="Special">:</span> www&#x000A;    <span class="Statement">- </span><span class="Identifier">group</span><span class="Special">:</span> www&#x000A;    <span class="Statement">- </span><span class="Identifier">fullname</span><span class="Special">:</span> HTTP Server&#x000A;    <span class="Statement">- </span><span class="Identifier">home</span><span class="Special">:</span> /home/www&#x000A;    <span class="Statement">- </span><span class="Identifier">shell</span><span class="Special">:</span> /sbin/nologin&#x000A;</pre>
      <p>
        Or the <em>name</em> paramter will default to the rule name
      </p>
      <pre>&#x000A;<span class="Identifier">www</span><span class="Special">:</span>&#x000A;  <span class="Identifier">user.present</span><span class="Special">:</span>&#x000A;    <span class="Statement">- </span><span class="Identifier">group</span><span class="Special">:</span> www&#x000A;    <span class="Statement">- </span><span class="Identifier">fullname</span><span class="Special">:</span> HTTP Server&#x000A;    <span class="Statement">- </span><span class="Identifier">home</span><span class="Special">:</span> /home/www&#x000A;    <span class="Statement">- </span><span class="Identifier">shell</span><span class="Special">:</span> /sbin/nologin&#x000A;</pre>
      <p>
        This is a shortcut, but another implication is that if we wanted to apply
        more than one rule to the same target we need to give the rule a unique name.
      </p>
      <p>
        The <em>source</em> path can refer to any location in this repo, this example
        expects a folder called <em>files</em>.
      </p>
      <h2>Master-Minion</h2>
      <p>
        Even on a small scale this mode really shines because of it's speed. The
        configuration for the master consists of the following changes to
        <em>/etc/salt/master</em>
      </p>
      <pre>&#x000A;<span class="Identifier">interface</span><span class="Special">:</span> 0.0.0.0&#x000A;<span class="Identifier">state_verbose</span><span class="Special">:</span> <span class="Constant">False</span>&#x000A;<span class="Identifier">file_roots</span><span class="Special">:</span>&#x000A;  <span class="Identifier">base</span><span class="Special">:</span>&#x000A;    <span class="Statement">- </span>/srv/salt&#x000A;  <span class="Identifier">eradman</span><span class="Special">:</span>&#x000A;    <span class="Statement">- </span>/home/eradman/hg/config&#x000A;</pre>
      <p>
        Now the trick is to write a top file that allows you to run against a specific
        environment.
      </p>
      <pre>&#x000A;<span class="Special">{{</span>saltenv<span class="Special">}}</span>:&#x000A;  <span class="Constant">'</span><span class="Constant">*</span><span class="Constant">'</span><span class="Special">:</span>&#x000A;      <span class="Statement">- </span>defaults&#x000A;</pre>
      <p>
        All service files in Salt are processed as Jinja2 templates, so {{saltenv}}
        will be replaced with the value of <em>env</em> on the command line
      </p>
      <pre>&#x000A;$ sudo salt '*' state.highstate test=True saltenv=$USER&#x000A;</pre>
      <p>
        As you might guess, <em>$USER</em> can be <em>devel</em> or any other path
        you define in <em>file_roots</em>.
      </p>
      <p>
        Special variables such as passwords are normally retrieved using a pillar
        module. One such module is <em>cmd_yaml</em>, which simply expects a command
        with formatted output. This is from `/etc/salt/master`
      </p>
      <pre>&#x000A;<span class="Identifier">ext_pillar</span><span class="Special">:</span>&#x000A;  <span class="Statement">- </span><span class="Identifier">cmd_yaml</span><span class="Special">:</span> lom_credentials.yaml&#x000A;</pre>
      <p>
        Now the values defined in this file can be rendered in templates, or viewed
        using
      </p>
      <pre>&#x000A;$ sudo salt $HOSTNAME pillar.items&#x000A;</pre>
      <h2>Templates</h2>
      <p>
        Every time a template is rendered it has access to range of variables that
        pertian to the host it will be installed on. To see a list this list of
        values, run the <em>grains.items</em> rule
      </p>
      <pre>&#x000A;$ sudo salt $HOSTNAME grains.items&#x000A;</pre>
      <p>
        Now you can reference any of these values in your template
      </p>
      <pre>&#x000A;<span class="Statement">&lt;VirtualHost</span><span class="Constant"> *:80</span><span class="Statement">&gt;</span>&#x000A;   <span class="Identifier">ServerName</span> {{ grains['localhost'] }}&#x000A;   <span class="Identifier">DocumentRoot</span> /var/www/html&#x000A;<span class="Statement">&lt;/VirtualHost&gt;</span>&#x000A;</pre>
      <p>
        Since service files are processed as templates, you can build various
      </p>
      shortcuts by using loops
      <pre>&#x000A;<span class="Special">{</span>% for interface in <span class="Special">[</span><span class="Constant">&quot;</span><span class="Constant">athn0</span><span class="Constant">&quot;</span>, <span class="Constant">&quot;</span><span class="Constant">bridge0</span><span class="Constant">&quot;</span>, <span class="Constant">&quot;</span><span class="Constant">em0</span><span class="Constant">&quot;</span>, <span class="Constant">&quot;</span><span class="Constant">gif0</span><span class="Constant">&quot;</span>, <span class="Constant">&quot;</span><span class="Constant">vether0</span><span class="Constant">&quot;</span><span class="Special">]</span> %<span class="Special">}</span>&#x000A;<span class="Identifier">/etc/hostname.{{interface}}</span><span class="Special">:</span>&#x000A;  <span class="Identifier">file.managed</span><span class="Special">:</span>&#x000A;    <span class="Statement">- </span><span class="Identifier">source</span><span class="Special">:</span> salt://home/hostname.{{interface}}&#x000A;    <span class="Statement">- </span><span class="Identifier">user</span><span class="Special">:</span> root&#x000A;    <span class="Statement">- </span><span class="Identifier">group</span><span class="Special">:</span> wheel&#x000A;    <span class="Statement">- </span><span class="Identifier">mode</span><span class="Special">:</span> <span class="Constant">640</span>&#x000A;<span class="Special">{</span>% endfor %<span class="Special">}</span>&#x000A;</pre>
      <p>
        There are a number of <a
        href="http://jinja.pocoo.org/docs/dev/templates/#builtin-filters">built-in
        filters</a> that you can employ them to remap all sorts of data. Here I'm
        using <em>replace</em> to map a paths to the naming convetion in my local
        repository
      </p>
      <pre>&#x000A;<span class="Special">{</span>% for file in <span class="Special">[</span><span class="Constant">&quot;</span><span class="Constant">miniupnpd.conf</span><span class="Constant">&quot;</span>, <span class="Constant">&quot;</span><span class="Constant">dhcpd.conf</span><span class="Constant">&quot;</span>, <span class="Constant">&quot;</span><span class="Constant">mail/smtpd.conf</span><span class="Constant">&quot;</span><span class="Special">]</span> %<span class="Special">}</span>&#x000A;<span class="Identifier">/etc/{{file}}</span><span class="Special">:</span>&#x000A;  <span class="Identifier">file.managed</span><span class="Special">:</span>&#x000A;    <span class="Statement">- </span><span class="Identifier">source</span><span class="Special">:</span> salt://home/{{file|replace('/', <span class="Constant">'</span><span class="Constant">_</span><span class="Constant">'</span>)}}&#x000A;&#x000A;</pre>
      <h2>Precheckin Validation</h2>
      <p>
        Salt doesn't provide a check-syntax flag, but several state modules provide a
        <em>mock</em> flag that enables you to process rules without hitting the
        network
      </p>
      <pre>&#x000A;<span class="Comment">#!/bin/sh -e</span>&#x000A;sudo salt-call state.highstate <span class="Statement">\</span>&#x000A;  <span class="Special">--file-root=</span><span class="Error">$(</span><span class="Special">dirname </span><span class="PreProc">$0</span><span class="Error">)</span> <span class="Statement">\</span>&#x000A;  <span class="Special">--local</span> <span class="Special">--retcode-passthrough</span> <span class="Statement">\</span>&#x000A;  <span class="Identifier">mock</span>=True&#x000A;</pre>
      <h2>Running Salt's Development Branch</h2>
      <p>
        If you want to run salt's development branch or test a modification it is
        easy enough to install it to a <em>virtualenv</em>
      </p>
      <pre>&#x000A;  virtualenv-2.<span class="Constant">7</span> ~/local/saltenv&#x000A; <span class="Statement"> . </span>~/local/saltenv/bin/activate&#x000A;&#x000A;  <span class="Statement">cd</span> ~/git/salt&#x000A;  pip install <span class="Special">-r</span> requirements/dev_python27.txt&#x000A;  pip install <span class="Special">-r</span> requirements/zeromq.txt&#x000A;  ./setup.py install&#x000A;</pre>
      <p>
        Now test changes by running locally
      </p>
      <pre>&#x000A;$ salt-call state.highstate --file-root=$PWD --local -l debug&#x000A;</pre>
      <p>
        <em>salt-call</em> would normally try to connect to a master, but
        <em>--local</em> instructs it to use to read configuration locally.
      </p>
      <h2>Example Configuration: WordPress</h2>
      <p>
        The following is a completely automated install of WordPress on OpenBSD.
        <a href="http://docs.ansible.com/ansible/playbooks_best_practices.html">Unlike
        Ansible</a>, Salt allows you to factor out components as you go. In this case
        I created a single file called <em>vm/wordpress.sls</em> that I included at
        the end of <em>vm/init.sls</em>
      </p>
      <pre>&#x000A;<span class="Identifier">include</span><span class="Special">:</span>&#x000A;  <span class="Statement">- </span>vm.wordpress&#x000A;</pre>
      <p>
        First we install the prerequisites for WordPress itself, including PHP and the
        libraries for accessing MySQL
      </p>
      <pre>&#x000A;<span class="Identifier">wordpress-packages</span><span class="Special">:</span>&#x000A;  <span class="Identifier">pkg.installed</span><span class="Special">:</span>&#x000A;    <span class="Statement">- </span><span class="Identifier">pkgs</span><span class="Special">:</span>&#x000A;      <span class="Statement">- </span>mariadb-server&#x000A;      <span class="Statement">- </span>mariadb-client&#x000A;      <span class="Statement">- </span>py-mysql&#x000A;      <span class="Statement">- </span>py-pip&#x000A;      <span class="Statement">- </span>php-mysqli&#x000A;    <span class="Statement">- </span><span class="Identifier">skip_suggestions</span><span class="Special">:</span> <span class="Constant">true</span>&#x000A;    <span class="Statement">- </span><span class="Identifier">fromrepo</span><span class="Special">:</span> pillar['openbsd_pkg_mirror']&#x000A;</pre>
      <p>
        OpenBSD supports multiple versions of PHP, none of which are configured by
        default. Symlink the default configurations like so
      </p>
      <pre>&#x000A;<span class="Identifier">/etc/php-5.6/mysqli.ini</span><span class="Special">:</span>&#x000A;  <span class="Identifier">file.symlink</span><span class="Special">:</span>&#x000A;    <span class="Statement">- </span><span class="Identifier">target</span><span class="Special">:</span> /etc/php-5.6.sample/mysqli.ini&#x000A;&#x000A;<span class="Identifier">/etc/php-5.6/opcache.ini</span><span class="Special">:</span>&#x000A;  <span class="Identifier">file.symlink</span><span class="Special">:</span>&#x000A;    <span class="Statement">- </span><span class="Identifier">target</span><span class="Special">:</span> /etc/php-5.6.sample/opcache.ini&#x000A;&#x000A;<span class="Identifier">/etc/php-5.6.ini</span><span class="Special">:</span>&#x000A;  <span class="Identifier">file.symlink</span><span class="Special">:</span>&#x000A;    <span class="Statement">- </span><span class="Identifier">target</span><span class="Special">:</span> /usr/local/share/examples/php-5.6/php.ini-development&#x000A;</pre>
      <p>
        Next initialize and start up a MariaDB server
      </p>
      <pre>&#x000A;<span class="Identifier">/usr/local/bin/mysql_install_db</span><span class="Special">:</span>&#x000A;  <span class="Identifier">cmd.run</span><span class="Special">:</span>&#x000A;    <span class="Statement">- </span><span class="Identifier">creates</span><span class="Special">:</span> /var/mysql&#x000A;<span class="Identifier">mysqld</span><span class="Special">:</span>&#x000A;  service.running&#x000A;</pre>
      <p>
        Now that we have a MariaDB server we will create a mysql user and database for
        WordPress to use. In order to manage the new database Salt needs a MySQL
        library for Python. Salt can install packages via PIP itself as long as we
        symlink the <em>pip</em> to the version of Python we're using
      </p>
      <pre>&#x000A;<span class="Identifier">/usr/local/bin/pip</span><span class="Special">:</span>&#x000A;  <span class="Identifier">file.symlink</span><span class="Special">:</span>&#x000A;    <span class="Statement">- </span><span class="Identifier">target</span><span class="Special">:</span> /usr/local/bin/pip2.7&#x000A;&#x000A;<span class="Identifier">wordpress_db</span><span class="Special">:</span>&#x000A;  <span class="Identifier">pip.installed</span><span class="Special">:</span>&#x000A;    <span class="Statement">- </span><span class="Identifier">name</span><span class="Special">:</span> mysql&#x000A;  <span class="Identifier">mysql_database.present</span><span class="Special">:</span>&#x000A;    <span class="Statement">- </span><span class="Identifier">name</span><span class="Special">:</span> wordpress&#x000A;  <span class="Identifier">mysql_user.present</span><span class="Special">:</span>&#x000A;    <span class="Statement">- </span><span class="Identifier">name</span><span class="Special">:</span> wordpress&#x000A;    <span class="Statement">- </span><span class="Identifier">password</span><span class="Special">:</span> XYZ987&#x000A;  <span class="Identifier">mysql_grants.present</span><span class="Special">:</span>&#x000A;    <span class="Statement">- </span><span class="Identifier">database</span><span class="Special">:</span> wordpress.*&#x000A;    <span class="Statement">- </span><span class="Identifier">grant</span><span class="Special">:</span> ALL PRIVILEGES&#x000A;    <span class="Statement">- </span><span class="Identifier">user</span><span class="Special">:</span> wordpress&#x000A;    <span class="Statement">- </span><span class="Identifier">host</span><span class="Special">:</span> <span class="Constant">'</span><span class="Constant">localhost</span><span class="Constant">'</span>&#x000A;</pre>
      <p>
        Now we can fetch and install WordPress itself. By specifying a path that
        should exist using <em>creates</em> we allow this to run only once. If we wish
        to wipe and reinstall we would simply rename the <em>wordpress</em> directory.
      </p>
      <pre>&#x000A;<span class="Identifier">/var/www/wordpress</span><span class="Special">:</span>&#x000A;  <span class="Identifier">file.directory</span><span class="Special">:</span>&#x000A;    <span class="Statement">- </span><span class="Identifier">owner</span><span class="Special">:</span> www&#x000A;    <span class="Statement">- </span><span class="Identifier">group</span><span class="Special">:</span> www&#x000A;&#x000A;<span class="Identifier">get_wordpress</span><span class="Special">:</span>&#x000A;  <span class="Identifier">cmd.run</span><span class="Special">:</span>&#x000A;    <span class="Statement">- </span><span class="Identifier">name</span><span class="Special">:</span> <span class="Constant">'</span><span class="Constant">wget <a href="http://wordpress.org/latest.tar.gz">http://wordpress.org/latest.tar.gz</a> &amp;&amp; tar xvzf latest.tar.gz</span><span class="Constant">'</span>&#x000A;    <span class="Statement">- </span><span class="Identifier">cwd</span><span class="Special">:</span> /var/www&#x000A;    <span class="Statement">- </span><span class="Identifier">creates</span><span class="Special">:</span> /var/www/wordpress/index.php&#x000A;    <span class="Statement">- </span><span class="Identifier">runas</span><span class="Special">:</span> www&#x000A;</pre>
      <p>
        WordPress needs to know the database connection parameters, which is set in
        <em>wp-config.php</em>
      </p>
      <pre>&#x000A;<span class="Identifier">/var/www/wordpress/wp-config.php</span><span class="Special">:</span>&#x000A;  <span class="Identifier">file.managed</span><span class="Special">:</span>&#x000A;    <span class="Statement">- </span><span class="Identifier">source</span><span class="Special">:</span> salt://vm/wp-config.php&#x000A;    <span class="Statement">- </span><span class="Identifier">owner</span><span class="Special">:</span> www&#x000A;    <span class="Statement">- </span><span class="Identifier">group</span><span class="Special">:</span> www&#x000A;</pre>
      <p>
        To establish FCGI communication to the service running PHP we can use
        <em>file.replace</em> to change only one line in the <em>php-fpm</em>
        configuration. This is a very nice option when you do not want to keep the
        entire file in sync
      </p>
      <pre>&#x000A;<span class="Identifier">/etc/php-fpm.conf</span><span class="Special">:</span>&#x000A;  <span class="Identifier">file.replace</span><span class="Special">:</span>&#x000A;    <span class="Statement">- </span><span class="Identifier">pattern</span><span class="Special">:</span> <span class="Constant">&quot;</span><span class="Constant">listen = /var/www/run/php-fpm.sock</span><span class="Constant">&quot;</span>&#x000A;    <span class="Statement">- </span><span class="Identifier">repl</span><span class="Special">:</span> <span class="Constant">&quot;</span><span class="Constant">listen = 127.0.0.1:9000</span><span class="Constant">&quot;</span>&#x000A;    <span class="Statement">- </span><span class="Identifier">append_if_not_found</span><span class="Special">:</span> <span class="Constant">True</span>&#x000A;</pre>
      <p>
        Finally we'll install the Nginx configuration and set the service to reload
        whenever <em>nginx.conf</em> changes
      </p>
      <pre>&#x000A;<span class="Identifier">/etc/nginx/nginx.conf</span><span class="Special">:</span>&#x000A;  <span class="Identifier">file.managed</span><span class="Special">:</span>&#x000A;    <span class="Statement">- </span><span class="Identifier">source</span><span class="Special">:</span> salt://vm/nginx.conf&#x000A;    <span class="Statement">- </span><span class="Identifier">user</span><span class="Special">:</span> root&#x000A;    <span class="Statement">- </span><span class="Identifier">group</span><span class="Special">:</span> wheel&#x000A;    <span class="Statement">- </span><span class="Identifier">mode</span><span class="Special">:</span> <span class="Constant">644</span>&#x000A;&#x000A;<span class="Identifier">nginx</span><span class="Special">:</span>&#x000A;  <span class="Identifier">service.running</span><span class="Special">:</span>&#x000A;    <span class="Statement">- </span><span class="Identifier">watch</span><span class="Special">:</span>&#x000A;      <span class="Statement">- </span><span class="Identifier">file</span><span class="Special">:</span> /etc/nginx/nginx.conf&#x000A;</pre>
      <p>
        The section from <em>nginx.conf</em> that points to our new WordPress
        installation
      </p>
      <pre>&#x000A;  server {&#x000A;      listen 162.213.37.87:80;&#x000A;      server_name pineconeperfections.com www.pineconeperfections.com;&#x000A;      root /var/www/wordpress;&#x000A;      index index.php;&#x000A;&#x000A;      location ~ \.php$ {&#x000A;          try_files $uri $uri/ =404;&#x000A;          include fastcgi_params;&#x000A;          fastcgi_index index.php;&#x000A;          fastcgi_pass 127.0.0.1:9000;&#x000A;          fastcgi_intercept_errors on;&#x000A;          fastcgi_param SCRIPT_FILENAME wordpress$fastcgi_script_name;&#x000A;      }&#x000A;&#x000A;      access_log   /var/www/logs/pineconeperfections.log main;&#x000A;  }&#x000A;</pre>
      <p>
        After putting all of these steps in order it makes it possible to see how the
        service operates and how the components relate.
      </p>
    </div>
    <p class='timestamp'>
      Last updated on November 26, 2016
    </p>
  </body>
</html>
