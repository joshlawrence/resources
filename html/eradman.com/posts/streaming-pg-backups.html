<!DOCTYPE html>
<html>
  <head>
    <title>
      Streaming Backups
    </title>
    <meta content='text/html; charset=US-ASCII' http-equiv='Content-Type'>
    <link href='../main.css' rel='stylesheet' type='text/css'>
    <link href='../code.css' rel='stylesheet' type='text/css'>
  </head>
  <body>
    <h3 style='margin-left: 5px; margin-top: 20px;'>
      <a href='../index.html' id='myname'>Eric Radman</a>
      <span id='mytitle'>: a Journal</span>
    </h3>
    <div id='article'>
      <h1>Streaming Backups</h1>
      <p>
        Sometimes you take up a task because it needs to be done even though no one
        will notice. Setting up backups with real-time updates and point-in-time
        recovery may go unnoticed for a period, but it is not a thankless task.
      </p>
      <p>
        The first time something very bad happens you will have a good story to tell.
        This story includes the fact that we have proper backups, but it also includes
        the changes and updates that you make every day to enable applications to
        evolve and adapt. Daily changes are best made under conditions are calm.
      </p>
      <p>
        Mistakes will happen, and when they do a full database replica with streaming
        updates provide the means of recovering. Not living in terror of data loss
        means you can get a good nights rest, and write better software during the
        day. If this software can be moved into production without too much fuss you
        will definitely be thanked.
      </p>
      <h2>Making a Copy</h2>
      <p>
        In times past rsync (bracketed with invocations to
        <em>pg_start_backup()</em>, <em>pg_stop_backup()</em>) was the most
        effective way of brining up a new standby server, but these days <a
        href="http://www.postgresql.org/docs/9.5/static/app-pgbasebackup.html">pg_basebackup</a>
        is usually safer and more elegant. It operates by connecting as a
        client, so we need configure the database server as a master first by
        amending <em>postgresql.conf</em>
      </p>
      <pre>&#x000A;<span class="Comment"># postgresql.conf</span>&#x000A;wal_level <span class="Statement">=</span> hot_standby&#x000A;max_wal_senders <span class="Statement">=</span> <span class="Constant">4</span>&#x000A;wal_keep_segments <span class="Statement">=</span> <span class="Constant">100</span>&#x000A;</pre>
      <p>
        The value of <em>wal_keep_segments</em> instructs the server to keep at least
        this number of WAL logs. This will allow a replica to catch up if it is
        disconnected. For the purpose of a backup it also allows us to sync up after
        the initial clone.
      </p>
      <p>
        After a reload we can create a copy of the master using
      </p>
      <pre>&#x000A;pg_basebackup <span class="Special">-U</span> postgres <span class="Special">-D</span> backup&#x000A;</pre>
      <p>
        Hopefully you are taking this one step further to create an off-site replica.
        We can use <a href="http://www.ivarch.com/programs/pv.shtml">pv</a> utility or
        the built-in <em>--max-rate</em> option to rate-limit the stream over a WAN:
      </p>
      <pre>&#x000A;mkdir <span class="Special">-m</span> <span class="Constant">0700</span> backup&#x000A;<span class="Statement">cd</span> backup&#x000A;pg_basebackup <span class="Special">-h</span> primary <span class="Special">-U</span> postgres <span class="Special">-D</span> - <span class="Special">-Ft</span> <span class="Special">-x</span> <span class="Special">-z</span> <span class="Special">-vP</span> <span class="Statement">\</span>&#x000A;       <span class="Special">--max-rate=10M</span> | tar <span class="Special">-xzf</span> -</pre>
      <p>
        The options supplied to <em>pg_basebackup</em> will stream the results over
        STDOUT in the tar format while displaying periodic progress updates on STDERR.
      </p>
      <pre>&#x000A;LOG:  transaction log start point: 0/5000024 on timeline 1&#x000A;LOG:  42286/42286 kB (100%), 1/1 tablespace&#x000A;LOG:  transaction log end point: 0/50000DC&#x000A;LOG:  pg_basebackup: base backup completed&#x000A;</pre>
      <p>
        Note that everything is copied from the master, including configuration files
        and log files. Before cloning a busy server be sure to trim the contents of
        <em>/pg_log</em>
      </p>
      <p>
        Starting a server to access the new backup is now as easy as starting up the
        server using the cloned data directory
      </p>
      <pre>&#x000A;cp <span class="Special">-R</span> backup backup_copy&#x000A;pg_ctl <span class="Special">-D</span> backup_copy start&#x000A;</pre>
      <p>
        Tailing <em>pg_log/*</em> sould indicate that the server was able to reach a
        consistent state
      </p>
      <pre>&#x000A;LOG:  creating missing WAL directory &quot;pg_xlog/archive_status&quot;&#x000A;LOG:  redo starts at 36/750000C8&#x000A;LOG:  consistent recovery state reached at 36/75751FC8&#x000A;&#x000A;</pre>
      <h2>Point-in-Time Recovery</h2>
      <p>
        Now that we have a clone, <a
        href="http://www.postgresql.org/docs/9.5/static/app-pgreceivexlog.html">pg_receivexlog</a>
        can be used to stream transaction logs from the primary
      </p>
      <pre>&#x000A;pg_receivexlog <span class="Special">-h</span> primary <span class="Special">-U</span> postgres <span class="Special">-D</span> backup&#x000A;</pre>
      <p>
        Running a replica will usually protect you from a hardware failure, it will
        not protect you from operator error or a faulty application.
        <a
        href="http://www.postgresql.org/docs/9.5/static/continuous-archiving.html">Point-in-time
        recovery</a> enables you to replay the transactions up to a specific point in
        time. It is activated by defining <em>recovery_target_time</em> in
        <em>recovery.conf</em> then Postgres will replay each transaction log until
        the specified timestamp
      </p>
      <pre>&#x000A;<span class="Comment"># recovery.conf</span>&#x000A;recovery_target_time <span class="Statement">=</span> <span class="Constant">'2015-06-29 08:00:00'</span>&#x000A;restore_command <span class="Statement">=</span> <span class="Constant">'cp /pg_backup/wals/%f %p'</span>&#x000A;</pre>
      <p>
        The <em>restore_command</em> is used to copy files from an transaction log
        archive.  The examples above are not using the archive feature, but this
        command is still required. When the server is started the
        <em>restore_command</em> is executed, will fail (because
        <em>/pg_backup/pg_xlog/</em> does not exist) and the data used in
        <em>pg_xlog</em> will be used instead.
      </p>
      <pre>&#x000A;pg_ctl <span class="Special">-D</span> backup start&#x000A;</pre>
      <p>
        Postgres will record that it is running a point-in-time recovery to the
        specified time
      </p>
      <pre>&#x000A;LOG:  starting point-in-time recovery to 2015-06-29 08:00:00-04&#x000A;LOG:  database system was not properly shut down; automatic recovery in&#x000A;LOG:  redo starts at 36/756E53B8&#x000A;</pre>
      <p>
        Once the restore succeeds <em>recovery.conf</em> is renamed to
        <em>restore.conf</em> and the server starts up in master mode with a new
        timeline.
      </p>
      <p>
        All of this can be scripted and orchestrated, in my view this is exactly what
        <a href="http://www.pgbarman.org/">Barman</a> does, and it does it well.
      </p>
      <h2>Establishing a Delayed Replica</h2>
      <p>
        Storing WAL using <em>pg_receivexlog</em> works well for keeping transaction
        logs, but there is no way to apply these regularly, so a fresh full backup
        needs to taken periodically. Starting a server in-place on the backup will
        replay the WALL up to date, but a new timeline will be established during this
        process which will prevent us from receiving further WAL updates.
      </p>
      <p>
        [I think] the most elegant solution to this is to run "live backups" using a
        delayed replica.
      </p>
      <pre>&#x000A;<span class="Comment"># recovery.conf</span>&#x000A;recovery_min_apply_delay <span class="Statement">=</span> <span class="Constant">'5d'</span>&#x000A;</pre>
      <p>
        Since these servers are mostly idling inbetween update appliation a bunch of
        them can be run on a single host using different port numbers, or my
        preference is to stand them up in limited footprint VMs in way nearly
        identical to every other standby.
      </p>
      <h2>Daily Verification</h2>
      <p>
        One way to verify a physical replica is to measure the delta between
        transaction IDs on the master and the backup
      </p>
      <pre>&#x000A;<span class="Identifier">backup_txid</span>=<span class="Error">$(</span><span class="Special">ssh </span><span class="PreProc">$host</span><span class="Special"> </span><span class="Statement">&quot;</span><span class="Constant">psql -At -c 'SELECT txid_current()'</span><span class="Statement">&quot;</span><span class="Error">)</span>&#x000A;<span class="Comment"># copy database and start in place</span>&#x000A;<span class="Identifier">restore_txid</span>=<span class="Error">$(</span><span class="Special">psql </span><span class="Special">-At</span><span class="Special"> </span><span class="Special">-c</span><span class="Special"> </span><span class="Statement">'</span><span class="Constant">SELECT txid_current()</span><span class="Statement">'</span><span class="Error">)</span>&#x000A;<span class="Statement">echo</span><span class="Constant"> </span><span class="PreProc">$restore_txid</span><span class="Constant"> </span><span class="PreProc">$backup_txid</span><span class="Constant"> </span>| awk <span class="Special">-f</span> compare.awk <span class="Statement">&gt;</span> <span class="PreProc">$host</span>.verify/compare.out&#x000A;</pre>
      <p>
        Admittedly relying an arbitrary TXID delta (I use 6000) can raise false
        positives, but it will not miss a replica who has fallen behind.
      </p>
      <p></p>
      <pre>&#x000A;<span class="Special">BEGIN</span> { xid_max_delta<span class="Special">=</span><span class="Constant">6000</span><span class="Special">;</span> }&#x000A;{&#x000A;<span class="Statement">if</span> (<span class="Special">$2</span> <span class="Special">-</span> <span class="Special">$1</span> &lt; xid_max_delta)&#x000A;    <span class="Statement">print</span> <span class="Constant">&quot;xids&quot;</span><span class="Special">,</span><span class="Special">$0</span><span class="Special">,</span><span class="Constant">&quot;=&gt; Pass&quot;</span><span class="Special">;</span>&#x000A;<span class="Statement">else</span>&#x000A;    <span class="Statement">print</span> <span class="Constant">&quot;xids&quot;</span><span class="Special">,</span><span class="Special">$0</span><span class="Special">,</span><span class="Constant">&quot;=&gt; Fail&quot;</span><span class="Special">;</span>&#x000A;}&#x000A;</pre>
      <p>
        Finally, notification and alerting can be handled by some combination of
        syslog and e-mail
      </p>
      <pre>&#x000A;logger <span class="Special">-t</span> <span class="Statement">&quot;</span><span class="Constant">pg_verifybackup </span><span class="PreProc">$host</span><span class="Statement">&quot;</span> <span class="Special">-p</span> local0.notice &amp;lt; <span class="PreProc">$host</span>.verify/compare.out&#x000A;grep <span class="Special">-q</span> <span class="Statement">&quot;</span><span class="Constant">Pass</span><span class="Statement">&quot;</span> <span class="PreProc">$host</span> <span class="PreProc">$host</span>.verify/compare.out&#x000A;</pre>
      <p>
        The <a href="https://bitbucket.org/eradman/pg-verify">pg-verify</a> project
        provides a simple implementation of this process.
      </p>
    </div>
    <p class='timestamp'>
      Last updated on January 11, 2017
    </p>
  </body>
</html>
